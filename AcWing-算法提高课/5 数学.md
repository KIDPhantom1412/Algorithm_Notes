# 5 数学

## 筛质数

### 哥德巴赫猜想

题目：https://www.acwing.com/problem/content/description/1294/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout, std::string;

const int N = 1e6 + 10;

int n;
bool st[N];
int prime[N], cnt;

constexpr void init()
{
    int n = 1e6;
    for (int i = 2; i <= n; i++)
    {
        if (!st[i]) prime[cnt++] = i;

        for (int j = 0; prime[j] <= n / i; j++)
        {
            st[prime[j] * i] = true;
            if (i % prime[j] == 0) break;
        }
    }
}

void solve()
{
    for (int i = 1; i <= cnt / 2; i++)
        if (!st[n - prime[i]])
        {
            printf("%d = %d + %d\n", n, prime[i], n - prime[i]);
            return;
        }

    puts("Goldbach's conjecture is wrong.");
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    init();

    while (cin >> n, n)
        solve();

    return 0;
}
```

### 夏洛克和他的女朋友

题目：https://www.acwing.com/problem/content/description/1295/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout, std::string;

const int N = 1e5 + 10;

int n;
bool st[N];
int prime[N], cnt;

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    n++;

    for (int i = 2; i <= n; i++)
    {
        if (!st[i]) prime[cnt++] = i;

        for (int j = 0; prime[j] <= n / i; j++)
        {
            st[prime[j] * i] = true;
            if (i % prime[j] == 0) break;
        }
    }

    cout << (cnt == n - 1 ? 1 : 2) << '\n';
    for (int i = 2; i <= n; i++) 
    {
        if (!st[i]) cout << 1 << ' ';
        else cout << 2 << ' ';
    }
    cout << '\n';

    return 0;
}
```

### 质数距离

题目：https://www.acwing.com/problem/content/description/198/

题解：https://www.acwing.com/solution/content/45722/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout, std::string;
using std::max;
using LL = long long;

const int N = 1e6 + 10;

bool st[N];
int prime[N], cnt;

void sieve(int n)
{
    bzero(st, sizeof st);
    cnt = 0;
    for (int i = 2; i <= n; i++)
    {
        if (!st[i]) prime[cnt++] = i;

        for (int j = 0; prime[j] <= n / i; j++)
        {
            st[prime[j] * i] = true;
            if (i % prime[j] == 0) break;
        }
    }
}

int l, r;

void solve()
{
    sieve(5e4);

    bzero(st, sizeof st);
    for (int i = 0; i < cnt; i++)
    {
        LL p = prime[i];
        for (LL j = max((l + p - 1) / p * p, p * 2); j <= r; j += p)
            st[j - l] = true;
    }

    cnt = 0;
    for (int i = 0; i < r - l + 1; i++)
        if (!st[i] && i + l > 1) prime[cnt++] = i + l;

    int mn = 0, mx = 0;
    for (int i = 1; i < cnt - 1; i++)
    {
        if (prime[i + 1] - prime[i] < prime[mn + 1] - prime[mn])
            mn = i;
        if (prime[i + 1] - prime[i] > prime[mx + 1] - prime[mx])
            mx = i;
    }

    if (cnt < 2) puts("There are no adjacent primes.");
    else printf("%d,%d are closest, %d,%d are most distant.\n", 
        prime[mn], prime[mn + 1], 
        prime[mx], prime[mx + 1]);
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    while (cin >> l >> r)
        solve();

    return 0;
}
```

## 分解质因数

### 阶乘分解

题目：https://www.acwing.com/problem/content/submission/199/

勒让德定理

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout, std::string;
using LL = long long;

const int N = 1e6 + 10;

bool st[N];
int prime[N], cnt;

void sieve(int n)
{
    for (int i = 2; i <= n; i++)
    {
        if (!st[i]) prime[cnt++] = i;
        for (int j = 0; prime[j] <= n / i; j++)
        {
            st[prime[j] * i] = true;
            if (i % prime[j] == 0) break;
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int n; cin >> n;
    sieve(n);

    for (int i = 0; i < cnt; i++)
    {
        int p = prime[i], c = 0;
        // for (int j = n; j >= p; j /= p) c += j / p; // 除法比较慢
        for (LL j = p; j <= n; j *= p) c += n / j;
        cout << p << ' ' << c << '\n';
    }

    return 0;
}
```

## 快速幂

### 序列的第k个数

题目：https://www.acwing.com/problem/content/description/1291/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout, std::string;
using LL = long long;

const int MOD = 200907;

int FP(int a, int b)
{
    int res = 1;
    while (b)
    {
        if (b & 1) res = (LL(res) * a) % MOD;
        a = (LL(a) * a) % MOD;
        b >>= 1;
    }
    return res;
}

void solve()
{
    int a, b, c; cin >> a >> b >> c;
    int k; cin >> k;
    if (a + c == b * 2) cout << (a + LL(b - a) * (k - 1)) % MOD << '\n';
    else cout << LL(a) * FP(b / a, k - 1) % MOD << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int T; cin >> T;
    while (T--)
        solve();

    return 0;
}
```

### 越狱

题目：https://www.acwing.com/problem/content/description/1292/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout, std::string;
using LL = long long;

const int MOD = 100003;

int FP(LL a, LL b)
{
    int res = 1;
    while (b)
    {
        if (b & 1) res = (res * a) % MOD;
        a = (a * a) % MOD;
        b >>= 1;
    }
    return res;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    LL m, n;
    cin >> m >> n;

    cout << ((FP(m, n) - m * FP(m - 1, n - 1) % MOD) % MOD + MOD) % MOD << '\n';

    return 0;
}
```

## 约数个数

### 轻拍牛头

题目：https://www.acwing.com/problem/content/description/1293/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

const int N = 1e5 + 10, M = 1e6 + 10;

int n;
int A[N];
int cnt[M], sum[M];

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    int mx = 0, mn = M;
    for (int i = 1; i <= n; i++)
    {
        cin >> A[i];
        cnt[A[i]]++;
        mx = std::max(mx, A[i]);
        mn = std::min(mn, A[i]);
    }

    for (int i = mn; i <= mx; i++)
        if (cnt[i])
            for (int j = i; j <= mx; j += i)
                sum[j] += cnt[i];

    for (int i = 1; i <= n; i++) cout << sum[A[i]] - 1 << '\n';

    return 0;
}
```

### 樱花

题目：https://www.acwing.com/problem/content/description/1296/

题解：https://www.acwing.com/solution/content/47739/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

const int N = 1e6 + 10, MOD = 1e9 + 7;

bool st[N];
int prime[N], cnt;

void sieve(int n)
{
    for (int i = 2; i <= n; i++)
    {
        if (!st[i]) prime[cnt++] = i;
        for (int j = 0; prime[j] <= n / i; j++)
        {
            st[prime[j] * i] = true;
            if (i % prime[j] == 0) break;
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int n; cin >> n;
    sieve(n);

    int res = 1;
    for (int i = 0; i < cnt; i++)
    {
        int p = prime[i], c = 0;
        for (int j = n / p; j > 0; j /= p) c += j;
        res = (LL(res) * (2 * c + 1)) % MOD;
    }

    cout << res << '\n';

    return 0;
}
```

### 反素数

题目：https://www.acwing.com/problem/content/description/200/

题解：https://www.acwing.com/solution/content/47849/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

int n, cnt, num;
int prime[9] = {2, 3, 5, 7, 11, 13, 17, 19, 23};

void DFS(int u, int p, int c, int mx)
{
    if (c > cnt || (c == cnt && p < num))
    {
        num = p, cnt = c;
    }

    if (u == 9) return;

    for (int i = 1; i <= mx; i++)
    {
        if (LL(p) * prime[u] > n) break;
        p *= prime[u];
        DFS(u + 1, p, c * (i + 1), i);
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    DFS(0, 1, 1, 30);

    cout << num << '\n';

    return 0;
}
```

### Hankson的趣味题

题目：https://www.acwing.com/problem/content/description/202/

题解：https://www.acwing.com/solution/content/3101/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>

using std::cin, std::cout;
using LL = long long;

const int N = 5e4;

int a0, a1, b0, b1;
bool st[N];
int prime[N], cnt;

void sieve(int n)
{
    for (int i = 2; i <= n; i++)
    {
        if (!st[i]) prime[cnt++] = i;
        for (int j = 0; LL(prime[j]) * i <= n; j++)
        {
            st[prime[j] * i] = true;
            if (i % prime[j] == 0) break;
        }
    }
}

struct Node
{
    int p, c;
};
std::vector<Node> factor;

void decom(int n)
{
    for (int i = 0; LL(prime[i]) * prime[i] <= n; i++)
    {
        int p = prime[i];
        if (n % p == 0)
        {
            int c = 0;
            while (n % p == 0)
            {
                n /= p;
                c++;
            }
            factor.push_back({p, c});
        }
    }
    if (n > 1) factor.push_back({n, 1});
}

std::vector<int> candidate;

void DFS(int u, int p)
{
    if (u == factor.size())
    {
        candidate.push_back(p);
        return;
    }

    int a = factor[u].p, b = factor[u].c;
    for (int i = 0; i <= b; i++)
    {
        DFS(u + 1, p);
        p *= a;
    }
}

int GCD(int a, int b)
{
    return b ? GCD(b, a % b) : a;
}

LL LCM(int a, int b)
{
    return LL(a / GCD(a, b)) * b;
}

void solve()
{
    factor.clear();
    candidate.clear();

    cin >> a0 >> a1 >> b0 >> b1;
    decom(b1);

    DFS(0, 1);

    int res = 0;
    for (int x : candidate)
    {
        if (GCD(a0, x) == a1 && LCM(b0, x) == b1)
            res++;
    }

    cout << res << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    sieve(N - 1);

    int T; cin >> T;
    while (T--)
        solve();

    return 0;
}
```

## 欧拉函数

### 可见的点

题目：https://www.acwing.com/problem/content/description/203/

题解：https://www.acwing.com/solution/content/25745/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <bitset>
#include <vector>

using std::cin, std::cout;
using LL = long long;

const int N = 1010;

int T;
std::bitset<N> st;
std::vector<int> prime;
std::vector<int> phi;

void sieve(int n)
{
    phi.resize(n + 1);
    phi[1] = 1;
    for (int i = 2; i <= n; i++)
    {
        if (!st[i])
        {
            prime.push_back(i);
            phi[i] = i - 1;
        }
        for (int p : prime)
        {
            if (LL(p) * i > n) break;
            st[p * i] = true;
            if (i % p == 0)
            {
                phi[p * i] = phi[i] * p;
                break;
            }
            phi[p * i] = phi[i] * (p - 1);
        }
    }
}

void solve()
{
    int n; cin >> n;
    int res = 0;
    for (int i = 2; i <= n; i++) res += phi[i];
    res = res * 2 + 3;
    cout << T << ' ' << n << ' ' << res << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    sieve(N - 1);

    int n; cin >> n;
    for (T = 1; T <= n; T++)
        solve();

    return 0;
}
```

### 最大公约数

题目：https://www.acwing.com/problem/content/description/222/

题解：https://www.acwing.com/solution/content/25752/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <bitset>

using std::cin, std::cout;
using LL = long long;

const int N = 1e7 + 10;

std::bitset<N> st;
int prime[N], cnt;
int phi[N];

void sieve(int n)
{
    phi[1] = 1;
    for (int i = 2; i <= n; i++)
    {
        if (!st[i])
        {
            prime[cnt++] = i;
            phi[i] = i - 1;
        }
        for (int j = 0; LL(prime[j]) * i <= n; j++)
        {
            int p = prime[j];
            st[p * i] = true;
            if (i % p == 0)
            {
                phi[p * i] = p * phi[i];
                break;
            }
            phi[p * i] = (p - 1) * phi[i];
        }
    }
}

LL ps[N];

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int n; cin >> n;
    sieve(n);
    for (int i = 1; i <= n; i++) ps[i] = ps[i - 1] + phi[i];

    LL res = 0;
    for (int i = 0; i < cnt; i++)
    {
        int p = prime[i];
        res += ps[n / p] * 2 - 1;
    }

    cout << res << '\n';

    return 0;
}
```

## 同余

### 同余方程

题目：https://www.acwing.com/problem/content/205/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

int exGCD(int a, int b, int &x, int &y)
{
    if (b == 0)
    {
        x = 1, y = 0;
        return a;
    }

    int d = exGCD(b, a % b, y, x);
    y -= (a / b) * x;

    return d;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int a, b; cin >> a >> b;
    int x, y;
    exGCD(a, b, x, y);
    
    cout << (LL(x % b) + b) % b << '\n';

    return 0;
}
```

### 青蛙的约会

题目：https://www.acwing.com/problem/content/description/224/

从数学上来说，最大公约数是正数。但在这里`exGCD(a, b, u, v)`有可能会返回负数，此时的`ua + vb`也是负数。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

int exGCD(int a, int b, LL &x, LL &y)
{
    if (b == 0)
    {
        x = 1, y = 0;
        return a;
    }

    int d = exGCD(b, a % b, y, x);
    y -= a / b * x;
    return d;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int x, y, m, n, L; cin >> x >> y >> m >> n >> L;
    LL u = 0, v = 0;
    int a = m - n, b = y - x;
    int d = exGCD(a, L, u, v);
    if (b % d) cout << "Impossible" << '\n';
    else
    {
        LL t = u * b / d;
        int s = std::abs(L / d);
        cout << (t % s + s) % s << '\n';
    }

    return 0;
}
```

### 最幸运的数字

题目：https://www.acwing.com/problem/content/description/204/

题解：https://www.acwing.com/solution/content/47979/

```c++
#include <cstdio>
#include <cstring>
#include <climits>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

int T, L;

int GCD(int a, int b)
{
    return b ? GCD(b, a % b) : a;
}

LL getEuler(LL n)
{
    LL res = n;
    for (LL p = 2; p * p <= n; p++)
        if (n % p == 0)
        {
            while (n % p == 0) n /= p;
            res = res / p * (p - 1);
        }
    if (n > 1) res = res / n * (n - 1);
    return res;
}

LL SM(LL a, LL b, LL m)
{
    LL res = 0;
    while (b)
    {
        if (b & 1) res = (res + a) % m;
        a = (a + a) % m;
        b >>= 1;
    }
    return res;
}

LL FP(LL a, LL b, LL m)
{
    LL res = 1;
    while (b)
    {
        if (b & 1) res = SM(res, a, m);
        a = SM(a, a, m);
        b >>= 1;
    }
    return res;
}

void solve()
{
    int d = GCD(L, 8);
    LL m = 9L * L / d;
    LL phi = getEuler(m);

    LL res = LONG_LONG_MAX;
    if (m % 2 == 0 || m % 5 == 0) res = 0;
    else
    {
        for (LL i = 1; i * i <= phi; i++)
            if (phi % i == 0)
            {
                LL j = phi / i;
                if (FP(10, i, m) == 1) res = std::min(res, i);
                if (FP(10, j, m) == 1) res = std::min(res, j);
            }
    }

    printf("Case %d: %lld\n", ++T, res);
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    while (cin >> L, L)
        solve();

    return 0;
}
```

### 曹冲养猪

题目：https://www.acwing.com/problem/content/description/1300/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

const int N = 15;

int n;
int A[N], B[N];

LL exGCD(LL a, LL b, LL &x, LL &y)
{
    if (!b)
    {
        x = 1, y = 0;
        return a;
    }
    
    LL d = exGCD(b, a % b, y, x);
    y -= a / b * x;
    return d;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    LL M = 1;
    cin >> n;
    for (int i = 0; i < n; i++)
    {
        cin >> A[i] >> B[i];
        M *= A[i];
    }

    LL x = 0;
    for (int i = 0; i < n; i++)
    {
        LL Mi = M / A[i], Ni = 0;
        LL t = 0;
        exGCD(Mi, A[i], Ni, t);
        x += ((__int128)Mi * Ni % M) * B[i] % M;
    }

    cout << (x % M + M) % M << '\n';

    return 0;
}
```

## 矩阵乘法

### 斐波那契前 n 项和

题目：https://www.acwing.com/problem/content/description/1305/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

int n, m;

int A[3][3] = {
    {0, 1, 0},
    {1, 1, 1},
    {0, 0, 1}
};
int F[3] = {1, 1, 1};

void mul(int C[3], int A[3], int B[3][3])
{
    static int tmp[3];
    bzero(tmp, sizeof tmp);

    for (int i = 0; i < 3; i++)
        for (int j = 0; j < 3; j++)
            tmp[i] = (tmp[i] + LL(A[j]) * B[j][i] % m) % m;

    memcpy(C, tmp, sizeof tmp);
}

void mul(int C[3][3], int A[3][3], int B[3][3])
{
    static int tmp[3][3];
    bzero(tmp, sizeof tmp);

    for (int i = 0; i < 3; i++)
        for (int j = 0; j < 3; j++)
            for (int k = 0; k < 3; k++)
                tmp[i][j] = (tmp[i][j] + LL(A[i][k]) * B[k][j] % m) % m;

    memcpy(C, tmp, sizeof tmp);
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    int b = n - 1;
    while (b)
    {
        if (b & 1) mul(F, F, A);
        mul(A, A, A);
        b >>= 1;
    }

    cout << F[2] % m << '\n';

    return 0;
}
```

### 佳佳的斐波那契

题目：https://www.acwing.com/problem/content/1306/

题解：https://www.acwing.com/solution/content/83638/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

int n, m;
int F[5] = {1, 1, 1, 2, 1};
int A[5][5] = {
    {0, 1, 0, 2, 0},
    {1, 1, 0, 1, 0},
    {0, 0, 0, 1, 0},
    {0, 0, 1, 1, 1},
    {0, 0, 0, 0, 1},
};

void mul(int C[5], int A[5], int B[5][5])
{
    static int tmp[5];
    bzero(tmp, sizeof tmp);

    for (int i = 0; i < 5; i++)
        for (int j = 0; j < 5; j++)
            tmp[i] = (tmp[i] + LL(A[j]) * B[j][i]) % m;

    memcpy(C, tmp, sizeof tmp);
}

void mul(int C[5][5], int A[5][5], int B[5][5])
{
    static int tmp[5][5];
    bzero(tmp, sizeof tmp);

    for (int i = 0; i < 5; i++)
        for (int j = 0; j < 5; j++)
            for (int k = 0; k < 5; k++)
                tmp[i][j] = (tmp[i][j] + LL(A[i][k]) * B[k][j]) % m;

    memcpy(C, tmp, sizeof tmp);
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    int b = n - 1;
    while (b)
    {
        if (b & 1) mul(F, F, A);
        mul(A, A, A);
        b >>= 1;
    }

    cout << F[4] % m << '\n';

    return 0;
}
```

题解：https://www.acwing.com/solution/content/48039/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

int n, m;
int F[4] = {1, 1, 1, 0};
int A[4][4] = {
    {0, 1, 0, 0},
    {1, 1, 1, 0},
    {0, 0, 1, 1},
    {0, 0, 0, 1},
};

void mul(int C[4], int A[4], int B[4][4])
{
    static int tmp[4];
    bzero(tmp, sizeof tmp);

    for (int i = 0; i < 4; i++)
        for (int j = 0; j < 4; j++)
            tmp[i] = (tmp[i] + LL(A[j]) * B[j][i]) % m;

    memcpy(C, tmp, sizeof tmp);
}

void mul(int C[4][4], int A[4][4], int B[4][4])
{
    static int tmp[4][4];
    bzero(tmp, sizeof tmp);

    for (int i = 0; i < 4; i++)
        for (int j = 0; j < 4; j++)
            for (int k = 0; k < 4; k++)
                tmp[i][j] = (tmp[i][j] + LL(A[i][k]) * B[k][j]) % m;

    memcpy(C, tmp, sizeof tmp);
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    int b = n - 1;
    while (b)
    {
        if (b & 1) mul(F, F, A);
        mul(A, A, A);
        b >>= 1;
    }

    int s = F[2], p = F[3];
    cout << ((LL(n) * s - p) % m + m) % m << '\n';

    return 0;
}
```

### GT考试

题目：https://www.acwing.com/problem/content/description/1307/

题解：https://www.acwing.com/solution/content/46059/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

const int M = 25;

int n, m, K;

std::string p;
int next[M];

void getNext()
{
    for (int i = 2, j = 0; i <= m; i++)
    {
        while (j > 0 && p[j + 1] != p[i]) j = next[j];
        if (p[j + 1] == p[i]) j++;
        next[i] = j;
    }
}

int F[M];
int A[M][M];

void mul(int C[M], int A[M], int B[M][M])
{
    static int tmp[M];
    bzero(tmp, sizeof tmp);

    for (int i = 0; i < m; i++)
        for (int j = 0; j < m; j++)
            tmp[i] = (tmp[i] + A[j] * B[j][i]) % K;

    memcpy(C, tmp, sizeof tmp);
}

void mul(int C[M][M], int A[M][M], int B[M][M])
{
    static int tmp[M][M];
    bzero(tmp, sizeof tmp);

    for (int i = 0; i < m; i++)
        for (int j = 0; j < m; j++)
            for (int k = 0; k < m; k++)
                tmp[i][j] = (tmp[i][j] + A[i][k] * B[k][j]) % K;

    memcpy(C, tmp, sizeof tmp);
}

void FP()
{
    F[1] = 1, F[0] = 9;
    int b = n - 1;
    while (b)
    {
        if (b & 1) mul(F, F, A);
        mul(A, A, A);
        b >>= 1;
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m >> K;
    cin >> p; p = ' ' + p;

    getNext();

    for (int j = 0; j < m; j++)
        for (char c = '0'; c <= '9'; c++)
        {
            int k = j;
            while (k > 0 && p[k + 1] != c) k = next[k];
            if (p[k + 1] == c) k++;
            A[j][k]++;
        }

    FP();

    int res = 0;
    for (int j = 0; j < m; j++) res = (res + F[j]) % K;

    cout << res << '\n';
    return 0;
}
```

## 组合计数

### 牡牛和牝牛

题目：https://www.acwing.com/problem/content/description/1309/

题解：https://www.acwing.com/solution/content/48077/

实际上$f(i)$表示的是，最后一个是1的位置是$i$的方案数，这才能保证$f(i)$和$f(i - k - 1)$​之前的不重复。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

const int N = 1e5 + 10, MOD = 5000011;

int n, K;
int f[N], ps[N];

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> K;
    f[0] = ps[0] = 1;
    for (int i = 1; i <= n; i++)
    {
        f[i] = ps[std::max(i - K - 1, 0)];
        ps[i] = (ps[i - 1] + f[i]) % MOD;
    }

    cout << ps[n] << '\n';
    return 0;
}
```

### 方程的解

题目：https://www.acwing.com/problem/content/1310/

题解：https://www.acwing.com/solution/content/48085/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>

using std::cin, std::cout;
using std::vector;
using LL = long long;

const int N = 1010, M = 150, MOD = 1000;

int n, m;
vector<int> C[N][M];

int FP(int a, int b)
{
    a = a % MOD;
    int res = 1;
    while (b)
    {
        if (b & 1) res = (res * a) % MOD;
        a = (a * a) % MOD;
        b >>= 1;
    }
    return res;
}

void add(vector<int>& res, vector<int>& A, vector<int>& B)
{
    res.reserve(M);
    int la = A.size(), lb = B.size();
    int len = std::max(la, lb);
    int t = 0;
    for (int i = 0; i < len; i++)
    {
        if (i < la) t += A[i];
        if (i < lb) t += B[i];
        res.push_back(t % 10);
        t /= 10;
    }
    if (t > 0) res.push_back(t);
}

void show(vector<int>& A)
{
    for (auto it = A.rbegin(); it != A.rend(); it++) cout << *it;
    cout << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> m >> n;
    n = FP(n, n);

    for (int i = 0; i < n; i++) C[i][0].push_back(1);
    for (int i = 1; i < n; i++)
        for (int j = 1; j < m; j++)
            add(C[i][j], C[i - 1][j - 1], C[i - 1][j]);

    show(C[n - 1][m - 1]);

    return 0;
}
```

### 车的放置

题目：https://www.acwing.com/problem/content/description/1311/

题解：https://www.acwing.com/solution/content/17627/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

const int N = 2010, M = 100003;

int a, b, c, d, _k;
int fact[N], infact[N];

int FP(int a, int b)
{
    int res = 1;
    while (b)
    {
        if (b & 1) res = (LL(res) * a) % M;
        a = (LL(a) * a) % M;
        b >>= 1;
    }
    return res;
}

int C(int a, int b)
{
    return LL(fact[a]) * infact[a - b] % M * infact[b] % M;
}

int A(int a, int b)
{
    return LL(fact[a]) * infact[a - b] % M;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    fact[0] = infact[0] = 1;
    for (int i = 1; i < N; i++)
    {
        fact[i] = LL(fact[i - 1]) * i % M;
        infact[i] = FP(fact[i], M - 2);
    }

    cin >> a >> b >> c >> d >> _k;

    int res = 0;
    int start = std::max(_k - d, 0), end = std::min({a, b, _k});
    for (int i = start; i <= end; i++)
    {
        res = (res + LL(C(b, i)) * A(a, i) % M * C(d, _k - i) * A(a + c - i, _k - i) % M) % M;
    }
    cout << res << '\n';

    return 0;
}
```

### 数三角形

题目：https://www.acwing.com/problem/content/description/1312/

题解：https://www.luogu.com.cn/article/iju3tmkt

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

int n, m;

LL C(LL b)
{
    return b * (b - 1) * (b - 2) / 6;
}

int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    n++, m++;

    LL res = C(n * m) - n * C(m) - m * C(n);

    for (int i = 1; i < n; i++)
        for (int j = 1; j < m; j++)
            res -= 2 * (gcd(i, j) - 1) * (n - i) * (m - j);

    cout << res << '\n';

    return 0;
}
```

### 序列统计

题目：https://www.acwing.com/problem/content/description/1314/

题解：https://www.acwing.com/solution/content/8867/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

const int M = 1e6 + 3;

int FP(int a, int b)
{
    int res = 1;
    while (b)
    {
        if (b & 1) res = (LL(res) * a) % M;
        a = (LL(a) * a) % M;
        b >>= 1;
    }
    return res;
}

int C(int a, int b)
{
    int res = 1, inv = 1;
    for (int i = 1, j = a; i <= b; i++, j--)
    {
        res = (LL(res) * j) % M;
        inv = (LL(inv) * i) % M;
    }
    res = (LL(res) * FP(inv, M - 2)) % M;
    return res;
}

int Lucas(int a, int b)
{
    if (a < M && b < M) return C(a, b);
    return LL(C(a % M, b % M)) * Lucas(a / M, b / M) % M;
}

void solve()
{
    int n, l, r; cin >> n >> l >> r;
    int m = r - l;
    int res = Lucas(m + n + 1, m + 1) - 1;
    cout << (res + M) % M << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int T; cin >> T;
    while (T--)
        solve();

    return 0;
}
```

### 网格

题目：https://www.acwing.com/problem/content/submission/1317/

题解：

https://www.acwing.com/solution/content/46130/

https://www.acwing.com/solution/content/260891/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <bitset>
#include <vector>

using std::cin, std::cout;
using std::bitset, std::vector;
using LL = long long;

const int N = 1e4 + 10;

bitset<N> st;
int prime[N], cnt;

void sieve(int n)
{
    for (int i = 2; i <= n; i++)
    {
        if (!st[i]) prime[cnt++] = i;
        for (int j = 0; prime[j] * i <= n; j++)
        {
            st[prime[j] * i] = true;
            if (i % prime[j] == 0) break;
        }
    }
}

int Legendre(int n, int p)
{
    int cnt = 0;
    while (n)
    {
        cnt += n / p;
        n /= p;
    }
    return cnt;
}

vector<int> mul(vector<int>& A, int b)
{
    vector<int> C;
    int t = 0;
    for (int a : A)
    {
        t += a * b;
        C.push_back(t % 10);
        t /= 10;
    }
    while (t)
    {
        C.push_back(t % 10);
        t /= 10;
    }
    return C;
}

void show(vector<int>& A)
{
    for (int i = A.size() - 1; i >= 0; i--) cout << A[i];
    cout << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int n, m; cin >> n >> m;
    sieve(n + m);

    vector<int> res;
    res.push_back(1);

    for (int i = 0; i < cnt; i++)
    {
        int p = prime[i];
        int c = Legendre(m + n, p) - Legendre(n + 1, p) - Legendre(m, p);
        while (c--) res = mul(res, p);
    }
    res = mul(res, n - m + 1);

    show(res);

    return 0;
}
```

### 有趣的数列

题目：https://www.acwing.com/problem/content/description/1318/

题解：https://www.acwing.com/solution/content/133856/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <bitset>

using std::cin, std::cout;
using LL = long long;

const int N = 2e6 + 10;

int n, m;
int prime[N], cnt;
std::bitset<N> st;

void sieve(int n)
{
    for (int i = 2; i <= n; i++)
    {
        if (!st[i]) prime[cnt++] = i;
        for (int j = 0; LL(prime[j]) * i <= n; j++)
        {
            st[prime[j] * i] = true;
            if (i % prime[j] == 0) break;
        }
    }
}

int Legendre(int n, int p)
{
    int c = 0;
    while (n)
    {
        c += n / p;
        n /= p;
    }
    return c;
}

int FP(int a, int b)
{
    int res = 1;
    while (b)
    {
        if (b & 1) res = (LL(res) * a) % m;
        a = (LL(a) * a) % m;
        b >>= 1;
    }
    return res;
}

int C(int a, int b)
{
    int res = 1;
    for (int i = 0; i < cnt; i++)
    {
        int p = prime[i];
        int c = Legendre(a, p) - Legendre(b, p) - Legendre(a - b, p);
        res = (LL(res) * FP(p, c)) % m;
    }
    return res;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    sieve(n * 2);
    int cat = C(n * 2, n) - C(n * 2, n - 1);
    cout << (cat % m + m) % m << '\n';

    return 0;
}
```

## 高斯消元

### 球形空间产生器

题目：https://www.acwing.com/problem/content/description/209/

题解：https://www.acwing.com/solution/content/48342/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

const int N = 15;

int n;
double A[N][N], B[N][N];

void Gauss()
{
    for (int c = 0, r = 0; r < n; r++, c++)
    {
        int t = r;
        for (int i = r + 1; i < n; i++)
            if (std::abs(B[i][c]) > std::abs(B[t][c]))
                t = i;

        if (t != r)
        {
            for (int j = c; j <= n; j++) std::swap(B[r][j], B[t][j]);
        }

        for (int j = c + 1; j <= n; j++) B[r][j] /= B[r][c];
        B[r][c] = 1;

        for (int i = r + 1; i < n; i++)
        {
            for (int j = c + 1; j <= n; j++)
                B[i][j] -= B[i][c] * B[r][j];
            B[i][c] = 0;
        }
    }

    for (int i = n - 1; i > 0; i--)
        for (int j = i - 1; j >= 0; j--)
        {
            B[j][n] -= B[j][i] * B[i][n];
            B[j][i] = 0;
        }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    for (int i = 0; i < n + 1; i++)
        for (int j = 0; j < n; j++) 
            cin >> A[i][j];

    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
        {
            B[i][j] = 2 * (A[i + 1][j] - A[0][j]);
            B[i][n] += A[i + 1][j] * A[i + 1][j] - A[0][j] * A[0][j];
        }
    
    Gauss();

    for (int i = 0; i < n; i++) printf("%.3lf ", B[i][n]);

    return 0;
}
```

### 开关问题

题目：https://www.acwing.com/problem/content/description/210/

题解：https://www.acwing.com/solution/content/157080/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

const int N = 35;

int n;
int A[N][N];

int Gauss()
{
    int r, c;
    for (r = 1, c = 1; c <= n; c++)
    {
        int t = r;
        for (int i = r; i <= n; i++)
            if (A[i][c])
            {
                t = i;
                break;
            }

        if (A[t][c] == 0) continue;

        if (t != r)
        {
            for (int j = c; j <= n + 1; j++) std::swap(A[r][j], A[t][j]);
        }

        for (int i = r + 1; i <= n; i++)
            if (A[i][c])
                for (int j = c; j <= n + 1; j++)
                    A[i][j] ^= A[r][j];

        r++;
    }
    
    for (int i = r; i <= n; i++)
        if (A[i][n + 1])
            return -1;

    return 1 << (n - r + 1);
}

void solve()
{
    bzero(A, sizeof A);
    cin >> n;

    for (int i = 1; i <= n; i++) cin >> A[i][n + 1];
    for (int i = 1; i <= n; i++)
    {
        int x; cin >> x;
        A[i][n + 1] ^= x;
        A[i][i] = 1;
    }

    int a, b;
    while (cin >> a >> b, a || b)
    {
        A[b][a] = 1;
    }

    int ret = Gauss();

    if (ret == -1) cout << "Oh,it's impossible~!!" << '\n';
    else cout << ret << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int T; cin >> T;
    while (T--)
        solve();

    return 0;
}
```

## 容斥原理

### Devu和鲜花

题目：https://www.acwing.com/problem/content/description/216/

题解：https://www.acwing.com/solution/content/13666/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

const int N = 25, MOD = 1e9 + 7;

int n, br;
LL m;
LL A[N];

int FP(int a, int b)
{
    int res = 1;
    while (b)
    {
        if (b & 1) res = LL(res) * a % MOD;
        a = LL(a) * a % MOD;
        b >>= 1;
    }
    return res;
}

int C(LL a)
{
    if (a < n - 1) return 0;
    int up = 1;
    for (LL i = a - n + 2; i <= a; i++) up = i % MOD * up % MOD;
    return LL(up) * br % MOD;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < n; i++) cin >> A[i];

    br = 1;
    for (int i = 1; i <= n - 1; i++) br = LL(br) * i % MOD;
    br = FP(br, MOD - 2);

    int res = 0;
    for (int i = 0; i < 1 << n; i++)
    {
        int sign = 1;
        LL a = m + n - 1;
        for (int j = 0; j < n; j++)
            if (i >> j & 1)
            {
                sign = -sign;
                a -= (A[j] + 1);
            }

        res = (res + sign * C(a)) % MOD;
    }

    cout << (res + MOD) % MOD << '\n';

    return 0;
}
```

### 破译密码

题目：https://www.acwing.com/problem/content/description/217/

题解：https://www.acwing.com/solution/content/17858/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <bitset>

using std::cin, std::cout;
using LL = long long;

const int N = 5e4 + 10;

std::bitset<N> st;
int prime[N], cnt;
int mobius[N], ps[N];

void sieve(int n)
{
    mobius[1] = 1;
    for (int i = 2; i <= n; i++)
    {
        if (!st[i])
        {
            mobius[i] = -1;
            prime[cnt++] = i;
        }
        for (int j = 0; LL(prime[j]) * i <= n; j++)
        {
            int com = prime[j] * i;
            st[com] = true;
            if (i % prime[j] == 0)
            {
                mobius[com] = 0;
                break;
            }
            mobius[com] = -1 * mobius[i];
        }
    }

    for (int i = 1; i <= n; i++) ps[i] = ps[i - 1] + mobius[i];
}

void solve()
{
    int a, b, d; cin >> a >> b >> d;
    a /= d, b /= d;
    int n = std::min(a, b);

    LL res = 0;
    for (int l = 1, r = 1; l <= n; l = r + 1)
    {
        r = std::min({n, a / (a / l), b / (b / l)});
        res += LL(ps[r] - ps[l - 1]) * (a / l) * (b / l);
    }
    cout << res << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    sieve(N - 1);

    int T; cin >> T;
    while (T--)
        solve();

    return 0;
}
```

## 概率与数学期望

### 绿豆蛙的归宿

题目：https://www.acwing.com/problem/content/description/219/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

const int N = 1e5 + 10, M = 2e5 + 10;

int n, m;
int H[N], idx;
struct EdgeNode
{
    int v, w, n;
} E[M];

void addE(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

double f[N];
int out[N];

double DFS(int u)
{
    if (f[u] > 0) return f[u];

    double res = 0;
    for (int p = H[u]; p; p = E[p].n)
    {
        int v = E[p].v, w = E[p].w;
        res += (DFS(v) + w) / out[u];
    }
    return res;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b, c; cin >> a >> b >> c;
        addE(a, b, c);
        out[a]++;
    }

    printf("%.2lf\n", DFS(1));

    return 0;
}
```

### 扑克牌

题目：https://www.acwing.com/problem/content/description/220/

题解：https://www.acwing.com/solution/content/162833/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

const int N = 15;
const double INF = 54 * 54 + 100;

int A, B, C, D;
double f[N][N][N][N][5][5];

double DFS(int a, int b, int c, int d, int x, int y)
{
    double &v = f[a][b][c][d][x][y];
    if (v >= 0) return v;

    int as = a + (x == 1) + (y == 1);
    int bs = b + (x == 2) + (y == 2);
    int cs = c + (x == 3) + (y == 3);
    int ds = d + (x == 4) + (y == 4);

    if (as >= A && bs >= B && cs >= C && ds >= D) return v = 0;

    int sum = as + bs + cs + ds;
    if (sum == 54) return v = INF;

    v = 1;
    if (a < 13) v += double(13 - a) / (54 - sum) * DFS(a + 1, b, c, d, x, y);
    if (v > 54) return v = INF;
    if (b < 13) v += double(13 - b) / (54 - sum) * DFS(a, b + 1, c, d, x, y);
    if (v > 54) return v = INF;
    if (c < 13) v += double(13 - c) / (54 - sum) * DFS(a, b, c + 1, d, x, y);
    if (v > 54) return v = INF;
    if (d < 13) v += double(13 - d) / (54 - sum) * DFS(a, b, c, d + 1, x, y);
    if (v > 54) return v = INF;

    if (x == 0)
    {
        double t = INF;
        for (int i = 1; i <= 4; i++) t = std::min(t, DFS(a, b, c, d, i, y));
        v += 1 / double(54 - sum) * t;
        if (v > 54) return v = INF;
    }
    if (y == 0)
    {
        double t = INF;
        for (int i = 1; i <= 4; i++) t = std::min(t, DFS(a, b, c, d, x, i));
        v += 1 / double(54 - sum) * t;
        if (v > 54) return v = INF;
    }

    return v;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    memset(f, -1, sizeof f);

    cin >> A >> B >> C >> D;

    double res = DFS(0, 0, 0, 0, 0, 0);
    if (res > 54) res = -1;

    printf("%.3lf\n", res);

    return 0;
}
```

## 博弈论

### 移棋子游戏

题目：https://www.acwing.com/problem/content/description/1321/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <unordered_set>

using std::cin, std::cout;
using LL = long long;

const int N = 2010, M = 6010;

int n, m, k;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M]; int idx;

void addE(int a, int b)
{
    E[++idx] = {b, H[a]}, H[a] = idx;
}

int f[N];

int SG(int x)
{
    if (f[x] >= 0) return f[x];

    std::unordered_set<int> hs;
    for (int p = H[x]; p; p = E[p].n)
    {
        int v = E[p].v;
        hs.insert(SG(v));
    }

    for (int i = 0; ; i++)
        if (hs.count(i) == 0)
            return f[x] = i;

    return -1;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m >> k;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        addE(a, b);
    }

    int res = 0;
    memset(f, -1, sizeof f);
    for (int i = 0; i < k; i++)
    {
        int x; cin >> x;
        res ^= SG(x);
    }

    cout << (res ? "win" : "lose") << '\n';

    return 0;
}
```

### 取石子

题目：https://www.acwing.com/problem/content/description/1323/

题解：

[y总的做法](https://www.acwing.com/solution/content/26214/)，在证明上似乎有疏漏。

[分类讨论](https://www.acwing.com/solution/content/76900/)，这个做法很高明。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

void solve()
{
    int n; cin >> n;
    int cnt = 0, op = 0;
    for (int i = 0; i < n; i++)
    {
        int a; cin >> a;
        if (a == 1) cnt++;
        else op += a + 1;
    }
    if (op > 0) op -= 1;

    if (cnt == n || (cnt == n - 1 && op == 2))
    {
        cout << (cnt % 3 ? "YES" : "NO") << '\n';
    }
    else
    {
        cout << (cnt % 2 || op % 2 ? "YES" : "NO") << '\n';
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int T; cin >> T;
    while (T--)
        solve();

    return 0;
}
```

### 取石子游戏

题目：https://www.acwing.com/problem/content/description/1324/

题解：https://www.acwing.com/solution/content/26286/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

const int N = 1010;

int n, A[N];
int L[N][N], R[N][N];

void solve()
{
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> A[i];

    for (int len = 1; len <= n; len++)
        for (int i = 1; i + len - 1 <= n; i++)
        {
            int j = i + len - 1;
            if (len == 1)
            {
                L[i][j] = R[i][j] = A[i];
            }
            else
            {
                int x = A[j];
                int l = L[i][j - 1], r = R[i][j - 1];

                if (r == x) L[i][j] = 0;
                else if ((x < l && x < r) ||
                         (x > l && x > r)) L[i][j] = x;
                else if (l > r) L[i][j] = x - 1;
                else L[i][j] = x + 1;

                x = A[i];
                l = L[i + 1][j], r = R[i + 1][j];
                if (l == x) R[i][j] = 0;
                else if ((x < l && x < r) ||
                         (x > l && x > r)) R[i][j] = x;
                else if (r > l) R[i][j] = x - 1;
                else R[i][j] = x + 1;
            }
        }

    if (n == 1) cout << 1 << '\n';
    else cout << int(A[1] != L[2][n]) << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int T; cin >> T;
    while (T--)
        solve();

    return 0;
}
```

