# 动态规划

## 数字三角形模型

以下题目是[数字三角形](../算法基础课/5 动态规划#数字三角形)的应用。方格取数和传纸条是有价值的，其他两题是套皮题目。

### 摘花生

题目：https://www.acwing.com/problem/content/description/1017/

```c++
#include <iostream>

using namespace std;

const int N = 110;

int n, r, c;
int f[N][N];

int main()
{
    scanf( "%d", &n );
    
    while ( n-- )
    {
        scanf( "%d%d", &r, &c );
        for ( int i = 1; i <= r; i++ )
            for ( int j = 1; j <= c; j++ )
                scanf( "%d", &f[i][j] );
        
        for ( int i = 1; i <= r; i++ )
            for ( int j = 1; j <= c; j++ )
                f[i][j] += max( f[i - 1][j], f[i][j - 1] );
        
        printf( "%d\n", f[r][c] );
    }
    
    return 0;
}
```

### 最低通行费

题目：https://www.acwing.com/problem/content/description/1020/

```c++
#include<iostream>

using namespace std;

const int N = 110;

int n;
int f[N][N];

int main()
{
    scanf( "%d", &n );
    for ( int i = 1; i <= n; i++ )
        for ( int j = 1; j <= n; j++ )
            scanf( "%d", &f[i][j] );
    
    for ( int i = 2; i <= n; i++ ) f[i][1] += f[i - 1][1];
    for ( int j = 2; j <= n; j++ ) f[1][j] += f[1][j - 1];
    for ( int i = 2; i <= n; i++ )
        for ( int j = 2; j <= n; j++ )
            f[i][j] += min( f[i - 1][j], f[i][j - 1] );
    
    printf( "%d\n", f[n][n] );
    
    return 0;
}
```

### 方格取数

题目：https://www.acwing.com/problem/content/description/1029/

题解：https://www.acwing.com/solution/content/15868/

思路：要注意如何判断$(i1, j1), (i2, j2)$的合法范围，什么时候break什么时候continue。

```c++
#include <iostream>

using namespace std;

const int N = 15;

int n;
int w[N][N];
int f[2 * N][N][N];

int main()
{
    scanf( "%d", &n );
    int a, b, c;
    while ( scanf( "%d%d%d", &a, &b, &c ), a || b || c ) w[a][b] = c;
    
    for ( int k = 2; k <= 2 * n; k++ )  // k是终点的横纵坐标之和
        for ( int i1 = 1; i1 <= k - 1; i1++ )
            for ( int i2 = 1; i2 <= k - 1; i2++ )
            {
                int j1 = k - i1, j2 = k - i2;
                if ( i1 > n || i2 > n ) break;
                if ( j1 > n || j2 > n ) continue;
                int& x = f[k][i1][i2];
                x = max( x, f[k - 1][i1 - 1][i2 - 1] ); // 下下
                x = max( x, f[k - 1][i1 - 1][i2] );     // 下右
                x = max( x, f[k - 1][i1][i2 - 1] );     // 右下
                x = max( x, f[k - 1][i1][i2] );         // 又右
                x += i1 == i2 ? w[i1][j1] : w[i1][j1] + w[i2][j2];
            }
            
    printf( "%d\n", f[2 * n][n][n] );
    
    return 0;
}
```

### 传纸条

题目：https://www.acwing.com/problem/content/277/

题解：https://www.acwing.com/solution/content/12389/

题解的证明没有问题，但是答案代码的边界有问题。

思路：

代码的边界判断改到了循环中，效率实际上更高。

这个代码中更新$x$的代码可以改为`x += i1 == i2 ? 0 : w[i1][j1] + w[i2][j2];`这也不会出错，并且更加正确。甚至可以改成$-2$，因为原则上不能走重复的点，但是必须保证终点不做这个计算。即`if ( k != n + m ) x += i1 == i2 ? -2 : w[i1][j1] + w[i2][j2];`。

```c++
#include <iostream>

using namespace std;

const int N = 55;

int n, m;
int w[N][N];
int f[N * 2][N][N];

int main()
{
    scanf( "%d%d", &n, &m );
    for ( int i = 1; i <= n; i++ )
        for ( int j = 1; j <= m; j++ )
            scanf( "%d", &w[i][j] );
            
            
    for ( int k = 2; k <= n + m; k++ )
        for ( int i1 = max( 1, k - m ); i1 <= n && i1 <= k - 1; i1++ )
            for ( int i2 = max( 1, k - m ); i2 <= n && i2 <= k - 1; i2++ )
            {
                int j1 = k - i1, j2 = k - i2;
                int& x = f[k][i1][i2];
                x = max( x, f[k - 1][i1 - 1][i2 - 1] );
                x = max( x, f[k - 1][i1 - 1][i2] );
                x = max( x, f[k - 1][i1][i2 - 1] );
                x = max( x, f[k - 1][i1][i2] );
                x += i1 == i2 ? w[i1][j1] : w[i1][j1] + w[i2][j2];
            }
            
    printf( "%d\n", f[n + m][n][n] );
    
    return 0;
}
```

## 最长上升子序列模型

以[最长上升子序列](https://www.acwing.com/problem/content/897/)和[最长上升子序列 II](https://www.acwing.com/problem/content/description/898/)这两个题为模型。

### 怪盗基德的滑翔翼

题目：https://www.acwing.com/problem/content/1019/

思路：

因为可以往两个方向滑行，等同于正反计算两次最长上升子序列。这里是通过逆序数组实现的。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

int m, n;
int arr[N];
int f[N];

int LIS()
{
    for ( int i = 1; i <= n; i++ )
    {
        int tmp = 0;
        for ( int j = 1; j < i; j++ )
            if ( arr[j] < arr[i] ) tmp = max( tmp, f[j] );
        f[i] = tmp + 1;
    }
    
    int res = 0;
    for ( int i = 1; i <= n; i++ ) res = max( res, f[i] );
    
    return res;
}

int main()
{
    scanf( "%d", &m );
    
    while ( m-- )
    {
        scanf( "%d", &n );
        for ( int i = 1; i <= n; i++ ) scanf( "%d", arr + i );
        
        int res = LIS();
        reverse( arr + 1, arr + 1 + n );
        res = max( res, LIS() );
        
        printf( "%d\n", res );
    }
    
    return 0;
}
```

### 登山

题目：https://www.acwing.com/problem/content/1016/

说明：和[怪盗基德的滑翔翼](https://www.acwing.com/problem/content/1019/)是一类问题，但是从哪里开始下山需要遍历查找。

```c++
#include <iostream>

using namespace std;

const int N = 1010;

int n;
int arr[N];
int fu[N], fd[N];

int main()
{
    scanf( "%d", &n );
    for ( int i = 1; i <= n; i++ ) scanf( "%d", arr + i );
    
    for ( int i = 1; i <= n; i++ )
    {
        int tmp = 0;
        for ( int j = 1; j < i; j++ )
            if ( arr[j] < arr[i] ) tmp = max( tmp, fu[j] );
        fu[i] = tmp + 1;
    }
    
    for ( int i = n; i >= 1; i-- )
    {
        int tmp = 0;
        for ( int j = n; j > i; j-- )
            if ( arr[j] < arr[i] ) tmp = max( tmp, fd[j] );
        fd[i] = tmp + 1;
    }
    
    int res = 0;
    for ( int i = 1; i <= n; i++ )
        res = max( res, fu[i] + fd[i] );
    printf( "%d\n", --res );
    
    return 0;
}
```

### 合唱队形

题目：https://www.acwing.com/problem/content/description/484/

说明：和[登山](https://www.acwing.com/problem/content/1016/)差不多，没什么新意。

```c++
#include <iostream>

using namespace std;

const int N = 110;

int n;
int arr[N];
int f[N], g[N];

int main()
{
    scanf( "%d", &n );
    for ( int i = 1; i <= n; i++ ) scanf( "%d", arr + i );
    
    for ( int i = 1; i <= n; i++ )
    {
        int tmp = 0;
        for ( int j = 1; j < i; j++ )
            if ( arr[j] < arr[i] ) tmp = max( tmp, f[j] );
        f[i] = tmp + 1;
    }
    
    for ( int i = n; i >= 1; i-- )
    {
        int tmp = 0;
        for ( int j = n; j > i; j-- )
            if ( arr[j] < arr[i] ) tmp = max( tmp, g[j] );
        g[i] = tmp + 1;
    }
    
    int res = 0;
    for ( int i = 1; i <= n; i++ ) res = max( res, f[i] + g[i] );
    res = n - ( res - 1 );
    
    printf( "%d\n", res );
    
    return 0;
}
```

### 友好城市

题目：https://www.acwing.com/problem/content/description/1014/

说明：

可以从逆序对的角度去思考，LIS是指没有逆序对的最长序列，只要有逆序对就必然不可能满足题目条件。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

using PII = pair<int, int>;

const int N = 5010;

int n;
PII cities[N];
int f[N];

int main()
{
    scanf( "%d", &n );
    for ( int i = 1; i <= n; i++ )
    {
        int a, b; scanf( "%d%d", &a, &b );
        cities[i] = { a, b };
    }
    
    sort( cities + 1, cities + 1 + n );
    for ( int i = 1; i <= n; i++ )
    {
        int tmp = 0;
        for ( int j = 1; j < i; j++ )
            if ( cities[j].second < cities[i].second )
                tmp = max( tmp, f[j] );
        f[i] = tmp + 1;
    }
    
    int res = 0;
    for ( int i = 1; i <= n; i++ ) res = max( res, f[i] );
    
    printf( "%d\n", res );
    
    return 0;
}
```

### 最大上升子序列和

题目：https://www.acwing.com/problem/content/1018/

```c++
#include <iostream>

using namespace std;

const int N = 1010;

int n;
int arr[N];
int f[N];

int main()
{
    scanf( "%d", &n );
    for ( int i = 1; i <= n; i++ ) scanf( "%d", arr + i );
    
    for ( int i = 1; i <= n; i++ )
    {
        int tmp = 0;
        for ( int j = 1; j < i; j++ )
            if ( arr[j] < arr[i] ) tmp = max( tmp, f[j] );
        f[i] = tmp + arr[i];
    }
    
    int res = 0;
    for ( int i = 1; i <= n; i++ ) res = max( res, f[i] );
    printf( "%d\n", res );
    
    return 0;
}
```

### 拦截导弹

题目：https://www.acwing.com/problem/content/1012/

证明：https://www.acwing.com/solution/content/6746/

```c++
#include <iostream>

using namespace std;

const int N = 1010;

int n;
int arr[N];
int f[N], q[N];

int main()
{
    while ( cin >> arr[n] ) n++;
    
    for ( int i = n - 1; i >= 0; i-- )
    {
        int tmp = 0;
        for ( int j = n - 1; j > i; j-- )
            if ( arr[j] <= arr[i] ) tmp = max( tmp, f[j] );
        f[i] = tmp + 1;
    }
    int res = 0;
    for ( int i = 0; i < n; i++ ) res = max( res, f[i] );
    printf( "%d\n", res );
    
    int cnt = 0;
    for ( int i = n - 1; i >= 0; i-- )
    {
        int j = 0;
        while ( j < cnt && q[j] > arr[i] ) j++;
        q[j] = arr[i];
        
        if ( j == cnt ) cnt++;
    }
    printf( "%d\n", cnt );
    
    
    return 0;
}
```

### 导弹防御系统

题目：https://www.acwing.com/problem/content/description/189/

思路：没什么好说的就是暴力搜索。

```c++
#include <iostream>

using namespace std;

const int N = 55;

int n, arr[N];
int f[N], lf; // 上升
int g[N], lg; // 下降
int res;

void dfs( int i )
{
    if ( lf + lg >= res ) return;
    if ( i == n )
    {
        res = lf + lg ;
        return;
    }

    int j = 0;
    while ( j < lf && f[j] >= arr[i] ) j++;
    int tmp = f[j];
    f[j] = arr[i];
    if ( j == lf ) lf++;
    dfs( i + 1 );
    f[j] = tmp;
    if ( j == lf - 1 && tmp == 0 ) lf--;
    
    j = 0;
    while ( j < lg && g[j] <= arr[i] ) j++;
    tmp = g[j];
    g[j] = arr[i];
    if ( j == lg ) lg++;
    dfs( i + 1 );
    g[j] = tmp;
    if ( j == lg - 1 && tmp == 0 ) lg--;
}

int main()
{
    while ( scanf( "%d", &n ), n )
    {
        for ( int i = 0; i < n; i++ ) scanf( "%d", arr + i );
        
        res = N;
        dfs( 0 );
        printf( "%d\n", res );
    }
    
    return 0;
}
```

### 最长公共上升子序列

题目：https://www.acwing.com/problem/content/description/274/

题解：https://www.acwing.com/solution/content/4955/

```c++
#include <iostream>

using namespace std;

const int N = 3010;

int n;
int A[N], B[N];
int f[N][N];

int main()
{
    scanf( "%d", &n );
    for ( int i = 1; i <= n; i++ ) scanf( "%d", A + i );
    for ( int i = 1; i <= n; i++ ) scanf( "%d", B + i );
    
    for ( int i = 1; i <= n; i++ )
    {
        int maxv = 1;
        for ( int j = 1; j <= n; j++ )
        {
            f[i][j] = f[i - 1][j]; // 不包含A[i]
            if ( A[i] == B[j] ) f[i][j] = max( f[i][j], maxv );
            if ( B[j] < A[i] ) maxv = max( maxv, f[i - 1][j] + 1 );
        }
    }
    
    int res = 0;
    for ( int i = 1; i <= n; i++ ) res = max( res, f[n][i] );
    printf( "%d\n", res );
    
    return 0;
}
```

## 背包模型

### 采药

题目：https://www.acwing.com/problem/content/425/

```c++
#include <iostream>

using namespace std;

const int N = 110, M = 1010;

int t, m;
int T[N], W[N];
int f[N][M];

int main()
{
    scanf( "%d%d", &t, &m );
    for ( int i = 1; i <= m; i++ ) scanf( "%d%d", T + i, W + i );

    for ( int i = 1; i <= m; i++ )
        for ( int j = 1; j <= t; j++ )
        {
            f[i][j] = f[i - 1][j];
            if ( j >= T[i] ) f[i][j] = max( f[i][j], f[i - 1][j - T[i]] + W[i] );
        }
        
    printf( "%d\n", f[m][t] );
    
    return 0;
}
```

### 装箱问题

题目：https://www.acwing.com/problem/content/description/1026/

```c++
#include <iostream>

using namespace std;

const int N = 2e4 + 10;

int n, v;
int f[N];

int main()
{
    scanf( "%d%d", &v, &n );
    
    for ( int i = 1; i <= n; i++ )
    {
        int vi; scanf( "%d", &vi );
        for ( int j = v; j >= vi; j-- )
            f[j] = max( f[j], f[j - vi] + vi );
    }
    
    printf( "%d\n", v - f[v] );
    
    return 0;
}
```

### 宠物小精灵之收服

题目：https://www.acwing.com/problem/content/description/1024/

题解：https://www.acwing.com/solution/content/52741/

```c++
#include <iostream>

using namespace std;

const int N = 110;
const int V1 = 1010, V2 = 510;

int n, v1, v2;
int f[V1][V2];

int main()
{
    scanf( "%d%d%d", &v1, &v2, &n );
    v2--;
    
    for ( int i = 1; i <= n; i++ )
    {
        int a, b; scanf( "%d%d", &a, &b );
        for ( int j = v1; j >= a; j-- )
            for ( int k = v2; k >= b; k-- )
                f[j][k] = max( f[j][k], f[j - a][k - b] + 1 );
    }
    
    int k = v2;
    while ( k >= 0 && f[v1][v2] == f[v1][k] ) k--;
    
    printf( "%d %d\n", f[v1][v2], v2 - k );
    
    return 0;
}
```

### 数字组合

题目：https://www.acwing.com/problem/content/description/280/

题解：https://www.acwing.com/solution/content/5241/

```c++
#include <iostream>

using namespace std;

const int N = 110, M = 1e4 + 10;

int n, m;
int A[N];
int f[M];

int main()
{
    scanf( "%d%d", &n, &m );
    for ( int i = 1; i <= n; i++ ) scanf( "%d", A + i );
    
    f[0] = 1;
    for ( int i = 1; i <= n; i++ )
        for ( int j = m; j >= A[i]; j-- )
            f[j] += f[j - A[i]];
    
    printf( "%d\n", f[m] );
    
    return 0;
}
```

### 买书

题目：https://www.acwing.com/problem/content/1025/

题解：https://www.acwing.com/solution/content/52967/

```c++
#include <iostream>

using namespace std;

const int N = 1010;

int n;
int A[] = { 0, 10, 20, 50, 100 };
int f[N];

int main()
{
    scanf( "%d", &n );
    
    f[0] = 1;
    for ( int i = 1; i <= 4; i++ )
        for ( int j = A[i]; j <= n; j++ )
            f[j] +=  f[j - A[i]];
            
    printf( "%d\n", f[n] );
    
    return 0;
}
```

### 货币系统

题目：https://www.acwing.com/problem/content/1023/

```c++
#include <iostream>

using namespace std;

using LL = long long;

const int N = 20, M = 3010;

int n, m;
LL f[M];

int main()
{
    scanf( "%d%d", &n, &m );
    
    f[0] = 1;
    for ( int i = 1; i <= n; i++ )
    {
        int v; scanf( "%d", &v );
        for ( int j = v; j <= m; j++ )
            f[j] += f[j - v];
    }
    
    printf( "%lld\n", f[m] );
    
    return 0;
}
```

### 货币系统

题目：https://www.acwing.com/problem/content/description/534/

题解：https://www.acwing.com/solution/content/53198/

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 110, M = 25010;

int T, n;
int V[N];
bool f[M];

int main()
{
    scanf( "%d\n", &T );
    
    while ( T-- )
    {
        scanf( "%d", &n );
        for ( int i = 1; i <= n; i++ ) scanf( "%d", V + i );
        
        sort( V + 1, V + 1 + n );
        int v = V[n];
        memset( f, 0, sizeof f ); f[0] = true;
        int cnt = 0;
        for ( int i = 1; i <= n; i++ )
        {
            if ( f[V[i]] ) continue;
            cnt++;
            for ( int j = V[i]; j <= v; j++ )
                f[j] |= f[j - V[i]];
        }
        
        printf( "%d\n", cnt );
    }
    
    return 0;
}
```

### 多重背包问题 III

题目：https://www.acwing.com/problem/content/6/

题解：https://www.acwing.com/solution/content/53507/

stl：会TLE

```c++
#include <iostream>
#include <queue>

using namespace std;

const int N = 1010, M = 2e4 + 10;

int n, v;
int V[N], W[N], S[N];
int f[N][M];

int main()
{
    scanf( "%d%d", &n, &v );
    for ( int i = 1; i <= n; i++ ) scanf( "%d%d%d", V + i, W + i, S + i );

    for ( int i = 1; i <= n; i++ )
        for ( int r = 0; r < V[i]; r++ )
        {
            deque<int> q;
            for ( int j = r; j <= v; j += V[i] )
            {
                if ( q.size() && ( j - q.front() ) / V[i] > S[i] ) q.pop_front();
                while ( q.size() && f[i - 1][q.back()] + ( j - q.back() ) / V[i] * W[i] <= f[i - 1][j] ) q.pop_back();
                q.push_back( j );
                f[i][j] = f[i - 1][q.front()] + ( j - q.front() ) / V[i] * W[i];
            }
        }
    
    printf( "%d\n", f[n][v] );
    
    return 0;
}
```

模拟队列：

```c++
#include <iostream>
#include <queue>

using namespace std;

const int N = 1010, M = 2e4 + 10;

int n, v;
int V[N], W[N], S[N];
int f[N][M];
int q[M];

int main()
{
    scanf( "%d%d", &n, &v );
    for ( int i = 1; i <= n; i++ ) scanf( "%d%d%d", V + i, W + i, S + i );

    for ( int i = 1; i <= n; i++ )
        for ( int r = 0; r < V[i]; r++ )
        {
            int hh = 0, tt = -1;
            for ( int j = r; j <= v; j += V[i] )
            {
                if ( hh <= tt && ( j - q[hh] ) / V[i] > S[i] ) hh++;
                while ( hh <= tt && f[i - 1][q[tt]] + ( j - q[tt] ) / V[i] * W[i] <= f[i - 1][j] ) tt--;
                q[++tt] = j;
                f[i][j] = f[i - 1][q[hh]] + ( j - q[hh] ) / V[i] * W[i];
            }
        }
    
    printf( "%d\n", f[n][v] );
    
    return 0;
}
```

滚动数组优化：

```c++
#include <iostream>

const int N = 1010, M = 2e4 + 10;

int n, v;
int V[N], W[N], S[N];
int f[2][M];
int q[M];

int main()
{
    scanf("%d%d", &n, &v);
    for (int i = 1; i <= n; i++) scanf("%d%d%d", V + i, W + i, S + i);
    
    int start = 0, dest = 0;
    for (int i = 1; i <= n; i++)
    {
        start = i % 2, dest = !start;
        for (int r = 0; r < V[i]; r++)
        {
            int tt = -1, hh = 0;
            for (int j = r; j <= v; j += V[i])
            {
                if (hh <= tt && (j - q[hh]) / V[i] > S[i]) hh++;
                while (hh <= tt && f[start][q[tt]] + (j - q[tt]) / V[i] * W[i] <= f[start][j]) tt--;
                q[++tt] = j;
                f[dest][j] = f[start][q[hh]] + (j - q[hh]) / V[i] * W[i];
            }
        }
    }
    
    printf("%d\n", f[dest][v]);
    
    return 0;
}
```

### 庆功会

题目：https://www.acwing.com/problem/content/description/1021/

发现：

二进制优化的循环判断中，`c > k`和`c >= k`都行，都一样。

```c++
#include <iostream>

using namespace std;

const int N = 510, M = 6010;

int n, m;
int V[M], W[M];
int f[M];

int main()
{
    scanf("%d%d", &n, &m);
    
    int cnt = 0;
    for (int i = 1; i <= n; i++)
    {
        int a, b, c; scanf("%d%d%d", &a, &b, &c);
        int k = 1;
        for (int k = 1; c > k; k *= 2)
        {
            cnt++;
            V[cnt] = k * a; W[cnt] = k * b;
            c -= k;
        }
        if (c)
        {
            cnt++;
            V[cnt] = c * a; W[cnt] = c * b;
        }
    }
    
    for (int i = 1; i <= cnt; i++)
        for (int j = m; j >= V[i]; j--)
            f[j] = max(f[j], f[j - V[i]] + W[i]);
    
    printf("%d\n", f[m]);
    
    return 0;
}
```

### 混合背包问题

题目：https://www.acwing.com/problem/content/description/7/

思路：

所有背包都可以看成多重背包，并采用二进制优化。其中完全背包的最大个数为$v / v_i$。

```c++
#include <iostream>

using namespace std;

const int N = 1e4 + 10;

int n, v;
int V[N], W[N];
int f[N];

int main()
{
    scanf("%d%d", &n, &v);
    int cnt = 0;
    for (int i = 1; i <= n; i++)
    {
        int a, b, c; scanf("%d%d%d", &a, &b, &c);
        if      (c < 0) c = 1;
        else if (c == 0) c = v / a;
        for (int k = 1; c > k; k *= 2)
        {
            cnt++;
            V[cnt] = k * a;
            W[cnt] = k * b;
            c -= k;
        }
        if (c)
        {
            cnt++;
            V[cnt] = c * a;
            W[cnt] = c * b;
        }

    }

    for (int i = 1; i <= cnt; i++)
        for (int j = v; j >= V[i]; j--)
            f[j] = max(f[j], f[j - V[i]] + W[i]);

    printf("%d\n", f[v]);

    return 0;
}
```

### 二维费用的背包问题

题目：https://www.acwing.com/problem/content/description/8/

```c++
#include <iostream>

using namespace std;

const int N = 1010, K = 110;

int n, v, m;
int V[N], M[N], W[N];
int f[K][K];

int main()
{
    scanf("%d%d%d", &n, &v, &m);
    for (int i = 1; i <= n; i++) scanf("%d%d%d", V + i, M + i, W + i);

    for (int i = 1; i <= n; i++)
        for (int j = v; j >= V[i]; j--)
            for (int k = m; k >= M[i]; k--)
                f[j][k] = max(f[j][k], f[j - V[i]][k - M[i]] + W[i]);

    printf("%d\n", f[v][m]);
    
    return 0;
}
```

### 潜水员

题目：https://www.acwing.com/problem/content/description/1022/

题解：https://www.acwing.com/solution/content/53848/

```c++
#include <iostream>
#include <cstring>

using namespace std;

const int N = 1010, M = 100;

int n, v1, v2;
int A[N], B[N], C[N];
int f[M][M];

int main()
{
    scanf("%d%d%d", &v1, &v2, &n);
    for (int i = 1; i <= n; i++) scanf("%d%d%d", A + i, B + i, C + i);

    memset(f, 0x3f, sizeof f);
    f[0][0] = 0;
    for (int i = 1; i <= n; i++)
        for (int j = v1; j >= 0; j--)
            for (int k = v2; k >= 0; k--)
                f[j][k] = min(f[j][k], f[max(j - A[i], 0)][max(k - B[i], 0)] + C[i]);

    printf("%d\n", f[v1][v2]);

    return 0;
}
```

### 机器分配

题目：https://www.acwing.com/problem/content/1015/

```c++
#include <iostream>

using namespace std;

const int N = 20;

int n, m;
int W[N][N];
int f[N][N];

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            scanf("%d", &W[i][j]);

    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            for (int k = 0; k <= j; k++)
                f[i][j] = max(f[i][j], f[i - 1][j - k] + W[i][k]);

    printf("%d\n", f[n][m]);

    int j = m;
    for (int i = n; i >= 1; i--)
        for (int k = 0; k <= j; k++)
            if (f[i][j] == f[i - 1][j - k] + W[i][k])
            {
                printf("%d %d\n", i, k);
                j -= k;
                break;
            }

    return 0;
}
```

### 开心的金明

题目：https://www.acwing.com/problem/content/428/

题解：https://www.acwing.com/solution/content/4538/

```c++
#include <iostream>

using namespace std;

const int N = 3e4 + 10, M = 30;

int n, m;
int V[M], W[M];
int f[N];

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++)
        scanf("%d%d", &V[i], &W[i]);

    for (int i = 1; i <= m; i++)
        for (int j = n; j >= V[i]; j--)
            f[j] = max(f[j], f[j - V[i]] + V[i] * W[i]);

    printf("%d\n", f[n]);

    return 0;
}
```

### 有依赖的背包问题

题目：https://www.acwing.com/problem/content/description/10/

题解：https://www.acwing.com/solution/content/54139/

每次`dfs`都可以看做一次完整的分组背包问题，并且经过了滚动数组优化，所以`dfs`中的sj都是倒序遍历。

```c++
#include <iostream>

using namespace std;

const int N = 110;

int n, m;
int V[N], W[N];
int h[N], e[N], ne[N], idx = 1;
int f[N][N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

void dfs(int u)
{
    // 分组背包，每个子结点的看成一组
    for (int i = h[u]; i; i = ne[i])
    {
        int son = e[i];
        dfs(son);
        
        for (int j = m - V[u]; j >= 0; j--)
            for (int k = 1; k <= j; k++)
                f[u][j] = max(f[u][j], f[u][j - k] + f[son][k]);
    }

    for (int j = m; j >= V[u]; j--) f[u][j] = f[u][j - V[u]] + W[u];
    for (int j = 0; j < V[u]; j++) f[u][j] = 0;
}

int main()
{
    scanf("%d%d", &n, &m);
    int root = 0;
    for (int i = 1; i <= n; i++)
    {
        int p; scanf("%d%d%d", &V[i], &W[i], &p);
        if (p != -1) add(p, i);
        else root = i;
    }

    dfs(root);

    printf("%d\n", f[root][m]);
    return 0;
}
```

### 背包问题求方案数

题目：https://www.acwing.com/problem/content/11/

题解：https://www.acwing.com/solution/content/54273/

```c++
#include <iostream>

using namespace std;

const int N = 1010, MOD = 1e9 + 7;

int n, m;
int V[N], W[N];
int f[N], g[N];

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
        scanf("%d%d", &V[i], &W[i]);

    g[0] = 1;
    for (int i = 1; i <= n; i++)
        for (int j = m; j >= V[i]; j--)
        {
            int mx = max(f[j], f[j - V[i]] + W[i]);
            int cnt = 0;
            if (mx == f[j]) cnt += g[j];
            if (mx == f[j - V[i]] + W[i]) cnt += g[j - V[i]];
            g[j] = cnt % MOD;
            f[j] = mx;
        }

    int res = 0;
    for (int j = m; j >= 0; j--)
        if (f[m] == f[j]) res = (res + g[j]) % MOD;
        else break;

    printf("%d\n", res);
    return 0;
}
```

### 背包问题求具体方案

题目：https://www.acwing.com/problem/content/description/12/

```c++
#include <iostream>

using namespace std;

const int N = 1010;

int n, m;
int V[N], W[N];
int f[N][N];

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
        scanf("%d%d", &V[i], &W[i]);

    for (int i = n; i >= 1; i--)
        for (int j = 1; j <= m; j++)
        {
            f[i][j] = f[i + 1][j];
            if (j >= V[i]) f[i][j] = max(f[i][j], f[i + 1][j - V[i]] + W[i]);
        }

    int j = m;
    for (int i = 1; i <= n; i++)
        if (j >= V[i] && f[i][j] == f[i + 1][j - V[i]] + W[i])
        {
            printf("%d ", i);
            j -= V[i];
        }
    puts("");

    return 0;
}
```

### 能量石

题目：https://www.acwing.com/problem/content/description/736/

题解：https://www.acwing.com/solution/content/4639/

```c++
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

struct Stone
{
    int s, e, l;
    double r;

    bool operator<(const Stone &W) const
    {
        return r < W.r;
    }
};

const int N = 110, M = 1e4 + 10;

int n;
Stone stones[N];
int f[M];

int main()
{
    int T; scanf("%d", &T);
    for (int I = 1; I <= T; I++)
    {
        scanf("%d", &n);
        int time = 0;
        for (int i = 1; i <= n; i++)
        {
            int s, e, l; scanf("%d%d%d", &s, &e, &l);
            stones[i] = {s, e, l, double(s) / l};
            time += s;
        }
        sort(stones + 1, stones + 1 + n);

        memset(f, 0, sizeof f);
        for (int i = 1; i <= n; i++)
            for (int j = time; j >= stones[i].s; j--)
            {
                int s = stones[i].s, e = stones[i].e, l = stones[i].l;
                f[j] = max(f[j], f[j - s] + max(0, e - (j - s) * l));
            }

        int res = *max_element(f + 1, f + 1 + time);
        printf("Case #%d: %d\n", I, res);
    }

    return 0;
}
```

### 金明的预算方案

题目：https://www.acwing.com/problem/content/description/489/

题解：https://www.acwing.com/solution/content/3803/

```c++
#include <cstdio>
#include <vector>

using namespace std;

typedef long long LL;
typedef pair<int, int> PII;
#define v first
#define w second

int n, m;
vector<vector<PII>> items;
vector<int> f;

int main()
{
    scanf("%d%d", &m, &n);
    items.resize(n + 1);
    f.resize(m + 1);
    for (int i = 1; i <= n; i++)
    {
        int v, p, q; scanf("%d%d%d", &v, &p, &q);
        if (q) items[q].push_back({ v, v * p });
        else items[i].push_back({ v, v * p });
    }

    for (int i = 1; i <= n; i++)
    {
        if (items[i].empty()) continue;
        auto& item = items[i];
        for (int j = m; j >= 1; j--)
        {
            LL cnt = 1L << (item.size() - 1);
            for (LL k = 0; k < cnt; k++)
            {
                int v = item[0].v, w = item[0].w;
                for (int d = item.size() - 2; d >= 0; d--)
                    if (k >> d & 1)
                    {
                        v += item[d + 1].v;
                        w += item[d + 1].w;
                    }
                if (j >= v) f[j] = max(f[j], f[j - v] + w);
            }
        }
    }

    printf("%d\n", f[m]);

    return 0;
}
```

## 状态机模型

### 大盗阿福

题目：https://www.acwing.com/problem/content/description/1051/

题解：https://www.acwing.com/solution/content/23723/

```c++
#include <iostream>

using namespace std;

const int N = 1e5 + 10;

int n;
int W[N];
int f[N][2];

int main()
{
    int T; scanf("%d", &T);
    while (T--)
    {
        scanf("%d", &n);
        for (int i = 1; i <= n; i++)
            scanf("%d", &W[i]);
        
        for (int i = 1; i <= n; i++)
        {
            f[i][0] = max(f[i - 1][0], f[i - 1][1]);
            f[i][1] = f[i - 1][0] + W[i];
        }
        int res = max(f[n][0], f[n][1]);
        printf("%d\n", res);
    }
    return 0;
}
```

### 股票买卖 IV

题目：https://www.acwing.com/problem/content/description/1059/

题解：https://www.acwing.com/solution/content/55037/

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10, M = 110;

int n, m;
int W[N];
int f[M], g[M];

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
        scanf("%d", &W[i]);

    memset(f, -0x3f, sizeof f);
    memset(g, -0x3f, sizeof g);
    f[0] = 0;
    for (int i = 1; i <= n; i++)
        for (int j = m; j >= 1; j--)
        {
            f[j] = max(f[j], g[j] + W[i]);
            g[j] = max(g[j], f[j - 1] - W[i]);
        }

    int res = *max_element(f, f + 1 + m);
    printf("%d\n", res);

    return 0;
}
```

### 股票买卖 V

题目：https://www.acwing.com/problem/content/description/1060/

题解：https://www.acwing.com/solution/content/55147/

```c++
#include <iostream>

using namespace std;

const int N = 1e5 + 10, INF = 1e9 + 10;

int n;
int W[N];
int f[N][3];

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%d", &W[i]);
    
    f[0][0] = f[0][1] = -INF;
    for (int i = 1; i <= n; i++)
    {
        f[i][0] = max(f[i - 1][0], f[i - 1][2] - W[i]);
        f[i][1] = f[i - 1][0] + W[i];
        f[i][2] = max(f[i - 1][2], f[i - 1][1]);
    }

    int res = max(f[n][1], f[n][2]);
    printf("%d\n", res);

    return 0;
}
```

### 设计密码

题目：https://www.acwing.com/problem/content/description/1054/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;

const int N = 55, MOD = 1e9 + 7;

int n, m;
std::string p;
int next[N];
int f[N][N];

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> p;
    m = p.size();
    p = ' ' + p;

    for (int i = 2, j = 0; i <= m; i++)
    {
        while (j && p[j + 1] != p[i]) j = next[j];
        if (p[j + 1] == p[i]) j++;
        next[i] = j;
    }

    f[0][0] = 1;
    for (int i = 0; i < n; i++)
        for (int j = 0; j <= std::min(i, m - 1); j++)
            for (char c = 'a'; c <= 'z'; c++)
            {
                int k = j;
                while (k && p[k + 1] != c) k = next[k];
                if (p[k + 1] == c) k++;
                f[i + 1][k] = (f[i + 1][k] + f[i][j]) % MOD;
            }

    int res = 0;
    for (int j = 0; j < m; j++) res = (res + f[n][j]) % MOD;

    cout << res << '\n';

    return 0;
}
```

### 修复DNA

题目：https://www.acwing.com/problem/content/description/1055/

题解：https://www.acwing.com/solution/content/189723/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;

const int M = 1010, INF = 0x3f3f3f3f;

int n;
struct TrieNode
{
    int son[4];
    bool isEnd;
} trie[M]; int idx;

int getSon(char c)
{
    switch (c)
    {
    case 'A': return 0;
    case 'G': return 1;
    case 'C': return 2;
    case 'T': return 3;
    }
    return -1;
}

void insert(std::string& word)
{
    int p = 0;
    for (char c : word)
    {
        int u = getSon(c);
        if (!trie[p].son[u]) trie[p].son[u] = ++idx;
        p = trie[p].son[u];
    }
    trie[p].isEnd = true;
}

int next[M];
int Q[M], hh, tt;

void getNext()
{
    bzero(next, sizeof next);
    tt = -1, hh = 0;
    for (int i = 0; i < 4; i++)
        if (trie[0].son[i])
            Q[++tt] = trie[0].son[i];

    while (hh <= tt)
    {
        int p = Q[hh++];
        trie[p].isEnd = trie[p].isEnd || trie[next[p]].isEnd;
        for (int i = 0; i < 4; i++)
            if (int q = trie[p].son[i]; !q)
            {
                trie[p].son[i] = trie[next[p]].son[i];
            }
            else
            {
                next[q] = trie[next[p]].son[i];
                Q[++tt] = q;
            }
    }
}

int T;
std::string str;
int f[M][M];

void solve()
{
    idx = 0;
    bzero(trie, sizeof trie);
    for (int i = 0; i < n; i++)
    {
        std::string word; cin >> word;
        insert(word);
    }

    getNext();

    cin >> str;
    int m = str.size();
    str = ' ' + str;

    memset(f, 0x3f, sizeof f);
    f[0][0] = 0;
    for (int i = 0; i < m; i++)
        for (int j = 0; j < idx; j++)
            if (!trie[j].isEnd)
                for (int k = 0; k < 4; k++)
                {
                    int cost = getSon(str[i + 1]) != k;
                    int p = trie[j].son[k];
                    if (!trie[p].isEnd)
                        f[i + 1][p] = std::min(f[i + 1][p], f[i][j] + cost);
                }

    int res = *std::min_element(f[m], f[m] + idx);
    if (res == INF) res = -1;
    cout << "Case " << ++T << ": " << res << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    while (cin >> n, n)
        solve();

    return 0;
}
```



## 状态压缩

### 小国王

题目：https://www.acwing.com/problem/content/description/1066/

题解：https://www.acwing.com/solution/content/56348/

```c++
#include <iostream>
#include <vector>

using namespace std;

typedef long long LL;

const int N = 12;
const int M = N * N, TOT = 1 << N;

int n, m, tot;
vector<int> states;
vector<int> trans[TOT];
int count[TOT];
LL f[N][M][TOT];

bool check(int s)
{
    return !(s & s >> 1);
}

int main()
{
    scanf("%d%d", &n, &m);
    tot = 1 << n;
    
    for (int s = 0; s < tot; s++)
        if (check(s))
        {
            states.push_back(s);
            int cnt = 0, x = s;
            while (x)
            {
                x -= x & -x;
                cnt++;
            }
            count[s] = cnt;
        }

    // for (int a : states)
    //     for (int b : states)
    //         if (!(a & b) && check(a | b))
    //             trans[a].push_back(b);

    trans[0].push_back(0); // 这是一个坑点
    for (int i = 0; i < states.size(); i++)
        for (int j = i + 1; j < states.size(); j++)
        {
            int a = states[i], b = states[j];
            if (!(a & b) && check(a | b))
            {
                trans[a].push_back(b);
                trans[b].push_back(a);
            }
        }

    f[0][0][0] = 1;
    for (int i = 1; i <= n + 1; i++)
        for (int j = 0; j <= m; j++)
            for (int a : states)
                for (int b : trans[a])
                    if (j >= count[a])
                        f[i][j][a] += f[i - 1][j - count[a]][b];
    
    printf("%lld\n", f[n + 1][m][0]);

    return 0;
}
```

### 玉米田

题目：https://www.acwing.com/problem/content/description/329/

题解：https://www.acwing.com/solution/content/56822/

```c++
#include <iostream>
#include <vector>

using namespace std;

const int N = 15, TOT = 1 << 12;
const int MOD = 1e8;

int n, m, tot;
int G[N];
vector<int> states;
vector<int> trans[TOT];
int f[N][TOT];

bool check(int s)
{
    return !(s & (s >> 1));
}

int main()
{
    scanf("%d%d", &n, &m);
    tot = 1 << m;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
        {
            int t; scanf("%d", &t);
            G[i] = (G[i] << 1) + t;
        }

    for (int s = 0; s < tot; s++)
        if (check(s)) states.push_back(s);

    // trans[0].push_back(0);
    // for (int i = 0; i < states.size(); i++)
    //     for (int j = i + 1; j < states.size(); j++)
    //     {
    //         int a = states[i], b = states[j];
    //         if (!(a & b))
    //         {
    //             trans[a].push_back(b);
    //             trans[b].push_back(a);
    //         }
    //     }

    for (int a : states)
        for (int b : states)
            if (!(a & b))
                trans[a].push_back(b);

    f[0][0] = 1;
    G[0] = 0xFFFFFFFF;
    for (int i = 1; i <= n + 1; i++)
        for (int a : states)
        {
            if ((a | G[i]) != G[i]) continue;
            for (int b : trans[a])
                f[i][a] = (f[i][a] + f[i - 1][b]) % MOD;
        }
    
    printf("%d\n", f[n + 1][0]);

    return 0;
}
```

### 炮兵阵地

题目：https://www.acwing.com/problem/content/description/294/

题解：https://www.acwing.com/solution/content/150426/

```c++
#include <iostream>
#include <vector>

using namespace std;

const int N = 110, M = 15;
const int TOT = 1 << 10;

int n, m, tot;
int G[N];
vector<int> states, trans[TOT];
int f[2][TOT][TOT];
int count[TOT];

bool check(int s)
{
    return !((s & (s >> 1)) || (s & (s >> 2)));
}

int main()
{
    scanf("%d%d", &n, &m);
    tot = 1 << m;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
        {
            char c; cin >> c;
            G[i] <<= 1;
            if (c == 'H') G[i] += 1;
        }

    for (int s = 0; s < tot; s++)
        if (check(s))
        {
            states.push_back(s);
            int cnt = 0, x = s;
            while (x)
            {
                cnt++;
                x -= x & -x;
            }
            count[s] = cnt;
        }

    for (int a : states)
        for (int b : states)
            if (!(a & b)) trans[a].push_back(b);
    
    for (int i = 1; i <= n + 2; i++)
        for (int a : states)
            if (!(a & G[i]))
                for (int b : trans[a])
                    for (int c : trans[b])
                        if (!(a & c))
                            f[i & 1][a][b] = max(f[i & 1][a][b], f[i - 1 & 1][b][c] + count[a]);

    printf("%d\n", f[n + 2 & 1][0][0]);

    return 0;
}
```

### 愤怒的小鸟

题目：https://www.acwing.com/problem/content/description/526/

题解：https://www.acwing.com/solution/content/4028/

**递推：**

```c++
#include <iostream>
#include <cmath>
#include <cstring>

#define x first
#define y second

using namespace std;

typedef pair<double, double> PDD;

const int N = 18, TOT = 1 << N;
const double eps = 1e-8;

int n, m, tot;
PDD P[N];
int curve[N][N];
int f[TOT];

int cmp(double a, double b)
{
    if (fabs(a - b) < eps) return 0;
    else return a > b ? 1 : -1;
}

int main()
{
    int T; scanf("%d", &T);
    while (T--)
    {
        scanf("%d%d", &n, &m);
        tot = 1 << n;
        for (int i = 0; i < n; i++)
            scanf("%lf%lf", &P[i].x, &P[i].y);
        
        memset(curve, 0, sizeof curve);
        for (int i = 0; i < n; i++)
        {
            curve[i][i] = 1 << i;
            auto [x1, y1] = P[i];
            for (int j = i + 1; j < n; j++)
            {
                auto [x2, y2] = P[j];
                if (cmp(x1, x2) == 0) continue;
                double tmp = x1 * x2 * (x1 - x2);
                double a = (y1 * x2 - y2 * x1) / tmp;
                if (cmp(a, 0) >= 0) continue;
                double b = (y2 * x1 * x1 - y1 * x2 * x2) / tmp;
                int state = 0;
                for (int k = 0; k < n; k++)
                {
                    auto [x, y] = P[k];
                    if (cmp(y, a * x * x + b * x) == 0)
                        state |= 1 << k;
                }
                curve[i][j] = curve[j][i] = state;
            }
        }

        memset(f, 0x3f, sizeof f);
        f[0] = 0;
        for (int s = 0; s < tot - 1; s++)
        {
            int i = 0;
            while (i < n && (s >> i & 1)) i++;
            for (int j = 0; j < n; j++)
                f[s | curve[i][j]] = min(f[s | curve[i][j]], f[s] + 1);
        }

        printf("%d\n", f[tot - 1]);
    }

    return 0;
}
```

**记忆化搜索：**

```c++
#include <iostream>
#include <cstring>

#define x first
#define y second

using namespace std;

typedef pair<double, double> PDD;

const int N = 18, TOT = 1 << N, CNT = N * N;
const double eps = 1e-8;

int n, m, tot;
PDD P[N];
int curve[N][N];

int cmp(double a, double b)
{
    if (abs(a - b) < eps) return 0;
    else return a > b ? 1 : -1;
}

int f[TOT];
int dfs(int s)
{
    if (f[s]) return f[s];
    if (s == tot - 1) return 0;

    int i = 0;
    while (i < n && (s >> i & 1)) i++;
    int res = CNT;
    for (int j = 0; j < n; j++)
    {
        int ns = s | curve[i][j];
        if (curve[i][j]) res = min(res, dfs(ns) + 1);
    }
    return f[s] = res;
}

int main()
{
    int T; scanf("%d", &T);
    while (T--)
    {
        scanf("%d%d", &n, &m);
        tot = 1 << n;
        for (int i = 0; i < n; i++)
            scanf("%lf%lf", &P[i].x, &P[i].y);
        
        memset(curve, 0, sizeof curve);
        for (int i = 0; i < n; i++)
        {
            curve[i][i] = 1 << i;
            auto [x1, y1] = P[i];
            for (int j = i + 1; j < n; j++)
            {
                auto [x2, y2] = P[j];
                if (cmp(x1, x2) == 0) continue;
                double tmp = x1 * x2 * (x1 - x2);
                double a = (y1 * x2 - y2 * x1) / tmp;
                if (cmp(a, 0) >= 0) continue;
                double b = (y2 * x1 * x1 - y1 * x2 * x2) / tmp;
                int state = 0;
                for (int k = 0; k < n; k++)
                {
                    auto [x, y] = P[k];
                    if (cmp(y, a * x * x + b * x) == 0)
                        state |= 1 << k;
                }
                curve[i][j] = curve[j][i] = state;
            }
        }

        memset(f, 0, sizeof f);        
        int res = dfs(0);
        printf("%d\n", res);
    }

    return 0;
}
```

### 宝藏

题目：https://www.acwing.com/problem/content/description/531/

题解：https://www.acwing.com/solution/content/4026/

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 12, TOT = 1 << 12;
const int INF = 0x3f3f3f3f;

int n, m, tot;
int d[N][N];
int trans[TOT];
int f[TOT][N];

int main()
{
	scanf("%d%d", &n, &m);
	tot = 1 << n;

	memset(d, 0x3f, sizeof d);
	while (m--)
	{
		int a, b, w; scanf("%d%d%d", &a, &b, &w);
		a--, b--;
		d[a][b] = d[b][a] = min(d[a][b], w);
	}

	for (int s = 1; s < tot; s++)
		for (int i = 0; i < n; i++)
			if (s >> i & 1)
				for (int j = 0; j < n; j++)
					if (i == j || d[i][j] != INF)
						trans[s] |= 1 << j;	

	memset(f, 0x3f, sizeof f);
	for (int i = 0; i < n; i++) f[1 << i][0] = 0;
	for (int s = 1; s < tot; s++)
		for (int r = s & (s - 1); r; r = s & (r - 1))
			if ((trans[r] & s) == s)
			{
				int t = s ^ r;
				int cost = 0;
				for (int i = 0; i < n; i++)
					if (t >> i & 1)
					{
						int tmp = INF;
						for (int j = 0; j < n; j++)
							if (r >> j & 1) tmp = min(tmp, d[i][j]);
						cost += tmp;
					}
				for (int i = 1; i < n; i++)
					f[s][i] = min(f[s][i], f[r][i - 1] + cost * i);
			}

	int res = *min_element(f[tot - 1], f[tot - 1] + n);
	printf("%d\n", res);
	
	return 0;
}
```

## 区间DP

### 环形石子合并

题目：https://www.acwing.com/problem/content/description/1070/

题解：https://www.acwing.com/solution/content/59932/

```c++
#include <cstring>
#include <climits>
#include <iostream>

using namespace std;

const int N = 410;

int n, n_2;
int W[N], ps[N];
int f[N][N], g[N][N];

int main()
{
    scanf("%d", &n);
    n_2 = n * 2;
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &W[i]);
        W[i + n] = W[i];
    }
    for (int i = 1; i < n_2; i++)
        ps[i] = ps[i - 1] + W[i];
    
    memset(f, 0x3f, sizeof f);
    for (int i = 1; i < n_2; i++)
        f[i][i] = g[i][i] = 0;


    for (int len = 2; len <= n; len++)
        for (int l = 1; l + len - 1 < n_2; l++)
        {
            int r = l + len - 1;
            int sum = ps[r] - ps[l - 1];
            for (int k = l; k < r; k++)
            {
                f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + sum);
                g[l][r] = max(g[l][r], g[l][k] + g[k + 1][r] + sum);
            }
        }
    
    int mx = INT_MIN, mn = INT_MAX;
    for (int l = 1; l <= n; l++)
    {
        int r = l + n - 1;
        mx = max(mx, g[l][r]);
        mn = min(mn, f[l][r]);
    }

    printf("%d\n%d\n", mn, mx);

    return 0;
}
```

### 能量项链

题目：https://www.acwing.com/problem/content/description/322/

题解：https://www.acwing.com/solution/content/60478/

```c++
#include <iostream>

using namespace std;

const int N = 210;

int n, n_2;
int W[N];
int f[N][N];

int main()
{
    scanf("%d", &n);
    n_2 = n * 2;
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &W[i]);
        W[i + n] = W[i];
    }
    
    for (int len = 2; len <= n; len++)
        for (int l = 1; l + len - 1 < n_2; l++)
        {
            int r = l + len - 1;
            for (int k = l; k < r; k++)
                f[l][r] = max(f[l][r], f[l][k] + f[k + 1][r] + W[l] * W[k + 1] * W[r + 1]);
        }
        
    int res = 0;
    for (int l = 1; l <= n; l++)
        res = max(res, f[l][l + n - 1]);
    printf("%d\n", res);
    
    return 0;
}
```

### 加分二叉树

题目：https://www.acwing.com/problem/content/description/481/

题解：https://www.acwing.com/solution/content/3804/

```c++
#include <iostream>
#include <functional>

using namespace std;

const int N = 35;

int n;
int f[N][N], R[N][N];

int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
	{
		scanf("%d", &f[i][i]);
		R[i][i] = i; 
	}

	for (int len = 2; len <= n; len++)
		for (int l = 1; l + len - 1 <= n; l++)
		{
			int r = l + len - 1;
			for (int k = l; k <= r; k++)
			{
				int lt = k == l ? 1 : f[l][k - 1];
				int rt = k == r ? 1 : f[k + 1][r];
				int t = lt * rt + f[k][k];
				if (t > f[l][r])
				{
					f[l][r] = t;
					R[l][r] = k;
				}
			}
		}

	function<void(int, int)> dfs = [&](int l, int r)
	{
		if (l > r) return;

		int root = R[l][r];
		printf("%d ", root);
		dfs(l, root - 1);
		dfs(root + 1, r);
	};
	printf("%d\n", f[1][n]);
	dfs(1, n);
	puts("");
	
	return 0;
}
```

### 凸多边形的划分

题目：https://www.acwing.com/problem/content/description/1071/

题解：https://www.acwing.com/solution/content/62040/

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;
using LL = long long;

const int N = 55, D = 29;

int n;
int W[N];
vector<int> f[N][N];

vector<int> get_vec(int x)
{
	vector<int> C;
	while (x)
	{
		C.push_back(x % 10);
		x /= 10;
	}
	return C;
}

int cmp(vector<int>& A, vector<int>& B)
{
	if (A.size() != B.size())
		return A.size() > B.size() ? 1 : -1;

	for (int i = A.size() - 1; i >= 0; i--)
	{
		if (A[i] == B[i]) continue;
		return A[i] > B[i] ? 1 : -1;
	}
	return 0;
}

vector<int> mul(vector<int>& A, LL b)
{
	vector<int> C;
	LL t = 0;
	for (int a : A)
	{
		t += a * b;
		C.push_back(t % 10);
		t /= 10;
	}
	while (t)
	{
		C.push_back(t % 10);
		t /= 10;
	}
	return C;
}

vector<int> add(vector<int>& A, vector<int>& B)
{
	if (A.size() > B.size()) return add(B, A);

	vector<int> C;
	int t = 0, idx = 0;
	while (idx < A.size())
	{
		t += A[idx] + B[idx];
		C.push_back(t % 10);
		t /= 10;
		idx++;
	}
	while (idx < B.size())
	{
		t += B[idx];
		C.push_back(t % 10);
		t /= 10;
		idx++;
	}
	if (t) C.push_back(t);
	return C;
}

int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &W[i]);

	for (int len = 3; len <= n; len++)
		for (int l = 1; l + len - 1 <= n; l++)
		{
			int r = l + len - 1;
			f[l][r].resize(D, 9);
			for (int k = l + 1; k < r; k++)
			{
				vector<int> t1 = add(f[l][k], f[k][r]);
				vector<int> t2 = get_vec(W[l]);
				t2 = mul(t2, W[k]); t2 = mul(t2, W[r]);
				vector<int> t3 = add(t1, t2);
				if (cmp(t3, f[l][r]) < 0) f[l][r] = t3;
			}
		}

	for_each(f[1][n].rbegin(), f[1][n].rend(), [](int x)
			 { printf("%d ", x); });

	return 0;
}
```

### 棋盘分割

题目：https://www.acwing.com/problem/content/description/323/

题解：https://www.acwing.com/solution/content/62836/

```c++
#include <cmath>
#include <cstring>
#include <cfloat>
#include <iostream>

using namespace std;

const int N = 15, M = 8;

int n;
double ps[M + 1][M + 1], ave;
double f[N][M + 1][M + 1][M + 1][M + 1];

inline double sum(int x1, int y1, int x2, int y2)
{
	return ps[x2][y2] - ps[x2][y1 - 1] - ps[x1 - 1][y2] + ps[x1 - 1][y1 - 1];
}

double var(int x1, int y1, int x2, int y2)
{
	double tmp = sum(x1, y1, x2, y2) - ave;
	return tmp * tmp / n;
}

double dfs(int k, int x1, int y1, int x2, int y2)
{
	if (!k) return var(x1, y1, x2, y2);

	double& v = f[k][x1][y1][x2][y2];
	if (v >= 0) return v;
	v = DBL_MAX;
	for (int x = x1; x < x2; x++)
	{
		v = min(v, dfs(k - 1, x1, y1, x, y2) + var(x + 1, y1, x2, y2));
		v = min(v, var(x1, y1, x, y2) + dfs(k - 1, x + 1, y1, x2, y2));
	}
	for (int y = y1; y < y2; y++)
	{
		v = min(v, dfs(k - 1, x1, y1, x2, y) + var(x1, y + 1, x2, y2));
		v = min(v, var(x1, y1, x2, y) + dfs(k - 1, x1, y + 1, x2, y2));
	}
	return v;
}

int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= M; i++)
		for (int j = 1; j <= M; j++)
		{
			scanf("%lf", &ps[i][j]);
			ps[i][j] += ps[i - 1][j] + ps[i][j - 1] - ps[i - 1][j - 1];
		}
	ave = ps[M][M] / n;

	memset(f, -1, sizeof f);

	double res = sqrt(dfs(n - 1, 1, 1, M, M));
	printf("%.3lf\n", res);

	return 0;
}
```

## 树形DP

### 树的最长路径

题目：https://www.acwing.com/problem/content/description/1074/

题解：https://www.acwing.com/solution/content/29832/

```c++
#include <iostream>
#include <functional>

using namespace std;

const int N = 1e4 + 10;

int n;
int H[N];
struct ListNode
{
	int v, w, n;
} L[N * 2]; int idx = 1;

void add(int a, int b, int w)
{
	L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

int main()
{
	scanf("%d", &n);
	while ((n--) > 1)
	{
		int a, b, w; scanf("%d%d%d", &a, &b, &w);
		add(a, b, w); add(b, a, w);
	}

	int res = 0;
	function<int(int, int)> dfs = [&](int u, int f)
	{
		int d1 = 0, d2 = 0;
		for (int p = H[u]; p; p = L[p].n)
		{
			if (L[p].v == f) continue;
			int d = dfs(L[p].v, u) + L[p].w;
			if (d >= d1) d2 = d1, d1 = d;
			else if (d > d2) d2 = d;
		}
		res = max(res, d1 + d2);
		return d1;
	};
	dfs(1, 0);

	printf("%d\n", res);

	return 0;
}
```

### 树的中心

题目：https://www.acwing.com/problem/content/description/1075/

题解：https://www.acwing.com/solution/content/65263/

```c++
#include <climits>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e4 + 10;

int n;
int H[N];
struct ListNode
{
	int v, w, n;
} L[N * 2]; int idx = 1;

void add(int a, int b, int w)
{
	L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

int d1[N], d2[N], up[N];
int s1[N], s2[N];

void dfsDown(int u, int ft)
{
	for (int p = H[u]; p; p = L[p].n)
	{
		int v = L[p].v, w = L[p].w;
		if (v == ft) continue;
		dfsDown(v, u);
		int d = w + d1[v];
		if (d >= d1[u])
		{
			d2[u] = d1[u], s2[u] = s1[u];
			d1[u] = d, s1[u] = v;
		}
		else if (d > d2[u])
		{
			d2[u] = d, s2[u] = v;
		}
	}
}

void dfsUp(int u, int ft)
{
	for (int p = H[u]; p; p = L[p].n)
	{
		int v = L[p].v, w = L[p].w;
		if (v == ft) continue;
		up[v] = w + max(up[u], v == s1[u] ? d2[u] : d1[u]);
		dfsUp(v, u);
	}
}

int main()
{
	scanf("%d", &n);
	for (int i = 1; i < n; i++)
	{
		int a, b, w; scanf("%d%d%d", &a, &b, &w);
		add(a, b, w), add(b, a, w);
	}

	dfsDown(1, 0);
	dfsUp(1, 0);

	int res = INT_MAX;
	for (int i = 1; i <= n; i++) 
		res = min(res, max(up[i], d1[i]));
	printf("%d\n", res);

	return 0;
}
```

### 数字转换

题目：https://www.acwing.com/problem/content/description/1077/

题解：https://www.acwing.com/solution/content/65467/

```c++
#include <iostream>
#include <functional>

using namespace std;

const int N = 5e4 + 10;

int n;
int sum[N];
int H[N];
struct ListNode
{
	int v, n;
} L[N * 2]; int idx = 1;

void add(int a, int b)
{
	L[idx].v = b, L[idx].n = H[a], H[a] = idx++;
}

int main()
{
	scanf("%d", &n);

	for (int i = 1; i <= n; i++)
		for (int j = 2; j <= n / i; j++)
			sum[i * j] += i;
	
	for (int i = 2; i <= n; i++)
		if (i > sum[i])
		{
			add(i, sum[i]);
			add(sum[i], i);
		}

	int res = 0;
	function<int(int, int)> dfs = [&](int u, int ft) -> int
	{
		int d1 = 0, d2 = 0;
		for (int p = H[u]; p; p = L[p].n)
		{
			int v = L[p].v;
			if (v == ft) continue;
			int d = 1 + dfs(v, u);
			if (d >= d1) d2 = d1, d1 = d;
			else if (d > d2) d2 = d;
		}
		res = max(res, d1 + d2);
		return d1;
	};
	
	dfs(1, 0);
	printf("%d", res);

	return 0;
}
```

### 二叉苹果树

题目：https://www.acwing.com/problem/content/description/1076/

题解：https://www.acwing.com/solution/content/65600/

```c++
#include <iostream>
#include <algorithm>
#include <functional>

using namespace std;

const int N = 110;

int n, q;
int H[N];
struct ListNode
{
	int v, w, n;
} L[N * 2]; int idx = 1;

void add(int a, int b, int w)
{
	L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

int f[N][N];
void dfs(int u, int ft)
{
	for (int p = H[u]; p; p = L[p].n)
	{
		int v = L[p].v, w = L[p].w;
		if (v == ft) continue;
		dfs(v, u);
		for (int j = q; j > 0; j--)
			for (int k = 0; k < j; k++)
				f[u][j] = max(f[u][j], f[u][j - k - 1] + f[v][k] + w);
	}
}

int main()
{
	scanf("%d%d", &n, &q);
	for (int i = 1; i < n; i++)
	{
		int a, b, w; scanf("%d%d%d", &a, &b, &w);
		add(a, b, w), add(b, a, w);
	}

	dfs(1, 0);

	printf("%d\n", f[1][q]);

	return 0;
}
```

### 战略游戏

题目：https://www.acwing.com/problem/content/description/325/

题解：https://www.acwing.com/solution/content/66365/

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1510;

int n;
int H[N];
struct ListNode
{
	int v, n;
} L[N * 2]; int idx = 1;

void add(int a, int b)
{
	L[idx].v = b, L[idx].n = H[a], H[a] = idx++;
}

int f[N][2];
void dfs(int u, int ft)
{
	f[u][1] = 1;
	for (int p = H[u]; p; p = L[p].n)
	{
		int v = L[p].v;
		if (v == ft) continue;
		dfs(v, u);
		f[u][1] += min(f[v][1], f[v][0]);
		f[u][0] += f[v][1];
	}
}

int main()
{
	while (scanf("%d", &n) != EOF)
	{
		memset(H, 0, sizeof H);
		memset(L, 0, sizeof L), idx = 1;
		memset(f, 0, sizeof f);

		for (int i = 1; i <= n; i++)
		{
			int u, cnt; scanf("%d:(%d)", &u, &cnt);
			while (cnt--)
			{
				int v; scanf("%d", &v);
				add(u + 1, v + 1), add(v + 1, u + 1);
			}
		}

		dfs(1, 0);

		printf("%d\n", min(f[1][0], f[1][1]));
	}

	return 0;
}
```

### 皇宫看守

题目：https://www.acwing.com/problem/content/description/1079/

题解：https://www.acwing.com/solution/content/66594/

```c++
#include <climits>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1510;

int n;
int W[N];
int H[N];
struct ListNode
{
	int v, n;
} L[N * 2]; int idx = 1;

void add(int a, int b)
{
	L[idx].v = b, L[idx].n = H[a], H[a] = idx++;
}

int f[N][3];
void dfs(int u, int ft)
{
	f[u][2] = W[u];
	for (int p = H[u]; p; p = L[p].n)
	{
		int v = L[p].v;
		if (v == ft) continue;
		dfs(v, u);
		f[u][0] += min(f[v][1], f[v][2]);
		f[u][2] += min({ f[v][0], f[v][1], f[v][2] });
	}

	f[u][1] = INT_MAX;
	for (int p = H[u]; p; p = L[p].n)
	{
		int v = L[p].v;
		if (v == ft) continue;
		f[u][1] = min(f[u][1], f[u][0] - min(f[v][1], f[v][2]) + f[v][2]);
	}
}

int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
	{
		int u, w, cnt; scanf("%d%d%d", &u, &w, &cnt);
		W[u] = w;
		while (cnt--)
		{
			int v; scanf("%d", &v);
			add(v, u), add(u, v);
		}
	}

	dfs(1, 0);

	printf("%d\n", min(f[1][1], f[1][2]));

	return 0;
}
```

## 数位DP

### 度的数量

题目：https://www.acwing.com/problem/content/description/1083/

题解：https://www.acwing.com/solution/content/66855/

```c++
#include <iostream>
#include <vector>

using namespace std;

const int N = 31;

int X, Y, K, B;
int C[N][N];

int dp(int n)
{
	vector<int> ds;
	while (n)
	{
		ds.push_back(n % B);
		n /= B;
	}

	int res = 0, cnt = 0;
	for (int i = ds.size() - 1; i >= 0; i--)
	{
		int d = ds[i];
		if (d > 0) res += C[i][K - cnt];
		if (d > 1)
		{
			res += C[i][K - cnt - 1];
			break;
		}
		if (d == 1 && ++cnt == K)
		{
			res++;
			break;
		}
	}

	return res;
}

int main()
{
	for (int i = 0; i < N; i++)
		for (int j = 0; j <= i; j++)
			if (!j) C[i][j] = 1;
			else C[i][j] = C[i - 1][j - 1] + C[i - 1][j];

	scanf("%d%d%d%d", &X, &Y, &K, &B);
	
	printf("%d\n", dp(Y) - dp(X - 1));

	return 0;
}
```

### 数字游戏

题目：https://www.acwing.com/problem/content/description/1084/

题解：https://www.acwing.com/solution/content/33446/

```c++
#include <iostream>
#include <vector>
#include <numeric>

using namespace std;

const int N = 12;

int l, r;
int f[N][N];

void init()
{
	for (int j = 0; j <= 9; j++) f[1][j] = 1;
	for (int i = 2; i < N; i++)
		for (int j = 0; j <= 9; j++)
			f[i][j] = accumulate(f[i - 1] + j, f[i - 1] + 10, 0);
}

int dp(int n)
{
	vector<int> ds;
	while (n)
	{
		ds.push_back(n % 10);
		n /= 10;
	}

	int res = 0, last = 0;
	int i = ds.size() - 1;
	for (; i >= 0; i--)
	{
		int d = ds[i];
		if (d < last) break;
		else if (d > last)
		{
			res += accumulate(f[i + 1] + last, f[i + 1] + d, 0);
			last = d;
		}
	}
	if (i < 0) res++;
	return res;
}

int main()
{
	init();

	while (scanf("%d%d", &l, &r) != EOF)
		printf("%d\n", dp(r) - dp(l - 1));

	return 0;
}
```

### Windy数

题目：https://www.acwing.com/problem/content/1085/

题解：https://www.acwing.com/solution/content/15562/

```c++
#include <iostream>
#include <vector>

using namespace std;

const int N = 11;

int A, B;
int f[N][N];

void init()
{
	for (int j = 0; j <= 9; j++) f[1][j] = 1;
    for (int i = 2; i < N; i++) 
		for (int j = 0; j <= 9; j++)
		{
			for (int k = j - 2; k >= 0; k--) f[i][j] += f[i - 1][k];
			for (int k = j + 2; k <= 9; k++) f[i][j] += f[i - 1][k];
		}
}

int dp(int n)
{
	vector<int> ds;
	while (n) ds.push_back(n % 10), n /= 10;

	int res = 0, last = -2;
	int end = ds.size() - 1;
	int i = end;
	for (; i >= 0; i--)
	{
		int d = ds[i];
		for (int j = (i == end); j < d; j++)
			if (abs(j - last) >= 2)
				res += f[i + 1][j];

		if (abs(d - last) < 2) break;
		last = d;
	}
	if (i < 0) res++; // 这种写法会导致n=0时返回1

	for (int i = 1; i <= end; i++)
		for (int j = (i > 1); j <= 9; j++)
			res += f[i][j];
			
	return res;
}


int main()
{
	init();

	scanf("%d%d", &A, &B);

	printf("%d\n", dp(B) - dp(A - 1));

	return 0;
}
```

### 数字游戏 II

题目：https://www.acwing.com/problem/content/description/1086/

题解：https://www.acwing.com/solution/content/15556/

```c++
#include <cstring>
#include <iostream>
#include <vector>

using namespace std;

const int N = 100, LEN = 32;

int a, b, p;
int f[LEN][10][N];

int mod(int u, int v)
{
	return (u % v + v) % v;
}

void init()
{
	memset(f, 0, sizeof f);
	for (int i = 0; i < 10; i++) f[1][i][i % p]++;
	for (int len = 2; len < LEN; len++)
		for (int i = 0; i <= 9; i++)
			for (int j = 0; j < p; j++)
				for (int k = 0; k <= 9; k++)
					f[len][i][j] += f[len - 1][k][mod(j - i, p)];
}

int dp(int n)
{
	vector<int> ds;
	while (n) ds.push_back(n % 10), n /= 10;

	int res = 0, last = 0;
	for (int i = ds.size() - 1; i >= 0; i--)
	{
		int d = ds[i];
		for (int j = 0; j < d; j++) 
			res += f[i + 1][j][mod(-last, p)];
		last += d;
	}
	if (last % p == 0) res++;
	return res;
}

int main()
{
	while (scanf("%d%d%d", &a, &b, &p) != EOF)
	{
		init();

		printf("%d\n", dp(b) - dp(a - 1));
	}

	return 0;
}
```

### 不要62

题目：https://www.acwing.com/problem/content/1087/

题解：https://www.acwing.com/solution/content/15582/

```c++
#include <iostream>
#include <numeric>
#include <vector>

using namespace std;

const int N = 11;

int l, r;
int f[N][10];

void init()
{
	for (int i = 0; i <= 9; i++)
		if (i != 4) f[1][i] = 1;
	
	for (int len = 2; len < N; len++)
		for (int i = 0; i <= 9; i++)
			if (i != 4)
			{
				f[len][i] += accumulate(f[len - 1], f[len - 1] + 10, 0);
				if (i == 6) f[len][i] -= f[len - 1][2];
			}
}

int dp(int n)
{
	vector<int> ds;
	while (n) ds.push_back(n % 10), n /= 10;

	int res = 0, last = 0;
	int i = ds.size() - 1;
	for (; i >= 0; i--)
	{
		int d = ds[i];
		for (int j = 0; j < d; j++)
		{
			if (last == 6 && j == 2) continue;
			res += f[i + 1][j];
		}
		if (d == 4 || (last == 6 && d == 2)) break;
		last = d;
	}
	if (i < 0) res++;
	return res;
}

int main()
{
	init();

	while (scanf("%d%d", &l, &r), l || r)
		printf("%d\n", dp(r) - dp(l - 1));

	return 0;
}
```

### 恨7不成妻

题目：https://www.acwing.com/problem/content/1088/

题解：https://www.acwing.com/solution/content/47501/

```c++
#include <iostream>
#include <vector>

using namespace std;
using LL = long long;

const int N = 20, P = 7, MOD = 1e9 + 7;

int T;
LL l, r;
struct F
{
    LL cnt, s0, s1;
} f[N][10][P][P];
LL pow7[N], pow9[N];

LL mod(LL x, LL y)
{
    return ((x % y) + y) % y;
}

void init()
{
    pow7[0] = pow9[0] = 1;
    for (int i = 1; i < N; i++) pow7[i] = (pow7[i - 1] * 10) % P;
    for (int i = 1; i < N; i++) pow9[i] = (pow9[i - 1] * 10) % MOD;

    for (int i = 0; i <= 9; i++)
        if (i != 7)
        {
            auto& v = f[1][i][i % P][i % P];
            v.cnt++;
            v.s0 += i;
            v.s1 += i * i;
        }

    for (int len = 2; len < N; len++)
        for (int i = 0; i <= 9; i++)
            if (i != 7)
                for (int j = 0; j < P; j++)
                    for (int k = 0; k < P; k++)
                    {
                        auto& cur = f[len][i][j][k];
                        for (int r = 0; r <= 9; r++)
                            if (r != 7)
                            {
                                auto& pre = f[len - 1][r][mod(j - i, P)][mod(k - i * pow7[len - 1], P)];
                                cur.cnt = (cur.cnt + pre.cnt) % MOD;
                                cur.s0 = (cur.s0 + (pre.cnt * i % MOD * pow9[len - 1] % MOD + pre.s0) % MOD) % MOD;
                                cur.s1 = ((i * pow9[len - 1] % MOD * i % MOD * pow9[len - 1] % MOD * pre.cnt % MOD) +
                                          (2 * i % MOD * pow9[len - 1] % MOD * pre.s0 % MOD) +
                                          cur.s1 + pre.s1) % MOD;
                            }
                    }
}

F get(int len, int i, int j, int k)
{
    LL cnt = 0, s0 = 0, s1 = 0;
    for (int r = 0; r < P; r++)
        if (r != j)
            for (int s = 0; s < P; s++)
                if (s != k)
                {
                    auto v = f[len][i][r][s];
                    cnt = (cnt + v.cnt) % MOD;
                    s0 = (s0 + v.s0) % MOD;
                    s1 = (s1 + v.s1) % MOD;
                }

    return { cnt, s0, s1 };
}

LL dp(LL n)
{
    if (!n) return 0;
 
    LL x = n;
    n %= MOD;
    vector<int> ds;
    while (x) ds.push_back(x % 10), x /= 10;

    LL l1 = 0, l2 = 0, res = 0;
    int i = ds.size() - 1;
    for (; i >= 0; i--)
    {
        int d = ds[i];
        for (int j = 0; j < d; j++)
            if (j != 7)
            {
                int r = mod(-l1, P), s = mod(-l2 * pow7[i + 1], P);
                auto v = get(i + 1, j, r, s);
                res = (res + (l2 % MOD * pow9[i + 1] % MOD * (l2 % MOD) % MOD * pow9[i + 1] % MOD * v.cnt % MOD +
                              l2 % MOD * 2 % MOD * pow9[i + 1] % MOD * v.s0 % MOD +
                              v.s1) % MOD) % MOD;
            }

        if (d == 7) break;
        l1 += d;
        l2 = l2 * 10 + d;
    }
    if (i < 0 && l1 % P && l2 % P) 
        res = (res + n * n) % MOD;
    
    return res;
}

int main()
{
    init();
    scanf("%d", &T);
    while (T--)
    {
        scanf("%lld%lld", &l, &r);
        printf("%d\n", mod(dp(r) - dp(l - 1), MOD));
    }

    return 0;
}
```

## 单调队列优化DP

### 最大子序和

题目：https://www.acwing.com/problem/content/description/137/

题解：https://www.acwing.com/solution/content/67527/

```c++
#include <climits>
#include <iostream>

using namespace std;

const int N = 3e5 + 10;

int n, m;
int ps[N];
int Q[N], hh, tt;

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &ps[i]);
        ps[i] += ps[i - 1];
    }

    hh = 0, tt = 0; Q[0] = 0;
    int res = INT_MIN;
    for (int i = 1; i <= n; i++)
    {
        if (hh <= tt && i - Q[hh] > m) hh++;
        res = max(res, ps[i] - ps[Q[hh]]);
        while (hh <= tt && ps[Q[tt]] >= ps[i]) tt--;
        Q[++tt] = i;
    }

    printf("%d\n", res);

    return 0;s
}
```

### 修剪草坪

题目：https://www.acwing.com/problem/content/1089/

题解：https://www.acwing.com/solution/content/27326/

```c++
#include <iostream>
#include <algorithm>

using namespace std;
using LL = long long;

const int N = 1e5 + 10;

int n, m;
int Q[N], hh, tt = -1;
LL ps[N];
LL f[N], g[N];

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &ps[i]);
        ps[i] += ps[i - 1];
    }

    Q[++tt] = 0;
    for (int i = 1; i <= n; i++)
    {
        g[i] = f[i - 1] - ps[i];
        if (hh <= tt && Q[hh] < i - m) hh++;
        f[i] = max(f[i - 1], g[Q[hh]] + ps[i]);
        while (hh <= tt && g[Q[tt]] <= g[i]) tt--;
        Q[++tt] = i;
    }

    printf("%lld\n", f[n]);

    return 0;
}
```

### 旅行问题

题目：https://www.acwing.com/problem/content/description/1090/

题解：https://www.acwing.com/solution/content/67696/

```c++
#include <iostream>

using namespace std;
using LL = long long;

const int N = 1e6 + 10, N2 = N * 2;

int n, n2;
LL sp[N2], sd[N2];
bool f[N];
int Q[N2], hh, tt;

LL g(int j) { return sp[j] - sd[j]; }

LL h(int j) { return sd[j - 1] - sp[j]; }

int main()
{
    scanf("%d", &n);
    n2 = n * 2;
    for (int i = 1; i <= n; i++)
    {
        scanf("%d%d", &sp[i], &sd[i]);
        sp[i + n] = sp[i], sd[i + n] = sd[i];
    }
    for (int i = 1; i <= n2; i++)
        sp[i] += sp[i - 1], sd[i] += sd[i - 1];

    hh = 0, tt = -1;
    for (int i = 1; i <= n2; i++)
    {
        if (hh <= tt && Q[hh] < i - n) hh++;
        if (i > n && g(Q[hh]) + sd[i - n - 1] - sp[i - n - 1] >= 0)
            f[i - n] = true;
        while (hh <= tt && g(Q[tt]) >= g(i)) tt--;
        Q[++tt] = i;
    }

    hh = 0, tt = -1;
    for (int i = 1; i <= n2; i++)
    {
        if (hh <= tt && Q[hh] < i - n) hh++;
        if (i > n && h(Q[hh]) + sp[i] - sd[i - 1] >= 0)
            f[i - n] = true;
        while (hh <= tt & h(Q[tt]) >= h(i)) tt--;
        Q[++tt] = i;
    }

    for (int i = 1; i <= n; i++)
        puts(f[i] ? "TAK" : "NIE");

    return 0;
}
```

### 烽火传递

题目：https://www.acwing.com/problem/content/description/1091/

题解：https://www.acwing.com/solution/content/27813/

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 2e5 + 10;

int n, m;
int f[N];
int Q[N], hh, tt;

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%d", &f[i]);

    for (int i = 1; i <= n; i++)
    {
        if (hh <= tt && Q[hh] < i - m) hh++;
        f[i] += f[Q[hh]];
        while (hh <= tt && f[Q[tt]] >= f[i]) tt--;
        Q[++tt] = i;
    }
	// 这里也可以继续滑动一次窗口
    int res = *min_element(f + n - m + 1, f + n + 1);
    printf("%d\n", res);

    return 0;
}
```

### 绿色通道

题目：https://www.acwing.com/problem/content/description/1092/

题解：https://www.acwing.com/solution/content/67926/

```c++
#include <cstring>
#include <iostream>

using namespace std;

const int N = 5e4 + 10;

int n, t;
int W[N];
int f[N];
int Q[N], hh, tt;

bool check(int m)
{
    m++;
    // memset(f, 0, sizeof f);
    hh = tt = 0;
    for (int i = 1; i <= n; i++)
    {
        if (hh <= tt && Q[hh] < i - m) hh++;
        f[i] = f[Q[hh]] + W[i];
        while (hh <= tt && f[Q[tt]] >= f[i]) tt--;
        Q[++tt] = i;
    }
    if (Q[hh] < n + 1 - m) hh++;
    return f[Q[hh]] <= t;
}

int main()
{
    scanf("%d%d", &n, &t);
    for (int i = 1; i <= n; i++) scanf("%d", &W[i]);

    int l = 0, r = n;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }

    printf("%d\n", l);

    return 0;
}
```

### 理想的正方形

题目：https://www.acwing.com/problem/content/1093/

题解：https://www.acwing.com/solution/content/54792/

```c++
#include <climits>
#include <iostream>

using namespace std;

const int N = 1010;

int n, m, w;
int W[N][N];
int RMX[N][N], RMN[N][N];
int C[N], CMX[N], CMN[N];
int Q[N], hh, tt;

void getMin(int tar[], int sou[], int len)
{
    hh = 0, tt = -1;
    for (int i = 1; i <= len; i++)
    {
        if (hh <= tt && Q[hh] <= i - w) hh++;
        while (hh <= tt && sou[Q[tt]] >= sou[i]) tt--;
        Q[++tt] = i;
        tar[i] = sou[Q[hh]];
    }
}

void getMax(int tar[], int sou[], int len)
{
    hh = 0, tt = -1;
    for (int i = 1; i <= len; i++)
    {
        if (hh <= tt && Q[hh] <= i - w) hh++;
        while (hh <= tt && sou[Q[tt]] <= sou[i]) tt--;
        Q[++tt] = i;
        tar[i] = sou[Q[hh]];
    }
}

int main()
{
    scanf("%d%d%d", &n, &m, &w);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            scanf("%d", &W[i][j]);

    for (int i = 1; i <= n; i++)
    {
        getMin(RMN[i], W[i], m);
        getMax(RMX[i], W[i], m);
    }

    int res = INT_MAX;
    for (int j = w; j <= m; j++)
    {
        for (int i = 1; i <= n; i++) C[i] = RMN[i][j];
        getMin(CMN, C, n);

        for (int i = 1; i <= n; i++) C[i] = RMX[i][j];
        getMax(CMX, C, n);

        for (int i = w; i <= n; i++) 
            res = min(res, CMX[i] - CMN[i]);
    }

    printf("%d\n", res);

    return 0;
}
```

## 斜率优化DP

### 任务安排1

题目：https://www.acwing.com/problem/content/description/302/

题解：https://www.acwing.com/solution/content/68062/

```c++
#include <cstring>
#include <iostream>

using namespace std;
using LL = long long;

const int N = 5010;

int n, s;
int sc[N], st[N];
LL f[N];

int main()
{
    scanf("%d%d", &n, &s);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d%d", &st[i], &sc[i]);
        st[i] += st[i - 1];
        sc[i] += sc[i - 1];
    }

    memset(f, 0x3f, sizeof f);
    f[0] = 0;
    for (int i = 1; i <= n; i++)
        for (int j = 0; j < i; j++)
            f[i] = min(f[i], f[j] + st[i] * LL(sc[i] - sc[j]) + s * LL(sc[n] - sc[j]));

    printf("%lld\n", f[n]);

    return 0;
}
```

### 任务安排2

题目：https://www.acwing.com/problem/content/description/303/

题解：https://www.acwing.com/solution/content/35208/

```c++
#include <iostream>

using namespace std;
using LL = long long;

const int N = 3e5 + 10;

int n, s;
LL st[N], sc[N];
LL f[N];
int Q[N], hh, tt;

int main()
{
    scanf("%d%d", &n, &s);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d%d", &st[i], &sc[i]);
        st[i] += st[i - 1], sc[i] += sc[i - 1];
    }

    for (int i = 1; i <= n; i++)
    {
        while (hh < tt && f[Q[hh + 1]] - f[Q[hh]] <= (st[i] + s) * (sc[Q[hh + 1]] - sc[Q[hh]])) hh++;
        int j = Q[hh];
        f[i] = f[j] + st[i] * (sc[i] - sc[j]) + s * (sc[n] - sc[j]);
        while (hh < tt && (f[Q[tt]] - f[Q[tt - 1]]) * (sc[i] - sc[Q[tt]]) >= (f[i] - f[Q[tt]]) * (sc[Q[tt]] - sc[Q[tt - 1]])) tt--;
        Q[++tt] = i;
    }

    printf("%lld", f[n]);

    return 0;
}
```

### 任务安排3

题目：https://www.acwing.com/problem/content/description/304/

**题解：**

https://www.acwing.com/problem/content/discussion/content/799/

https://www.acwing.com/solution/content/68118/

```c++
#include <iostream>

using namespace std;
using LL = long long;

const int N = 3e5 + 10;

int n, s;
LL st[N], sc[N];
LL f[N];
int Q[N], hh, tt;

int main()
{
    scanf("%d%d", &n, &s);
    for (int i = 1; i <= n; i++)
    {
        scanf("%lld%lld", &st[i], &sc[i]);
        st[i] += st[i - 1], sc[i] += sc[i - 1];
    }

    for (int i = 1; i <= n; i++)
    {
        int l = hh, r = tt;
        while (l < r)
        {
            int mid = l + r >> 1;
            if (f[Q[mid + 1]] - f[Q[mid]] > (st[i] + s) * (sc[Q[mid + 1]] - sc[Q[mid]]))
                r = mid;
            else l = mid + 1;
        }
        int j = Q[l];
        f[i] = f[j] + st[i] * (sc[i] - sc[j]) + s * (sc[n] - sc[j]);
        while (hh < tt && __int128(f[Q[tt]] - f[Q[tt - 1]]) * (sc[i] - sc[Q[tt]]) >= __int128(f[i] - f[Q[tt]]) * (sc[Q[tt]] - sc[Q[tt - 1]]))
            tt--;
        Q[++tt] = i;
    }

    printf("%lld\n", f[n]);

    return 0;
}
```

### 运输小猫

题目：https://www.acwing.com/problem/content/description/305/

题解：https://www.acwing.com/solution/content/68473/

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;
using LL = long long;

const int N = 1e5 + 10, M = 110;

int n, m, p;
LL sd[N];
LL et[N], h, t;
LL ps[N];
LL f[M][N];
int Q[N], hh, tt;

LL y(int i, int k)
{
    return f[i - 1][k] + ps[k];
}

int main()
{
    scanf("%d%d%d", &n, &m, &p);
    for (int i = 2; i <= n; i++)
    {
        scanf("%d", &sd[i]);
        sd[i] += sd[i - 1];
    }
    for (int i = 1; i <= m; i++)
    {
        scanf("%d%d", &h, &t);
        et[i] = t - sd[h];
    }

    sort(et + 1, et + 1 + m);
    for (int i = 1; i <= m; i++) ps[i] = et[i] + ps[i - 1];

    memset(f, 0x3f, sizeof f);
    for (int i = 0; i <= p; i++) f[i][0] = 0;
    for (int i = 1; i <= p; i++)
    {
        hh = tt = Q[0] = 0;
        for (int j = 1; j <= m; j++)
        {
            while (hh < tt && y(i, Q[hh + 1]) - y(i, Q[hh]) <= (Q[hh + 1] - Q[hh]) * et[j]) 
                hh++;
            int k = Q[hh];
            f[i][j] = j * et[j] - ps[j] + f[i - 1][k] - k * et[j] + ps[k];
            while (hh < tt && (y(i, Q[tt]) - y(i, Q[tt - 1])) * (j - Q[tt]) >= (y(i, j) - y(i, Q[tt])) * (Q[tt] - Q[tt - 1]))
                tt--;
            Q[++tt] = j;
        }
    }

    printf("%lld\n", f[p][m]);

    return 0;
}
```

**滚动数组优化：**

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;
using LL = long long;

const int N = 1e5 + 10, M = 110;

int n, m, p;
LL sd[N];
LL et[N], h, t;
LL ps[N];
LL f[2][N];
int Q[N], hh, tt;

LL y(int i, int k)
{
    return f[i - 1 & 1][k] + ps[k];
}

int main()
{
    scanf("%d%d%d", &n, &m, &p);
    for (int i = 2; i <= n; i++)
    {
        scanf("%d", &sd[i]);
        sd[i] += sd[i - 1];
    }
    for (int i = 1; i <= m; i++)
    {
        scanf("%d%d", &h, &t);
        et[i] = t - sd[h];
    }

    sort(et + 1, et + 1 + m);
    for (int i = 1; i <= m; i++) ps[i] = et[i] + ps[i - 1];

    memset(f, 0x3f, sizeof f);
    f[0][0] = f[1][0] = 0;
    for (int i = 1; i <= p; i++)
    {
        hh = tt = Q[0] = 0;
        for (int j = 1; j <= m; j++)
        {
            while (hh < tt && y(i, Q[hh + 1]) - y(i, Q[hh]) <= (Q[hh + 1] - Q[hh]) * et[j]) 
                hh++;
            int k = Q[hh];
            f[i & 1][j] = j * et[j] - ps[j] + f[i - 1 & 1][k] - k * et[j] + ps[k];
            while (hh < tt && (y(i, Q[tt]) - y(i, Q[tt - 1])) * (j - Q[tt]) >= (y(i, j) - y(i, Q[tt])) * (Q[tt] - Q[tt - 1]))
                tt--;
            Q[++tt] = j;
        }
    }

    printf("%lld\n", f[p & 1][m]);

    return 0;
}
```

