# 数据结构

## 链表

### 单链表

**模板：**

`L[0].n`是头指针，指向第一个结点的下标。

```c++
struct ListNode
{
    int v, n;
} L[N];
int idx;

void ins(int k, int x)
{
    L[++idx] = {x, L[k].n}, L[k].n = idx;
}

void del(int k)
{
    L[k].n = L[L[k].n].n;
}
```



题目：[单链表](https://www.acwing.com/problem/content/828/)

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

const int N = 1e5 + 10;

int n;

struct ListNode
{
    int v, n;
} L[N];
int idx;

void ins(int k, int x)
{
    L[++idx] = {x, L[k].n}, L[k].n = idx;
}

void del(int k)
{
    L[k].n = L[L[k].n].n;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    while (n--)
    {
        char op; cin >> op;
        if (op == 'H')
        {
            int x; cin >> x;
            ins(0, x);
        }
        else if (op == 'D')
        {
            int k; cin >> k;
            del(k);
        }
        else
        {
            int k, x; cin >> k >> x;
            ins(k, x);
        }
    }

    for (int p = L[0].n; p; p = L[p].n) cout << L[p].v << ' ';
    cout << '\n';

    return 0;
}
```

### 双链表

**模板：**

`L[0].n`是头指针，`L[0].p`是尾指针。

```c++
struct ListNode
{
    int v, p, n;
} L[N];
int idx;

void insL(int k, int x)
{
    L[++idx] = {x, L[k].p, k}, L[L[k].p].n = idx, L[k].p = idx;
}

void insR(int k, int x)
{
    L[++idx] = {x, k, L[k].n}, L[L[k].n].p = idx, L[k].n = idx;
}

void del(int k)
{
    L[L[k].p].n = L[k].n, L[L[k].n].p = L[k].p;
}
```



题目：[双链表](https://www.acwing.com/problem/content/description/829/)

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

const int N = 1e5 + 5;

int n;
struct ListNode
{
    int v, p, n;
} L[N];
int idx;

void insL(int k, int x)
{
    L[++idx] = {x, L[k].p, k}, L[L[k].p].n = idx, L[k].p = idx;
}

void insR(int k, int x)
{
    L[++idx] = {x, k, L[k].n}, L[L[k].n].p = idx, L[k].n = idx;
}

void del(int k)
{
    L[L[k].p].n = L[k].n, L[L[k].n].p = L[k].p;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    while (n--)
    {
        std::string op; cin >> op;
        if (op == "L")
        {
            int x; cin >> x;
            insR(0, x);
        }
        else if (op == "R")
        {
            int x; cin >> x;
            insL(0, x);
        }
        else if (op == "D")
        {
            int k; cin >> k;
            del(k);
        }
        else if (op == "IL")
        {
            int k, x; cin >> k >> x;
            insL(k, x);
        }
        else
        {
            int k, x; cin >> k >> x;
            insR(k, x);
        }
    }

    for (int p = L[0].n; p; p = L[p].n) cout << L[p].v << ' ';
    cout << '\n';

    return 0;
}
```

## 栈

算法竞赛中更多地采用数组模拟栈

### 模板题：模拟栈

[模拟栈](https://www.acwing.com/problem/content/830/)

```c++
#include <iostream>

using namespace std;

const int N = 1e5 + 10;

int m;
int stk[N], tt;

int main()
{
    scanf( "%d", &m );
    
    while ( m-- )
    {
        string op; cin >> op;
        if ( op == "push" )
        {
            int x; scanf( "%d", &x );
            stk[++tt] = x;
        }
        else if ( op == "pop" ) --tt;
        else if ( op == "empty" ) 
        {
            if ( tt == 0 ) puts( "YES" );
            else puts( "NO" );
        }
        else printf( "%d\n", stk[tt] );
    }
    
    return 0;
}
```

### 单调栈

尽管模板题是寻找左边最近最小的数，但也可以是右边或者最大，稍微修改代码都可以实现。

**模板题：**

[单调栈](https://www.acwing.com/problem/content/832/)

```c++
#include <iostream>

using namespace std;

const int N = 1e5 + 10;

int n, arr[N];
int stk[N], tt;

int main()
{
    scanf( "%d", &n );
    for ( int i = 1; i <= n; i++ ) scanf( "%d", arr + i );
    
    for ( int i = 1; i <= n; i++ )
    {
        while ( tt && arr[stk[tt]] >= arr[i] ) tt--;
        
        if ( tt ) printf( "%d ", arr[stk[tt]] );
        else printf( "-1 " );
        
        stk[++tt] = i;
    }
    
    return 0;
}
```

1. 在本题的测试中，如果使用`cin, cout`，`ios::sync_with_stdio(false)`并没有提高多少速度，添加了`cin.tie(0)`可以明显提高速度。

2. 算法的时间复杂度为$O(n)$，因为每个数至多进出栈一次。

### 习题：表达式求值

[表达式求值](https://www.acwing.com/problem/content/3305/)

**STL**

```c++
#include <iostream>
#include <stack>
#include <unordered_map>

using namespace std;

string expr;
unordered_map<char, int> priority;
stack<int> optr;
stack<char> opnd;

void calc()
{
    int b = optr.top(); optr.pop();
    int a = optr.top(); optr.pop();
    char op = opnd.top(); opnd.pop();
    switch( op )
    {
        case '+': optr.push( a + b ); break;
        case '-': optr.push( a - b ); break;
        case '*': optr.push( a * b ); break;
        case '/': optr.push( a / b ); break;
    }
}

int main()
{
    priority = { { '(', 0 }, { '+', 1 }, { '-', 1 }, { '*', 2 }, { '/', 2 } }; 
    
    cin >> expr;
    
    for ( int i = 0; i < expr.size(); i++ )
    {
        if ( expr[i] == '(' ) opnd.push( '(' );
        else if ( expr[i] == ')' )
        {
            while ( opnd.top() != '(' ) calc();
            opnd.pop();
        }
        else if ( isdigit( expr[i] ) )
        {
			int x = 0, j = i;
			while ( j < expr.size() && isdigit( expr[j] ) )
			{
			    x = x * 10 + expr[j] - '0';
			    j++;
			}
			optr.push(x);
			i = j - 1; // 关键步骤
        }
        else
        {
            while ( opnd.size() && priority[expr[i]] <= priority[opnd.top()] ) calc();
            opnd.push( expr[i] );
        }
    }
    while ( opnd.size() ) calc();
    
    printf( "%d\n", optr.top() );
    
    return 0;
}
```

1. 可以添加幂运算，幂运算的优先级最高

**手写栈：**

```c++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 1e5 + 10;

char expr[N];
char op[N]; int opt;
int num[N], numt;

int pr(char ch)
{
	switch (ch)
	{
	case '+': return 1;
	case '-': return 1;
	case '*': return 2;
	case '/': return 2;
	}
}

void eval()
{
	auto b = num[numt--], a = num[numt--];
	auto ch = op[opt--];
	switch (ch)
	{
	case '+': num[++numt] = a + b; break;
	case '-': num[++numt] = a - b; break;
	case '*': num[++numt] = a * b; break;
	case '/': num[++numt] = a / b; break;
	}
}

int main()
{
	scanf("%s", expr);
	int len = strlen(expr);
	for (int i = 0; i < len; i++)
	{
		auto ch = expr[i];
		if (isdigit(ch))
		{
			int x = 0, j = i;
			while (j < len && isdigit(expr[j])) x = x * 10 + expr[j++] - '0';
			num[++numt] = x;
			i = j - 1;
		}
		else if (ch == '(') op[++opt] = '(';
		else if (ch == ')')
		{
			while (op[opt] != '(') eval();
			opt--; // 弹出'('
		}
		else // ch是运算符
		{
			while (opt && op[opt] != '(' && pr(op[opt]) >= pr(ch)) eval();
			op[++opt] = ch;
		}
	}
	while (opt) eval();
	printf("%d", num[numt]);
}
```

## 队列

**模板题：**

[模拟队列](https://www.acwing.com/problem/content/831/)

```c++
#include <iostream>
#include <cstring>

using namespace std;

const int N = 1e5 + 10;

int m;
int q[N], hh, tt = -1;

int main()
{
    scanf( "%d", &m );
    
    while ( m-- )
    {
        char op[10]; scanf( "%s", op );
        if ( !strcmp( op, "push" ) )
        {
            int x; scanf( "%d", &x );
            q[++tt] = x;
        }
        else if ( !strcmp( op, "pop" ) ) hh++;
        else if ( !strcmp( op, "empty" ) )
        {
            if ( hh <= tt ) puts( "NO" );
            else puts( "YES" );
        }
        else printf( "%d\n", q[hh] );
    }
    
    return 0;
}
```

### 单调队列

可以用于寻找滑动窗口内的最大值和最小值

**模板题：**

[滑动窗口](https://www.acwing.com/problem/content/156/)

**手写**

```c++
#include <iostream>

using namespace std;

const int N = 1e6 + 10;

int n, m;
int arr[N];
int q[N], hh, tt = -1;

int main()
{
    scanf( "%d%d", &n, &m );
    for ( int i = 1; i <= n; i++ ) scanf( "%d", arr + i );
    
    for ( int i = 1; i <= n; i++ )
    {
        while ( hh <= tt && arr[q[tt]] >= arr[i] ) tt--;
        q[++tt] = i;
        if ( i > m && q[hh] == i - m ) hh++;
        if ( i >= m ) printf( "%d ", arr[q[hh]] );
    }
    puts( "" );
    
    hh = 0, tt = -1;
    for ( int i = 1; i <= n; i++ )
    {
        while ( hh <= tt && arr[q[tt]] <= arr[i] ) tt--;
        q[++tt] = i;
        if ( i > m && q[hh] == i - m ) hh++;
        if ( i >= m ) printf( "%d ", arr[q[hh]] );
    }
    puts( "" );
    
    return 0;
}
```

1. 这个题目下标从1开始有好处，这个时候下标的意义更明确

**STL**

```c++
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

int n, m;
vector<int> arr;
deque<int> dq;

int main()
{
    scanf( "%d%d", &n, &m );
    arr.resize( n + 1 );
    for ( int i = 1; i <= n; i++ ) scanf( "%d", &arr[i] );
    
    for ( int i = 1; i <= n; i++ )
    {
        while ( dq.size() && arr[dq.back()] >= arr[i] ) dq.pop_back();
        dq.push_back( i );
        if ( i > m && dq.front() == i - m ) dq.pop_front();
        if ( i >= m ) printf( "%d ", arr[dq.front()] );
    }
    puts( "" );
    
    dq.clear();
    for ( int i = 1; i <= n; i++ )
    {
        while ( dq.size() && arr[dq.back()] <= arr[i] ) dq.pop_back();
        dq.push_back( i );
        if ( i > m && dq.front() == i - m ) dq.pop_front();
        if ( i >= m ) printf( "%d ", arr[dq.front()] );
    }
    puts( "" );
    
    return 0;
}
```

1. 相比手写队列stl慢个一倍左右。

## KMP

**模板题：**

[KMP字符串](https://www.acwing.com/problem/content/833/)

```c++
#include <iostream>
#include <vector>

using namespace std;

const int N = 1e5 + 10, M = 1e6 + 10;

int n, m;
char p[N], s[M]; // 注意p和s的最大长度不同

vector<int> get_next()
{
    vector<int> next( n + 1 );
    for ( int i = 2, j = 0; i <= n; i++ )
    {
        while ( j && p[i] != p[j + 1] ) j = next[j];
        if ( p[i] == p[j + 1] ) j++;
        next[i] = j;
    }
    return next;
}

int main()
{
    scanf( "%d%s", &n, p + 1 );
    scanf( "%d%s", &m, s + 1 );
    
    auto next = get_next();
    for ( int i = 1, j = 0; i <= m; i++ )
    {
        while ( j && s[i] != p[j + 1] ) j = next[j];
        if ( s[i] == p[j + 1] ) j++;
        if ( j == n )
        {
            printf( "%d ", i - n ); // 实际上是i - n + 1 - 1，题干的下标从0开始
            j = next[j];
        }
    }
    
    return 0;
}
```

1. 有一些kmp模板的next数组含义有些不同。关键在于每一次循环比较的是`s[i]`与`p[j+1]`，有一些模板比较的是`s[i]`与`p[j]`，这就导致了`next`数组的含义不同。

2. 本题很特别的是要找出所有的出现位置，如果采用`s[i]`和`p[j]`比较的方法，在找到一个之后，怎么去找下一个的处理会麻烦很多。

## Trie

### 模板题：Trie字符串统计

[Trie字符串统计](https://www.acwing.com/problem/content/837/)

```c++
#include <iostream>

using namespace std;

const int N = 1e5 + 10;

int n;
int son[N][26], cnt[N], idx;

void insert( char str[] )
{
    int p = 0;
    for ( int i = 0; str[i]; i++ )
    {
        int u = str[i] - 'a';
        if ( son[p][u] == 0 ) son[p][u] = ++idx;
        p = son[p][u];
    }
    cnt[p]++;
}

int query( char str[] )
{
    int p = 0;
    for ( int i = 0; str[i]; i++ )
    {
        int u = str[i] - 'a';
        if ( son[p][u] == 0 ) return 0;
        p = son[p][u];
    }
    return cnt[p];
}

int main()
{
    scanf( "%d", &n );
    
    char op[2], str[N];
    while ( n-- )
    {
        scanf( "%s%s", op, str );
        if ( op[0] == 'I' ) insert( str );
        else printf( "%d\n", query( str ) );
    }
    
    return 0;
}
```

1. 不要用`getchar()`或者`scanf("%c", &op)`读入。`getchar`会读入回车或空格，`scanf("%s")`会忽略回车和空格。

2. 计数器`cnt`总是以孩子节点的层数作为字符串的标记计数。

3. 由于插入的次数远远达不到1e5次，所以还有节省空间的余地。

### 习题：最大异或对

[最大异或对](https://www.acwing.com/problem/content/145/)

```c++
#include <iostream>

using namespace std;

const int N = 1e5 + 10, M = 31 * N;

int son[M][2], idx; // 字典树
int n;

void insert(int x) // 从高位开始插入
{
	int p = 0;
	for (int i = 30; i >= 0; i--)
	{
		int u = x >> i & 1;
		if (!son[p][u]) son[p][u] = ++idx;
		p = son[p][u];
	}
}

int query(int x)
{
	int p = 0, res = 0;
	for (int i = 30; i >= 0; i--)
	{
		int u = x >> i & 1, _u = 1 ^ u;
		if (son[p][_u])
		{
			p = son[p][_u];
			res += 1 << i;
		}
		else p = son[p][u];
	}
	return res;
}

int main()
{
	scanf("%d", &n);
	int res = 0;
	while (n--) // 先插入再查询，可以避免第一个数的特判
	{
		int x; scanf("%d", &x);
		insert(x);
		res = max(res, query(x));
	}
	printf("%d", res);
	return 0;
}
```

## 并查集

### 朴素并查集

**模板题：**

[合并集合](https://www.acwing.com/problem/content/838/)

```c++
#include <stdio.h>

using namespace std;

const int N = 1e5 + 10;

int n, m, p[N];

int find(int x)
{
    if (x != p[x]) p[x] = find(p[x]);
    return p[x];
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) p[i] = i;
    while (m--)
    {
        char op[2];
        int a, b;
        scanf("%s%d%d", op, &a, &b);
        if (op[0] == 'M') p[find(a)] = find(b);
        else
        {
            if (find(a) == find(b)) puts("Yes");
            else puts("No");
        }
    }
    return 0;
}
```

1. `find`操作含有路径压缩的优化，在每次查询的时候都会把查询过的节点的父节点直接变为祖宗节点。

### 维护size的并查集

**模板题：**

[连通块中点的数量](https://www.acwing.com/problem/content/839/)

```c++
#include <stdio.h>
#include <iostream>
using namespace std;

const int N = 1e5 + 10;

int n, m;
int p[N], cnt[N];

int find(int x)
{
    if (x != p[x]) p[x] = find(p[x]);
    return p[x];
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
    {
        p[i] = i;
        cnt[i] = 1;
    }

    while (m--)
    {
        string op; cin >> op;
        int a, b;
        if (op == "C")
        {
            scanf("%d%d", &a, &b);
            a = find(a), b = find(b);
            if (a != b)
            {
                cnt[b] += cnt[a];
                p[a] = p[b];
            }
        }
        else if (op == "Q1")
        {
            scanf("%d%d", &a, &b);
            if (find(a) == find(b)) puts("Yes");
            else puts("No");
        }
        else
        {
            scanf("%d", &a);
            printf("%d\n", cnt[find(a)]);
        }
    }
    return 0;
}
```

1. 不能定位为`int size[N];`因为`size`已经被使用过了。

### 习题：食物链

[食物链](https://www.acwing.com/problem/content/242/)

```c++
#include <iostream>

using namespace std;

const int N = 5e4 + 10;

int p[N], d[N];
int n, k;

int find(int x)
{
	if (x != p[x])
	{
		int tmp = p[x];
		p[x] = find(p[x]);
		d[x] += d[tmp];
	}
	return p[x];
}

int main()
{
	scanf("%d%d", &n, &k);
	for (int i = 1; i <= n; i++) p[i] = i;
	int res = 0;
	while (k--)
	{
		int t, x, y; scanf("%d%d%d", &t, &x, &y);
		if (x > n || y > n) res++;
		else
		{
			int px = find(x), py = find(y);
			if (t == 1) // 当x是y的子节点的时，说明x吃y
			{
				if (px == py && (d[x] - d[y]) % 3) res++;
				else if (px != py)
				{
					p[px] = py;
					d[px] = d[y] - d[x];
				}
			}
			else // t == 2
			{
				if (px == py && (d[x] - 1 - d[y]) % 3) res++;
				else if (px != py)
				{
					p[px] = py;
					d[px] = d[y] + 1 - d[x];
				}
			}
		}
	}
	printf("%d\n", res);
	return 0;
}
```

1. 本题的一个难点在于维护数组`d`。`d[x]`表示节点x到父节点的距离，在完成路径压缩后，就变成了到根节点的距离。具体可以参考[题解](https://www.acwing.com/solution/content/15938/)。

## 堆

堆的大部分操作都可以用以下的模板来完成

**模板：**

```c++
void down(int u)
{
    int mi = u, l = 2 * u, r = l + 1;
    if (l <= cnt && h[l] < h[mi]) mi = l;
    if (r <= cnt && h[r] < h[mi]) mi = r;
    if (mi != u)
    {
        swap(h[mi], h[u]);
        down(mi);
    }
}

void up(int u)
{
    int p = u / 2;
    while (p && h[u] < h[p])
    {
        swap(h[u], h[p]);
        u = p, p /= 2;
    }
}
```

### 堆排序

**模板题：**

[堆排序](https://www.acwing.com/problem/content/description/840/)

```c++
#include <iostream>
#include <stdio.h>

using namespace std;

const int N = 1e5 + 10;

int n, m;
int h[N], cnt; // 小根堆

void down(int u)
{
    int mi = u, l = 2 * u, r = l + 1;
    if (l <= cnt && h[l] < h[mi]) mi = l;
    if (r <= cnt && h[r] < h[mi]) mi = r;
    if (mi != u)
    {
        swap(h[mi], h[u]);
        down(mi);
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%d", h + i);
    cnt = n;
    for (int i = n / 2; i >= 1; i--) down(i); // O(n)建堆
    while (m--)
    {
        printf("%d ", h[1]);
        h[1] = h[cnt];
        cnt--;
        down(1);
    }
    return 0;
}
```

### 模板题：模拟堆

[模拟堆](https://www.acwing.com/problem/content/841/)

```c++
#include <stdio.h>
#include <string.h>
#include <iostream>
using namespace std;

const int N = 1e5 + 10;

int h[N], cnt; // 小根堆
int hp[N], ph[N]; // hp表示从堆的下标到插入顺序的映射，ph相反

void heap_swap(int i, int j) // 下面三个swap顺序随意
{
    swap(hp[i], hp[j]);
    swap(ph[hp[i]], ph[hp[j]]);
    swap(h[i], h[j]);
}

void up(int u)
{
    int p = u / 2;
    while (p && h[u] < h[p])
    {
        heap_swap(u, p);
        u = p, p /= 2;
    }
}

void down(int u)
{
    int mi = u, l = 2 * u, r = l + 1;
    if (l <= cnt && h[l] < h[mi]) mi = l;
    if (r <= cnt && h[r] < h[mi]) mi = r;
    if (mi != u)
    {
        heap_swap(mi, u);
        down(mi);
    }
}

int main()
{
    int n; scanf("%d", &n);
    int idx = 0; // 表示插入顺序
    char op[5]; int k, x;
    while (n--)
    {
        scanf("%s", op);
        if (!strcmp(op, "I"))
        {
            scanf("%d", &x);
            h[++cnt] = x;
            hp[cnt] = ++idx, ph[idx] = cnt;
            up(cnt);
        }
        else if (!strcmp(op, "PM"))
        {
            printf("%d\n", h[1]);
        }
        else if (!strcmp(op, "DM"))
        {
            heap_swap(1, cnt);
            cnt--;
            down(1);
        }
        else if (!strcmp(op, "D"))
        {
            scanf("%d", &k);
            k = ph[k];
            heap_swap(k, cnt);
            cnt--;
            down(k), up(k);
        }
        else // op = "C" 
        {
            scanf("%d%d", &k, &x);
            k = ph[k];
            h[k] = x;
            up(k), down(k);
        }
    }
    return 0;
}
```

1. 本题最难的在于维护两个数组`hp[N], ph[N]`

## 哈希表

**模板题：**

[模拟散列表](https://www.acwing.com/problem/content/842/)

### 拉链法

```c++
#include <iostream>
#include <cstring>

using namespace std;

const int N = 1e5 + 3; // 大于1e5的最小素数

int h[N]; // 哈希表，拉链法，h[k]存储第k个链表的头指针
int e[N + 1], ne[N + 1], idx = 1; // 多个单链表，0表示空指针

void insert(int x) // 头插法
{
    int k = (x % N + N) % N; 
    e[idx] = x;
    ne[idx] = h[k];
    h[k] = idx;
    idx++;
}

bool find(int x)
{
    int k = (x % N + N) % N;
    for (int p = h[k]; p; p = ne[p])
    {
        if (x == e[p]) return true;
    }
    return false;
}


int main()
{
    int n; scanf("%d", &n);
    char op[2]; int x;
    while (n--)
    {
        scanf("%s%d", op, &x);
        if (op[0] == 'I')
        {
            insert(x);
        }
        else
        {
            if (find(x)) puts("Yes");
            else puts("No");
        }
    }
    return 0;
}
```

### 开放定址法

```c++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 2e5 + 3; // 一般选取输入规模的两到三倍，也要选质数
const int null = 0x3f3f3f3f; // null大于10^9

int h[N];
inline void init() // 使得h中所有值为null
{
    memset(h, 0x3f, sizeof h);
}

// 如果已经存储了x，返回x的位置；如果没有存储x，则返回可以存储的位置
int find(int x) 
{
    int k = (x % N + N) % N;
    while (h[k] != null && h[k] != x) k = (k + 1) % N;
    return k;
}

int main()
{
    init();
    int n; scanf("%d", &n);
    char op[2]; int x;
    while (n--)
    {
        scanf("%s%d", op, &x);
        if (op[0] == 'I')
        {
            h[find(x)] = x;
        }
        else
        {
            if (h[find(x)] != null) puts("Yes");
            else puts("No");
        }
    }
    return 0;
}
```

### 字符串哈希

核心思想是把字符串看成是P进制数

**模板题：**

[字符串哈希](https://www.acwing.com/problem/content/843/)

```c++
#include <iostream>

using namespace std;

typedef unsigned long long ULL; // 相当于字符串哈希值mod 2^64

const int N = 1e5 + 10, P = 131; // p一般取131或13331

char str[N]; // str从str[1]开始存储
ULL h[N], p[N]; // h[i]表示str[1]*P^{i-1}+str[2]*P^{i-2}...+str[i]*P^0，p[i]=P^i
int n, m;

inline void init() // 初始化p和h
{
    p[0] = 1;
    for (int i = 1; i <= n; i++)
    {
        p[i] = p[i - 1] * P;
        h[i] = h[i - 1] * P + str[i];
    }
}

inline ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}

int main()
{
    scanf("%d%d%s", &n, &m, str + 1);
    init();
    while (m--)
    {
        int l1, r1, l2, r2;
        scanf("%d%d%d%d", &l1, &r1, &l2, &r2);
        if (get(l1, r1) == get(l2, r2)) puts("Yes");
        else puts("No");
    }
    return 0;
}
```

## C++ STL 简介

```c++
vector, 变长数组，倍增的思想
    vector(n, elem) 构造n个elem
    vector(n) 构造n个0
    size()  返回元素个数
    empty()  返回是否为空
    clear()  清空
    front()/back()
    push_back()/pop_back()
    begin()/end()
    [] 随机存取
    支持比较运算，按字典序

pair<int, int>
    first, 第一个元素
    second, 第二个元素
    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）
    p=make_pair(10, "yxc")/p={10, "yxc"} 构造pair

string，字符串
    size()/length()  返回字符串长度
    empty()
    clear()
    substr(起始下标，(子串长度))  返回子串
    c_str()  返回字符串所在字符数组的起始地址
    +=/append() 拼接字符串活字符

queue, 队列
    size()
    empty()
    push()  向队尾插入一个元素
    front()  返回队头元素
    back()  返回队尾元素
    pop()  弹出队头元素
    没有clear()

priority_queue, 优先队列，默认是大根堆
    size()
    empty()
    push()  插入一个元素
    top()  返回堆顶元素
    pop()  弹出堆顶元素
    priority_queue<int, vector<int>, greater<int>> 定义成小根堆

stack, 栈
    size()
    empty()
    push()  向栈顶插入一个元素
    top()  返回栈顶元素
    pop()  弹出栈顶元素

deque, 双端队列
    size()
    empty()
    clear()
    front()/back()
    push_back()/pop_back()
    push_front()/pop_front()
    begin()/end()
    []

set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列
    size()
    empty()
    clear()
    begin()/end()
    ++, -- 返回前驱和后继，时间复杂度 O(logn)

    set/multiset
        insert()  插入一个数
        find()  查找一个数
        count()  返回某一个数的个数
        erase()
            (1) 输入是一个数x，删除所有x   O(k + logn)
            (2) 输入一个迭代器，删除这个迭代器
        lower_bound()/upper_bound()
            lower_bound(x)  返回>=x的最小的数的迭代器
            upper_bound(x)  返回>x的最小的数的迭代器
    map/multimap
        insert()  插入的数是一个pair
        erase()  输入的参数是pair或者迭代器
        find()
        []  注意multimap不支持此操作。 时间复杂度是 O(logn)
        lower_bound()/upper_bound()

unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表
    和上面类似，增删改查的时间复杂度是 O(1)
    不支持 lower_bound()/upper_bound()， 迭代器的++，--

bitset, 圧位
    bitset<10000> s;
    ~, &, |, ^
    >>, <<
    ==, !=
    []

    count()  返回有多少个1

    any()  判断是否至少有一个1
    none()  判断是否全为0

    set()  把所有位置成1
    set(k, v)  将第k位变成v
    reset()  把所有位变成0
    flip()  等价于~
    flip(k) 把第k位取反
```

