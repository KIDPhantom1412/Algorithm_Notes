# 面试经典150题

[面试经典150题](https://leetcode.cn/studyplan/top-interview-150/)

## 数组/字符串

### 合并两个有序数组

题目：[合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/)

**题解：**

https://leetcode.cn/problems/merge-sorted-array/solutions/666608/he-bing-liang-ge-you-xu-shu-zu-by-leetco-rrb0/?envType=study-plan-v2&envId=top-interview-150

**双指针+临时数组：**

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        vector<int> tmp(m + n);
        int i = 0, j = 0, k = 0;
        while (i < m && j < n)
        {
            tmp[k++] = nums1[i] < nums2[j] ? nums1[i++] : nums2[j++];
        }
        while (i < m) tmp[k++] = nums1[i++];
        while (j < n) tmp[k++] = nums2[j++];
        for (i = 0; i < m + n; i++) nums1[i] = tmp[i]; 
    }
};
```

**逆向双指针：**

逆向双指针的含义是，从大到小的顺序用双指针去寻找对应元素，并从`nums1`的结尾开始往前放数字。可以证明，`nums1`中的元素永远不会被覆盖。

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int i = m - 1, j = n - 1, k = m + n - 1;
        while (i >= 0 && j >= 0)
        {
            nums1[k--] = nums1[i] > nums2[j] ? nums1[i--] : nums2[j--];
        }
        while (i >= 0) nums1[k--] = nums1[i--];
        while (j >= 0) nums1[k--] = nums2[j--];
    }
};
```

```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        i, j, k = m - 1, n - 1, m + n - 1
        while i >= 0 and j >= 0:
            if nums1[i] > nums2[j]:
                nums1[k] = nums1[i]
                i -= 1
            else:
                nums1[k] = nums2[j]
                j -= 1
            k -= 1
        while i >= 0:
            nums1[k] = nums1[i]
            i -= 1
            k -= 1
        while j >= 0:
            nums1[k] = nums2[j]
            j -= 1
            k -= 1
```

### 移除元素

题目：[移除元素](https://leetcode.cn/problems/remove-element/)

**对撞双指针：**

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int i = 0, j = nums.size();
        while (i < j)
        {
            if (nums[i] == val) swap(nums[i], nums[--j]);
            else i++;
        }
        return j;
    }
};
```

```c++
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        i, j = 0, len(nums)
        while i < j:
            if nums[i] == val:
                j -= 1
                nums[i] = nums[j]
            else:
                i += 1
        return j
```

### 删除有序数组中的重复项

题目：[删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

**快慢指针：**

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        int i = 1, j = 1;
        while (j < n)
        {
            if (nums[j] != nums[j - 1]) nums[i++] = nums[j];
            j++;
        }
        return i;
    }
};
```

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        n = len(nums)
        i, j = 1, 1
        while j < n:
            if nums[j - 1] != nums[j]:
                nums[i] = nums[j]
                i += 1
            j += 1
        return i
```

### 删除有序数组中的重复项 II

题目：[删除有序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/)

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        int k = 0, i = 0, j = 0;
        while (j < n)
        {
            while (j < n && nums[i] == nums[j]) j++;
            if (j - i >= 2) nums[k++] = nums[i];
            nums[k++] = nums[i];
            i = j;
        }
        return k;
    }
};
```

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        n = len(nums)
        k, i = 0, 0
        while i < n:
            j = i
            while j < n and nums[i] == nums[j]:
                j += 1
            if j - i >= 2:
                nums[k] = nums[k + 1] = nums[i]
                k += 2
            else:
                nums[k] = nums[i]
                k += 1
            i = j
        return k
```

1. 官方题解很烂，很难懂，而且只能适用于有序数组。我的题解更简单，可以把所有连续的都去重。

### 多数元素

题目：[多数元素](https://leetcode.cn/problems/majority-element/)

**题解：**

https://leetcode.cn/problems/majority-element/solutions/2362000/169-duo-shu-yuan-su-mo-er-tou-piao-qing-ledrh/?envType=study-plan-v2&envId=top-interview-150

**摩尔投票：**

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int cnt = 0, key;
        for (int i = 0; i < nums.size(); i++)
        {
            if (cnt == 0) key = nums[i];
            if (nums[i] == key) cnt++;
            else cnt--;
        }
        return key;
    }
};
```

```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        cnt, key = 0, 0
        for num in nums:
            if cnt == 0:
                key = num
            if key == num:
                cnt += 1
            else:
                cnt -= 1
        return key
```

1. 这个题是老朋友了。

### 轮转数组

题目：[轮转数组](https://leetcode.cn/problems/rotate-array/)

**翻转数组：**

这在408的算法题中考过，也算是老朋友了。这里的不同在于需要事先对$k$做处理。

```c++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        k = k % nums.size();
        reverse(nums.begin(), nums.end());
        reverse(nums.begin(), nums.begin() + k);
        reverse(nums.begin() + k, nums.end());
    }
};
```

```python
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        def reverse(i, j):
            while i < j:
                tmp = nums[i]
                nums[i] = nums[j]
                nums[j] = tmp
                i += 1
                j -= 1
        n = len(nums)
        k %= n
        reverse(0, n - 1)
        reverse(0, k - 1)
        reverse(k, n - 1)
```

**环装替换：**

一种数论做法。[参考](https://leetcode.cn/problems/rotate-array/solutions/551039/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/?envType=study-plan-v2&envId=top-interview-150)。

```c++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k %= n;
        int cnt = gcd(n, k);
        for (int i = 0; i < cnt; i++)
        {
            int cur = i;
            int tmp = nums[cur];
            do
            {
                int next = (cur + k) % n;
                swap(tmp, nums[next]);
                cur = next;
            } while (cur != i);
        }
    }
};
```

### 买卖股票的最佳时机

题目：[买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

**题解：**

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/solutions/1692872/by-jyd-cu90/?envType=study-plan-v2&envId=top-interview-150

**单调栈：**

这个题用单调栈会导致空间上的冗余。

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<int> stk;
        int res = 0;
        for (int p : prices)
        {
            while (!stk.empty() && p < stk.back()) stk.pop_back();
            stk.push_back(p);
            res = max(res, stk.back() - stk.front());
        }
        return res;
    }
};
```

**一次遍历：**

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int cost = 1e9, res = 0;
        for (int price : prices)
        {
            cost = min(cost, price);
            res = max(res, price - cost);
        }
        return res;
    }
};
```

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        cost, res = inf, 0
        for price in prices:
            cost = min(cost, price)
            res = max(res, price - cost)
        return res
```

### 买卖股票的最佳时机 II

题目：[买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

**题解：**

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/solutions/476791/mai-mai-gu-piao-de-zui-jia-shi-ji-ii-by-leetcode-s/?envType=study-plan-v2&envId=top-interview-150

**动态规划：**

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int f[n][2];
        f[0][0] = 0, f[0][1] = -prices[0];
        for (int i = 1; i < n; i++)
        {
            f[i][0] = max(f[i - 1][0], f[i - 1][1] + prices[i]);
            f[i][1] = max(f[i - 1][1], f[i - 1][0] - prices[i]);
        }
        return f[n - 1][0];
    }
};
```

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int f0 = 0, f1 = -prices[0];
        for (int i = 1; i < n; i++)
        {
            int tmp0 = f0;
            f0 = max(f0, f1 + prices[i]);
            f1 = max(f1, tmp0 - prices[i]);
        }
        return f0;
    }
};
```

**贪心：**

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int res = 0;
        for (int i = 1; i < n; i++)
            res += max(0, prices[i] - prices[i - 1]);
        return res;
    }
};
```

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        res = 0
        for i in range(1, n):
            res += max(0, prices[i] - prices[i - 1])
        return res
```

### 跳跃游戏

题目：[跳跃游戏](https://leetcode.cn/problems/jump-game/)

**题解：**

https://leetcode.cn/problems/jump-game/solutions/203549/tiao-yue-you-xi-by-leetcode-solution/?envType=study-plan-v2&envId=top-interview-150

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int n = nums.size();
        int remote = 0;
        for (int i = 0; i < n; i++)
        {
            if (i > remote) return false;
            remote = max(remote, i + nums[i]);
         }
        return remote >= n - 1;
    }
};
```

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        n = len(nums)
        remote = 0
        for i in range(n):
            if i > remote:
                return False
            remote = max(remote, i + nums[i])
        return remote >= n - 1
```

### 跳跃游戏 II

题目：[跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

**题解：**

https://leetcode.cn/problems/jump-game-ii/solutions/36035/45-by-ikaruga/?envType=study-plan-v2&envId=top-interview-150

```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        int n = nums.size();
        int res = 0, end = 0, max_pos = 0;
        for (int i = 0; i < n - 1; i++)
        {
            max_pos = max(max_pos, i + nums[i]);
            if (i == end)
            {
                end = max_pos;
                res++;
            }
        }
        return res;
    }
};
```

### H 指数

题目：[H 指数](https://leetcode.cn/problems/h-index/)

**题解：**

https://leetcode.cn/problems/h-index/solutions/869042/h-zhi-shu-by-leetcode-solution-fnhl/?envType=study-plan-v2&envId=top-interview-150

**排序：**

这个题在于理解判断条件为什么是`citations[i] > h`。可以从两个方面考虑，如果`citations[i] > h`那么此时`h++`所得到的`h`是合法的；如果`citations[i] <= h`那么此时`h++`得到的`h`是不合法的。

```c++
class Solution {
public:
    int hIndex(vector<int>& citations) {
        sort(citations.begin(), citations.end());
        int h = 0, i = citations.size() - 1;
        while (i >= 0 && citations[i] > h)
        {
            h++;
            i--;
        }
        return h;
    }
};
```

**计数：**

我一开始想了一个计数+前缀和的解法，和这个解法有类似之处。但我没有意识到当$h$满足h指数时，所以小于$h$的数也必然满足。所以应该倒序去找满足h指数的$h$。

```c++
class Solution {
public:
    int hIndex(vector<int>& citations) {
        int n = citations.size();
        vector<int> cnt(n + 1);
        for (int i = 0; i < n; i++) 
        {
            if (citations[i] >= n) cnt[n]++;
            else cnt[citations[i]]++;
        }
        int total = 0;
        for (int h = n; h > 0; h--) 
        {
            total += cnt[h];
            if (total >= h) return h;
        }
        return 0;
    }
};
```

**前缀和+二分：**

相比于官方题解进行了一定的优化。

```c++
class Solution {
public:
    int hIndex(vector<int>& citations) {
        int n = citations.size();
        vector<int> s(n + 1);
        for (int c : citations) s[min(c, n)]++;
        for (int i = 1; i <= n; i++) s[i] += s[i - 1];

        int l = 0, r = n;
        while (l < r)
        {
            int mid = l + r + 1 >> 1;
            int cnt = mid == 0 ? s[n] : s[n] - s[mid - 1];
            if (cnt >= mid) l = mid;
            else r = mid - 1;
        }
        return l;
    }
};
```

```python
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        n = len(citations)
        s = [0] * (n + 2)
        for c in citations:
            s[min(c, n)] += 1
        for i in range(1, n + 1):
            s[i] += s[i - 1]
        
        l, r = 0, n
        while l < r:
            mid = (l + r + 1) // 2
            cnt = s[n] - s[mid - 1]
            if cnt >= mid:
                l = mid
            else:
                r = mid - 1
        return l
```

### O(1) 时间插入、删除和获取随机元素

题目：[O(1) 时间插入、删除和获取随机元素](https://leetcode.cn/problems/insert-delete-getrandom-o1/)

**题解：**

https://leetcode.cn/problems/insert-delete-getrandom-o1/solutions/468200/cchang-shu-shi-jian-cha-ru-shan-chu-he-huo-qu-sui-/?envType=study-plan-v2&envId=top-interview-150

要特别注意`remove`函数中最后几行代码的顺序，考虑只有一个元素的情况。

```c++
class RandomizedSet {
private:
	unordered_map<int, int> hash;
	vector<int> arr;
public:
    RandomizedSet() 
	{
		srand((unsigned)time(NULL));
    }
    
    bool insert(int val) 
	{
		if (hash.find(val) != hash.end()) return false;
		
		arr.push_back(val);
		hash[val] = arr.size() - 1;
		return true;
    }
    
    bool remove(int val) 
	{
		auto it = hash.find(val);
		if (it == hash.end()) return false;
		
		int pos = it->second;
		
		// 这几行代码的顺序不能错，考虑只有一个元素的情况
		arr[pos] = arr.back();
		hash[arr[pos]] = pos; 
		arr.pop_back();
		hash.erase(it);
		
		return true;
    }
    
    int getRandom() 
	{
		int pos = rand() % arr.size();
		return arr[pos];
    }
};
```

```python
class RandomizedSet:

    def __init__(self):
        self.arr = []
        self.hash = {}


    def insert(self, val: int) -> bool:
        if val in self.hash:
            return False
        
        self.arr.append(val)
        self.hash[val] = len(self.arr) - 1
        return True


    def remove(self, val: int) -> bool:
        if val not in self.hash:
            return False
        
        pos = self.hash[val]
        self.arr[pos] = self.arr[-1]
        self.hash[self.arr[pos]] = pos
        self.arr.pop()
        del self.hash[val]
        return True


    def getRandom(self) -> int:
        return choice(self.arr)

```

### 除自身以外数组的乘积

题目：[除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

**题解：**

https://leetcode.cn/problems/product-of-array-except-self/solutions/11472/product-of-array-except-self-shang-san-jiao-xia-sa/?envType=study-plan-v2&envId=top-interview-150

```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
		int n = nums.size();
		vector<int> res(n, 1);

		for (int i = 1; i < n; i++)
			res[i] = res[i - 1] * nums[i - 1];

		int tmp = 1;
		for (int i = n - 2; i >= 0; i--)
		{
			tmp *= nums[i + 1];
			res[i] *= tmp;
		}
		
		return res;
    }
};
```

```python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res = [1] * n
        for i in range(1, n):
            res[i] = res[i - 1] * nums[i - 1]
        tmp = 1
        for i in range(n - 2, -1, -1):
            tmp *= nums[i + 1]
            res[i] *= tmp
        return res
```

### 加油站

题目：[加油站](https://leetcode.cn/problems/gas-station/)

**题解：**

https://leetcode.cn/problems/gas-station/solutions/488357/jia-you-zhan-by-leetcode-solution/?envType=study-plan-v2&envId=top-interview-150

```c++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
		int n = gas.size(), start = 0;
		while (start < n)
		{
			int i = start, cnt = 0, tank = 0;
			while (cnt < n)
			{
				tank += gas[i] - cost[i];
				if (tank < 0) break;
				cnt++;
				i = (i + 1) % n;
			}
			if (cnt == n) return start;
			start += cnt + 1;
		}
		return -1;
    }
};
```

### 分发糖果

题目：[分发糖果](https://leetcode.cn/problems/candy/)

**题解：**

https://leetcode.cn/problems/candy/solutions/533150/fen-fa-tang-guo-by-leetcode-solution-f01p/?envType=study-plan-v2&envId=top-interview-150

**两次遍历：**

这个方法的正确性我没有理解，题解也没有讲。我只是手算模拟了一下。

```c++
class Solution {
public:
    int candy(vector<int>& ratings) {
		int n = ratings.size();
		vector<int> left(n, 1);
		for (int i = 1; i < n; i++)
		{
			if (ratings[i] > ratings[i - 1]) 
				left[i] = left[i - 1] + 1;
		}
		int ans = left[n - 1], right = 1;
		for (int i = n - 2; i >= 0; i--)
		{
			if (ratings[i] > ratings[i + 1]) 
				right ++;
			else right = 1;
			ans += max(left[i], right);
		}
		return ans;
    }
};
```

**一次遍历：**

先暂时不用这个解法，因为这个解法的正确性我也不理解。

### 接雨水

题目：[接雨水](https://leetcode.cn/problems/trapping-rain-water/)

**题解：**

https://leetcode.cn/problems/trapping-rain-water/solutions/692342/jie-yu-shui-by-leetcode-solution-tuvc/?envType=study-plan-v2&envId=top-interview-150

**动态规划：**

```c++
class Solution {
public:
	int trap(vector<int>& height) {
		int n = height.size();
		vector<int> left(n), right(n);
		left[0] = height[0], right[n - 1] = height[n - 1];

		for (int i = 1; i < n; i++) 
            left[i] = max(left[i - 1], height[i]);
		for (int i = n - 2; i >= 0; i--) 
            right[i] = max(right[i + 1], height[i]);

		int res = 0;
		for (int i = 0; i < n; i++) 
            res += min(left[i], right[i]) - height[i];

		return res;
	}
};
```

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        n = len(height)
        left, right = [0] * n, [0] * n
        left[0], right[n - 1] = height[0], height[n - 1]
        for i in range(1, n): 
            left[i] = max(left[i - 1], height[i])
        for i in range(n - 2, -1, -1): 
            right[i] = max(right[i + 1], height[i])
        
        res = 0
        for i in range(n): 
            res += min(left[i], right[i]) - height[i]

        return res
```

**单调栈：**

```c++
class Solution {
public:
	int trap(vector<int>& height) {
        int n = height.size();
		stack<int> stk;
        
        int res = 0;
        for (int i = 0; i < n; i++)
        {
            if (stk.empty() || height[stk.top()] >= height[i])
            {
                stk.push(i);
                continue;
            }
            while (stk.size() >= 2 && height[stk.top()] < height[i])
            {
                int top = stk.top(); stk.pop();
                int left = stk.top();
                res += (i - left - 1) * (min(height[i], height[left]) - height[top]);
            }
            if (height[stk.top()] < height[i]) stk.pop();
            stk.push(i);
        }

        return res;
	}
};
```

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        stack<int> stk;

        int res = 0;
        for (int i = 0; i < n; i++)
        {
            while (stk.size() && height[i] > height[stk.top()])
            {
                int top = stk.top(); stk.pop();
                if (stk.empty()) break;
                int left = stk.top();
                int w = i - left - 1;
                int h = min(height[i], height[left]) - height[top];
                res += w * h;
            }
            stk.push(i);
        }

        return res;
    }
};
```

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        n = len(height)
        stk = []

        res = 0
        for i in range(n):
            while stk and height[i] > height[stk[-1]]:
                top = stk.pop()
                if not stk: break
                left = stk[-1]
                w = i - left - 1
                h = min(height[left], height[i]) - height[top]
                res += w * h
            stk.append(i)
        
        return res
```

**双指针：**

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        int l = 0, r = n - 1, l_max = 0, r_max = 0;
        int res = 0;
        while (l < r)
        {
            l_max = max(l_max, height[l]);
            r_max = max(r_max, height[r]);

            if (height[l] < height[r])
            {
                res += l_max - height[l];
                l++;
            }
            else
            {
                res += r_max - height[r];
                r--;
            }
        }

        return res;
    }
};
```

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        n = len(height)
        l, r = 0, n - 1
        l_max, r_max = 0, 0
        res = 0
        while l < r:
            l_max = max(l_max, height[l])
            r_max = max(r_max, height[r])

            if height[l] < height[r]:
                res += l_max - height[l]
                l += 1
            else:
                res += r_max - height[r]
                r -= 1
        
        return res
```

### 罗马数字转整数

题目：[罗马数字转整数](https://leetcode.cn/problems/roman-to-integer/)

**题解：**

https://leetcode.cn/problems/roman-to-integer/solutions/774992/luo-ma-shu-zi-zhuan-zheng-shu-by-leetcod-w55p/?envType=study-plan-v2&envId=top-interview-150

```c++
class Solution {
private:
    unordered_map<char, int> hash = {
        {'I', 1},
        {'V', 5},
        {'X', 10},
        {'L', 50},
        {'C', 100},
        {'D', 500},
        {'M', 1000},
    };
public:
    int romanToInt(string s) {
        int n = s.size();

        int res = 0;
        for (int i = 0; i < n; i++)
        {
            if (i + 1 >= n) res += hash[s[i]];
            else
            {
                int cur = hash[s[i]], nxt = hash[s[i + 1]];
                if (cur >= nxt) res += cur;
                else
                {
                    res += nxt - cur;
                    i++;
                }
            }
        }
        return res;
    }
};
```

### 最后一个单词的长度

题目：[最后一个单词的长度](https://leetcode.cn/problems/length-of-last-word/)

```c++
class Solution
{
public:
    int lengthOfLastWord(string s)
    {
        int n = s.size();
        int r = n - 1;
        while (s[r] == ' ') r--;
        int l = r;
        while (l >= 0 && s[l] != ' ') l--;
        return r - l;
    }
};

```

### 整数转罗马数字

题目：[整数转罗马数字](https://leetcode.cn/problems/integer-to-roman/)

**题解：**

https://leetcode.cn/problems/integer-to-roman/description/?envType=study-plan-v2&envId=top-interview-150

**模拟1：**

非常拙劣的做法，不够优雅。

```c++
#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
	string intToRoman(int num) {
		vector<int> digits(1);
		while (num)
		{
			digits.push_back(num % 10);
			num /= 10;
		}

		string res;
		int n = digits.size();
		for (int i = n - 1; i >= 0; i--)
		{
			if (digits[i] == 4 || digits[i] == 9) // 减法形式
			{
				if (i == 3)
				{
					res += 'C';
					res += digits[i] == 4 ? 'D' : 'M';
				}
				else if (i == 2)
				{
					res += 'X';
					res += digits[i] == 4 ? 'L' : 'C';
				}
				else
				{
					res += 'I';
					res += digits[i] == 4 ? 'V' : 'X';
				}
			}
			else if (digits[i] >= 5)
			{
				if (i == 3) res += 'D';
				else if (i == 2) res += 'L';
				else res += 'V';
				digits[i] -= 5;
				if (digits[i] > 0) i++;
			}
			else // digits[i] in [1, 3]
			{
				char ch;
				if (i == 4) ch = 'M';
				else if (i == 3) ch = 'C';
				else if (i == 2) ch = 'X';
				else ch = 'I';
				for (int j = 0; j < digits[i]; j++) res += ch;
			}
		}

		return res;
	}
};
```

**模拟2：**

这里面的一些语法问题是可以探究的，尤其是对于官方题解的写法。

```c++
#include <iostream>
#include <string>
#include <vector>
using namespace std;

#include <iostream>
#include <string>
#include <vector>
using namespace std;

class Solution {
private:
	vector<pair<int, string>> val_sym =
	{
		{ 1000, "M" },
		{ 900, "CM" },
		{ 500, "D" },
		{ 400, "CD" },
		{ 100, "C" },
		{ 90, "XC" },
		{ 50, "L" },
		{ 40, "XL" },
		{ 10, "X" },
		{ 9, "IX" },
		{ 5, "V" },
		{ 4, "IV" },
		{ 1, "I" }
	};
public:
	string intToRoman(int num)
	{

		string res;
		for (auto& [val, sym] : val_sym)
		{
			while (num >= val)
			{
				res += sym;
				num -= val;
			}
		}
		return res;
	}
};
```

### 最长公共前缀

题目：[最长公共前缀](https://leetcode.cn/problems/longest-common-prefix/)

```c++
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {        
        int n = strs.size(), m = strs[0].size();
        int i = 0;
        for (; i < m; i++)
        {
            char c = strs[0][i];
            for (int j = 1; j < n; j++)
            {
                if (i >= strs[j].size() || c != strs[j][i]) 
                    return strs[0].substr(0, i);
            }
        }
        return strs[0].substr(0, i);
    }
};
```

```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        n, m = len(strs), len(strs[0])
        i = 0
        while i < m:
            c = strs[0][i]
            for j in range(1, n):
                if i >= len(strs[j]) or c != strs[j][i]:
                    return strs[0][:i]
            i += 1
        return strs[0][:i]
```

### 反转字符串中的单词

题目：[反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

```c++
class Solution {
public:
    string reverseWords(string s) {
        string res;
        for (int i = s.size() - 1; i >= 0; i--)
        {
            if (s[i] == ' ') continue;
            int j = i - 1;
            while (j >= 0 && s[j] != ' ') j--;
            res += s.substr(j + 1, i - j);
            res += ' ';
            i = j;
        }
        res.erase(res.size() - 1);
        return res;
    }
};
```

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        res = []
        i = len(s) - 1
        while i >= 0:
            while i >= 0 and s[i] == ' ': i -= 1
            j = i - 1
            while j >= 0 and s[j] != ' ': j -= 1
            if i >= 0: res.append(s[j + 1: i + 1])
            i = j - 1
        return ' '.join(res)
```

### Z 字形变换

题目：[Z 字形变换](https://leetcode.cn/problems/zigzag-conversion/)

```c++
class Solution
{
public:
    string convert(string s, int numRows)
    {
        if (numRows == 1) return s;
        
        vector<string> rows(numRows);
        int idx = 0, step = -1;
        for (char c : s)
        {
            rows[idx] += c;
            if (idx == 0 || idx == numRows - 1)
                step = -step;
            idx += step;
        }

        string res;
        for (string &str : rows) res += str;
        return res;
    }
};
```

### 找出字符串中第一个匹配项的下标

题目：[找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

**KMP：**

```c++
class Solution {
public:

    vector<int> get_next(string p)
    {
        int n = p.size();
        vector<int> next(n);
        next[0] = -1;
        for (int i = 1, j = -1; i < n; i++)
        {
            while (j > -1 && p[i] != p[j + 1]) j = next[j];
            if (p[j + 1] == p[i]) j++;
            next[i] = j;
        }
        return next;
    }

    int strStr(string haystack, string needle) {
        int n = haystack.size(), m = needle.size();
        vector<int> next = get_next(needle);
        for (int i = 0, j = -1; i < n; i++)
        {
            while (j > -1 && haystack[i] != needle[j + 1]) j = next[j];
            if (needle[j + 1] == haystack[i]) j++;
            if (j == m - 1) return i - m + 1;
        }
        return -1;
    }
};
```

### 文本左右对齐

题目：[文本左右对齐](https://leetcode.cn/problems/text-justification/)

```c++
class Solution {
public:
	int maxWidth;

	void adjust(string& s) // 针对除了最后一行的操作
	{
		int n = s.size();
		int space = 0, chars = 1;
		for (int i = 1; i < n; i++)
		{
			if (s[i] == ' ' && s[i - 1] != ' ') space++;
			if (s[i] != ' ') chars++;
		}

		if (space == 0)
		{
			s.resize(maxWidth, ' ');
			return;
		}

		int cnt = maxWidth - chars, tmp = cnt / space;
		cnt -= tmp * space;

		for (int i = 0, j = 0; i < maxWidth; i++)
		{
			if (s[i] == ' ' && s[i - 1] != ' ')
			{
				if (j < cnt) s.insert(i, tmp, ' ');
				else s.insert(i, tmp - 1, ' ');
				j++;
			}
		}
	}

	vector<string> fullJustify(vector<string>& words, int maxWidth) {
		int n = words.size();
		this->maxWidth = maxWidth;
		vector<string> res; res.push_back(words[0]);

		for (int i = 1; i < n; i++)
		{
			if (res.back().size() + 1 + words[i].size() > maxWidth)
				res.push_back(words[i]);
			else res.back() += ' ' + words[i];
		}

		for (int i = res.size() - 2; i >= 0; i--) adjust(res[i]);
		res.back().resize(maxWidth, ' ');

		return res;
	}
};
```

**双指针：**

```c++
class Solution {
public:
	vector<string> fullJustify(vector<string>& words, int maxWidth) {
		int n = words.size();
		vector<string> res;
		for (int i = 0; i < n; i++)
		{
			int len = words[i].size();
			int j = i + 1;
			while (j < n && len + 1 + words[j].size() <= maxWidth)
			{
				len += 1 + words[j].size();
				j++;
			}

			string line = words[i];
			if (j == i + 1 || j == n) // 左对齐
			{
				for (int k = i + 1; k < j; k++) line += ' ' + words[k];
				line.resize(maxWidth, ' ');
			}
			else // 左右对齐
			{
				int cnt = j - i - 1, total_space = maxWidth - len + cnt;
				int space = total_space / cnt, extra = total_space % cnt;
				for (int k = i + 1; k < j; k++)
				{
					if (extra) line += string(space + 1, ' '), extra--;
					else line += string(space, ' ');
					line += words[k];
				}
			}
			i = j - 1;
			res.push_back(line);
		}
		return res;
	}
};
```

1. yxc的方法，优雅。

## 双指针

### 验证回文串

题目：[验证回文串](https://leetcode.cn/problems/valid-palindrome/)

1. isalnum()：判断一个字符是否是字母或者（十进制）数字，若为字母或者数字，则返回True(非0值)，否者返回False(0)；
2. tolower()：它返回c的小写等价物（如果不存在小写等效，则返回c）。

```c++
class Solution {
public:
    inline bool is_letter(char c)
    {
        return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9');
    }

    inline bool check(char a, char b)
    {
        a |= 32, b |= 32;
        return a == b;
    }

    bool isPalindrome(string s) {
        int i = 0, j = s.size() - 1;
        while (i < j)
        {
            while (i < j && !is_letter(s[i])) i++;
            while (i < j && !is_letter(s[j])) j--;
            if (!check(s[i], s[j])) return false;
            i++, j--;
        }
        return true;
    }
};
```

```c++
class Solution {
public:
    bool isPalindrome(string s) {
        int i = 0, j = s.size() - 1;
        while (i < j)
        {
            while (i < j && !isalnum(s[i])) i++;
            while (i < j && !isalnum(s[j])) j--;
            if (tolower(s[i]) != tolower(s[j])) return false;
            i++, j--;
        }
        return true;
    }
};
```

### 判断子序列

题目：[判断子序列](https://leetcode.cn/problems/is-subsequence/)

```c++
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int n = s.size(), m = t.size();
        for (int i = 0, j = 0; i < n; i++, j++)
        {
            while (j < m && t[j] != s[i]) j++;
            if (j == m) return false;
        }
        return true;
    }
};
```

```c++
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        j, m = 0, len(t)
        for i in range(len(s)):
            while j < m and s[i] != t[j]: j += 1
            if j == m: return False
            j += 1
        return True
```

### 两数之和 II - 输入有序数组

题目：[两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

**双指针：**

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int i = 0, j = numbers.size() - 1;
        while (i < j)
        {
            int sum = numbers[i] + numbers[j];
            if (sum < target) i++;
            else if (sum > target) j--;
            else return { i + 1, j + 1 };
        }
        return {};
    }
};
```

**二分查找：**

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int n = numbers.size();
        for (int k = 0; k < n; k++)
        {
            int tar = target - numbers[k];
            int i = k + 1, j = n - 1;
            while (i <= j)
            {
                int mid = i + j >> 1;
                if (numbers[mid] > tar) j = mid - 1;
                else if (numbers[mid] < tar) i = mid + 1;
                else return { k + 1, mid + 1 };
            }
        }
        return {};
    }
};
```

### 盛最多水的容器

题目：[盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

**题解：**

https://leetcode.cn/problems/container-with-most-water/solutions/11491/container-with-most-water-shuang-zhi-zhen-fa-yi-do/?envType=study-plan-v2&envId=top-interview-150

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int res = 0;
        int i = 0, j = height.size() - 1;
        while (i < j)
        {
            if (height[i] < height[j])
            {
                res = max(res, (j - i) * height[i]);
                i++;
            }
            else
            {
                res = max(res, (j - i) * height[j]);
                j--;
            }
        }
        
        return res;
    }
};
```

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        res = 0
        i, j = 0, len(height) - 1
        while i < j:
            if height[i] < height[j]:
                res = max(res, (j - i) * height[i])
                i += 1
            else:
                res = max(res, (j - i) * height[j])
                j -= 1
        
        return res
```

### 三数之和

题目：[三数之和](https://leetcode.cn/problems/3sum/)

**题解：**

https://leetcode.cn/problems/3sum/solutions/11525/3sumpai-xu-shuang-zhi-zhen-yi-dong-by-jyd/?envType=study-plan-v2&envId=top-interview-150

```c++
class Solution {
public:
	vector<vector<int>> threeSum(vector<int>& nums) {
		int n = nums.size();
		sort(nums.begin(), nums.end());
		vector<vector<int>> res;
		for (int k = 0; k < n - 2; k++)
		{
            if (nums[k] > 0) break;
            if (k > 0 && nums[k - 1] == nums[k]) continue;
			int tar = -nums[k];
			int i = k + 1, j = n - 1;
			while (i < j)
			{
				int sum = nums[i] + nums[j];
				if (sum < tar)
                    while (i < j && nums[i] == nums[++i]);
				else if (sum > tar)
                    while (i < j && nums[j] == nums[--j]);
				else
                {
                    res.push_back({ nums[i], nums[j], nums[k] });
                    while (i < j && nums[i] == nums[++i]);
                    while (i < j && nums[j] == nums[--j]);
                }
			}
		}

		return res;
	}
};
```

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        nums.sort()
        res = []
        for k in range(n - 2):
            if nums[k] > 0: break
            if k >= 1 and nums[k - 1] == nums[k]: continue
            tar = -nums[k]
            i, j = k + 1, n - 1
            while i < j:
                sum = nums[i] + nums[j]
                if sum < tar:
                    while i < j and nums[i] == nums[i + 1]: i += 1
                    i += 1
                elif sum > tar:
                    while i < j and nums[j] == nums[j - 1]: j -= 1
                    j -= 1
                else:
                    res.append([nums[i], nums[j], nums[k]])
                    i, j = i + 1, j - 1
                    while i < j and nums[i] == nums[i - 1]: i += 1
                    while i < j and nums[j] == nums[j + 1]: j -= 1

        return res
```

## 滑动窗口

### 长度最小的子数组

题目：[长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

**题解：**

https://leetcode.cn/problems/minimum-size-subarray-sum/solutions/305704/chang-du-zui-xiao-de-zi-shu-zu-by-leetcode-solutio/?envType=study-plan-v2&envId=top-interview-150

**滑动窗口：**

这里每一次外层循环动一次右侧指针`i`，如果每次外层循环动一次左侧指针会稍微麻烦一些。

```c++
class Solution {
public:
    const int INF = 1e5 + 10; 
    
    int minSubArrayLen(int target, vector<int>& nums) {
        int n = nums.size();
        int res = INF, sum = 0;
        for (int i = 0, j = 0; i < n; i++)
        {
            sum += nums[i];
            while (sum >= target)
            {
                res = min(res, i - j + 1);
                sum -= nums[j++];
            }
        }

        return res == INF ? 0 : res;
    }
};
```

**前缀和+二分查找：**

```c++
class Solution {
public:
    const int INF = 1e9 + 10;

    int binary_search(vector<int>& arr, int l, int r, int tar)
    {
        int i = l, j = r;
        while (i < j)
        {
            int mid = i + j + 1 >> 1;
            if (arr[mid] <= tar) i = mid;
            else j = mid - 1;
        }
        return arr[i] <= tar ? i : -1;
    }

    int minSubArrayLen(int target, vector<int>& nums) {
        int n = nums.size();
        vector<int> ps(n + 1); // 前缀和
        for (int i = 0; i < n; i++) ps[i + 1] = ps[i] + nums[i];

        // ps[i] - ps[j - 1] >= target -> ps[j - 1] <= ps[i] - target
        int res = INF; 
        for (int i = 1; i <= n; i++)
        {
            int j = binary_search(ps, 0, i - 1, ps[i] - target);
            if (j >= 0) res = min(res, i - j);
        }

        return res == INF ? 0 : res;
    }
};
```

### 无重复字符的最长子串

题目：[无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

**枚举右指针的滑动窗口：**

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.size();
        unordered_set<char> hash;
        int res = 0;
        for (int i = 0, j = 0; i < n; i++)
        {
            while (hash.count(s[i])) hash.erase(s[j++]);
            hash.insert(s[i]);
            res = max(res, i - j + 1);
        }

        return res;
    }
};
```

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        hash = set()
        res, j = 0, 0
        for i in range(len(s)):
            while s[i] in hash:
                hash.remove(s[j])
                j += 1
            hash.add(s[i])
            res = max(res, i - j + 1)
        
        return res
```

### 串联所有单词的子串

题目：[串联所有单词的子串](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/)

**题解：**

https://www.acwing.com/video/1352/

**滑动窗口：**

```c++
class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        vector<int> res;
        int n = s.size(), m = words.size(), w = words[0].size();

        unordered_map<string, int> tot;
        for (auto& word : words) tot[word]++;

        for (int i = 0; i < w; i++) 
        {
            unordered_map<string, int> wd;
            int cnt = 0;
            for (int j = i; j <= n - w; j += w)
            {
                if (j >= i + m * w)
                {
                    auto word = s.substr(j - m * w, w);
                    wd[word]--;
                    if (wd[word] < tot[word]) cnt--;
                }
                auto word = s.substr(j, w);
                wd[word]++;
                if (wd[word] <= tot[word]) cnt++;
                if (cnt == m) res.push_back(j - (m - 1) * w);
            }
        }

        return res;
    }
};
```

```python
class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        res = []
        n, m, w = len(s), len(words), len(words[0])
        
        tot = {}
        for word in words: tot[word] = tot[word] + 1 if word in tot else 1

        for i in range(w):
            wd = {}
            cnt = 0
            for j in range(i, n - w + 1, w):
                if j >= i + m * w:
                    word = s[j - m * w: j - (m - 1) * w]
                    wd[word] -= 1
                    if wd[word] < tot.get(word, 0): cnt -= 1
                
                word = s[j: j + w]
                wd[word] = wd[word] + 1 if word in wd else 1
                if wd[word] <= tot.get(word, 0): cnt += 1
                if cnt == m: res.append(j - (m - 1) * w)
        
        return res
```

**字符串哈希优化：**

### 最小覆盖子串

[最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

```c++
class Solution {
public:
    const int INF = 1e9;

    string minWindow(string s, string t) {
        int n = s.size(), m = t.size();

        unordered_map<char, int> tot; for (char c : t) tot[c]++;
        unordered_map<char, int> wd;

        int l = 0, r = INF; // 答案
        int cnt = 0;
        for (int i = 0, j = 0; i < n; i++)
        {
            wd[s[i]]++;
            if (wd[s[i]] <= tot[s[i]]) cnt++;
            if (cnt < m) continue;
            while (j <= i && wd[s[j]] > tot[s[j]])
            {
                wd[s[j]]--;
                j++;
            }
            if (i - j < r - l) l = j, r = i;
        }

        return r == INF ? "" : s.substr(l, r - l + 1);
    }
};
```

```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        n, m = len(s), len(t)
        INF = 1e5 + 10

        wd, tot = {}, {}
        for c in t: tot[c] = tot.get(c, 0) + 1

        l, r = 0, INF  # 答案
        j = 0          # 滑动窗口
        cnt = 0
        for i in range(n):
            wd[s[i]] = wd.get(s[i], 0) + 1
            if wd[s[i]] <= tot.get(s[i], 0): cnt += 1
            if cnt < m: continue

            while j <= i and wd[s[j]] > tot.get(s[j], 0):
                wd[s[j]] -= 1
                j += 1
            if i - j < r - l: l, r = j, i
                
        return "" if r == INF else s[l: r + 1]
```

## 矩阵

### 有效的数独

题目：[有效的数独](https://leetcode.cn/problems/valid-sudoku/)

```c++
class Solution {
public:
    const int n = 9;
    bool isValidSudoku(vector<vector<char>>& board) {
        vector<int> rows(n), cols(n), blocks(n);
        for ( int i = 0; i < n; i++ )
        {
            for ( int j = 0; j < n; j++ )
            {
                char c = board[i][j];
                if ( c == '.' ) continue;

                int d = 1 << ( c - '0' ), idx = ( i / 3 ) * 3 + j / 3;
                if ( d & rows[i] || d & cols[j] || d & blocks[idx] ) return false;
                rows[i] += d;
                cols[j] += d;
                blocks[idx] += d;
            }
        }

        return true;
    }
};
```

```python
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        n = 9
        rows, cols, blocks = [0] * n, [0] * n, [0] * n
        for i in range( n ):
            for j in range( n ):
                c = board[i][j]
                if c == '.': continue

                d, idx = 1 << int(c), ( i // 3 ) * 3 + j // 3
                if ( d & rows[i] ) or ( d & cols[j] ) or ( d & blocks[idx] ):
                    return False
                rows[i] += d
                cols[j] += d
                blocks[idx] += d
        
        return True
```

### 螺旋矩阵

题目：[螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int l = 0, r = matrix[0].size() - 1;
        int u = 0, d = matrix.size() - 1;
        vector<int> res; res.reserve( ( r + 1 ) * ( d + 1 ) );
        while ( true )
        {
            for ( int i = l; i <= r; i++ ) res.push_back( matrix[u][i] );
            if ( ++u > d ) break;

            for ( int i = u; i <= d; i++ ) res.push_back( matrix[i][r] ); 
            if ( l > --r ) break;

            for ( int i = r; i >= l; i-- ) res.push_back( matrix[d][i] );
            if ( u > --d ) break;

            for ( int i = d; i >= u; i-- ) res.push_back( matrix[i][l] );
            if ( ++l > r ) break;
        }

        return res;
    }
};
```

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        l, r = 0, len( matrix[0] ) - 1
        u, d = 0, len( matrix ) - 1
        res = []
        while True:
            for i in range( l, r + 1 ): res.append( matrix[u][i] )
            u += 1
            if u > d: break

            for i in range( u, d + 1 ): res.append( matrix[i][r] )
            r -= 1
            if l > r: break

            for i in range( r, l - 1, -1 ): res.append( matrix[d][i] )
            d -= 1
            if u > d: break

            for i in range( d, u - 1, -1 ): res.append( matrix[i][l] )
            l += 1
            if l > r: break

        return res
```

### 旋转图像

题目：[旋转图像](https://leetcode.cn/problems/rotate-image/)

**题解：**

思路可以参考这一份[题解](https://leetcode.cn/problems/rotate-image/solutions/1228078/48-xuan-zhuan-tu-xiang-fu-zhu-ju-zhen-yu-jobi/?envType=study-plan-v2&envId=top-interview-150)，但关键是如何推导四个要交换元素的坐标。这里给出一种简单的方法：分别把四个坐标记为$(i_1, j_1), (i_2, j_2), (i_3, j_3), (i_4, j_4)$。考察前两个坐标的关系，会发现$i_2 = j_1, j_2 = n - i_1 - 1.$

第二个坐标和第三个坐标有相同的关系，则可以推导出第一个坐标和第三个坐标的关系，
$$
\begin{aligned}
i_3 &= j_2 &&= n - i_1 - 1\\
j_3 &= n - i_2 - 1 &&= n - j_1 - 1
\end{aligned}
$$
同理可得第一个坐标和第四个坐标的关系，
$$
\begin{aligned}
i_4 &= j_3 &&= n - j_1 - 1\\
j_4 &= n - i_3 - 1 &&= i_1 
\end{aligned}
$$


```c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for ( int i = 0; i < n / 2; i++ )
        {
            for ( int j = 0; j < ( n + 1 ) / 2; j++ )
            {
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[n - j - 1][i];
                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
                matrix[j][n - i - 1] = tmp;
            }
        }
    }
};
```

### 矩阵置零

题目：[矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)

**题解：**

https://leetcode.cn/problems/set-matrix-zeroes/solutions/669901/ju-zhen-zhi-ling-by-leetcode-solution-9ll7/?envType=study-plan-v2&envId=top-interview-150

```c++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        bool fr = false, fc = false;
        for ( int i = 0; i < m; i++ )
            if ( !matrix[i][0] ) fc = true;
        for ( int i = 0; i < n; i++ )
            if ( !matrix[0][i] ) fr = true;

        for ( int i = 1; i < m; i++ )
            for ( int j = 1; j < n; j++ )
                if ( !matrix[i][j] )
                {
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                }

        for ( int i = 1; i < m; i++ )
            for ( int j = 1; j < n; j++ )
                if ( !matrix[i][0] || !matrix[0][j] ) 
                    matrix[i][j] = 0;

        if ( fr ) for ( int i = 0; i < n; i++ )
            matrix[0][i] = 0;
        if ( fc ) for ( int i = 0; i < m; i++ )
            matrix[i][0] = 0;
    }
};
```

```c++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        bool fc = false;
        for ( int i = 0; i < m; i++ )
            if ( !matrix[i][0] ) fc = true;
        for ( int i = 1; i < n; i++ )
            if ( !matrix[0][i] ) matrix[0][0] = 0;
        
        for ( int i = 1; i < m; i++ )
            for ( int j = 1; j < n; j++ )
                if ( !matrix[i][j] )
                {
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                }

        for ( int i = 1; i < m; i++ )
            for ( int j = 1; j < n; j++ )
                if ( !matrix[i][0] || !matrix[0][j] )
                    matrix[i][j] = 0;
        
        if ( !matrix[0][0] ) 
            for ( int i = 1; i < n; i++ )
                matrix[0][i] = 0;
        if ( fc )
            for ( int i = 0; i < m; i++ )
                matrix[i][0] = 0;            
    }
};
```

### 生命游戏

题目：[生命游戏](https://leetcode.cn/problems/game-of-life/)

**题解：**

我们可以丰富二进制表示的内涵，最低位表示细胞此时的状态，次低位作标记表示是否需要做转换。

对于一个数$x$，取$x$的最低位的代码为`x & 1`，取$x$的次低位的代码为`x & 2`。

```c++
class Solution {
public:
    int get_lives( vector<vector<int>>& board, int u, int v )
    {
        int cnt = -board[u][v];
        int m = board.size(), n = board[0].size();
        for ( int i = max( u - 1, 0 ); i < min( u + 2, m ); i++ )
            for ( int j = max( v - 1, 0 ); j < min( v + 2, n ); j++ )
                cnt += ( board[i][j] & 1 );
        return cnt;
    }

    void gameOfLife(vector<vector<int>>& board) {
        int m = board.size(), n = board[0].size();
        for ( int i = 0; i < m; i++ )
            for ( int j = 0; j < n; j++ )
            {
                int& x = board[i][j];
                int cnt = get_lives( board, i, j );
                if ( x && ( cnt < 2 || cnt > 3 ) ) x |= 2;
                if ( !x && cnt == 3 ) x |= 2;
            }
        
        for ( int i = 0; i < m; i++ )
            for ( int j = 0; j < n; j++ )
            {
                int& x = board[i][j];
                if ( x & 2 ) x = !( x & 1 );
            }
    }
};
```

## 哈希表

### 赎金信

题目：[赎金信](https://leetcode.cn/problems/ransom-note/)

```c++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int map[26]; memset( map, 0, sizeof( map ) );
        for ( char c : magazine ) map[c - 'a']++;
        for ( char c : ransomNote )
            if ( --map[c - 'a'] < 0 ) return false;
        return true;
    }
};
```

```python
class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        map = [0] * 26
        a = ord('a')
        for c in magazine: map[ord(c) - a] += 1
        for c in ransomNote:
            map[ord(c) - a] -= 1
            if map[ord(c) - a] < 0: return False
        return True
```

### 同构字符串

题目：[同构字符串](https://leetcode.cn/problems/isomorphic-strings/)

```c++
class Solution {
public:
    const int N = 128; // ASCII字符总数

    bool isIsomorphic(string s, string t) {
        int n = s.size();
        vector<int> s2t(N), t2s(N);
        for ( int i = 0; i < n; i++ )
        {
            if ( s2t[s[i]] && s2t[s[i]] != t[i] ) return false;
            if ( t2s[t[i]] && t2s[t[i]] != s[i] ) return false;
            if ( !s2t[s[i]] ) s2t[s[i]] = t[i], t2s[t[i]] = s[i];
        }
        return true;
    }
};
```

### 单词规律

题目：[单词规律](https://leetcode.cn/problems/word-pattern/)

```c++
class Solution {
public:
    bool wordPattern(string p, string s) {
        int n = p.size(), m = s.size();
        unordered_map<char, string> p2s;
        unordered_map<string, char> s2p;
        int i = 0;
        for (int k = 0; k < n; k++)
        {
            if ( i >= m ) return false;
            int j = i;
            while (j < m && s[j] != ' ') j++;
            string ss = s.substr(i, j - i);

            if (p2s.count(p[k]) && p2s[p[k]] != ss) return false;
            if (s2p.count(ss) && s2p[ss] != p[k]) return false;
            if (!p2s.count(p[k]))  p2s[p[k]] = ss, s2p[ss] = p[k];
            i = j + 1;
        }
        return i >= m;
    }
};
```

### 有效的字母异位词

题目：[有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        vector<int> map(26);
        for ( char c : s ) map[c - 'a']++;
        for ( char c : t ) map[c - 'a']--;
        for ( int num : map )
            if ( num ) return false;
        return true;
    }
};
```

### 字母异位词分组

题目：[字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

**题解：**

字符串哈希，每个字母$c$映射为`c - 'a' + 1`。这里并不把$a$映射为$0$，因为$a$会作高位，而高位不能为$0$。 

```c++
class Solution {
private:
    const int p = 29;

    unsigned int hash( string& s )
    {
        vector<int> map(26);
        for ( char c : s ) map[c - 'a']++;
        unsigned int res = 0;
        for ( int i = 0; i < 26; i++ )
            while ( map[i]-- )
            {
                res *= p;
                res += i + 1;
            }

        return res;
    }
    
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<unsigned int, vector<string>> map;
        for ( string& s : strs )
            map[hash( s )].emplace_back( s );

        vector<vector<string>> res;
        for ( auto it = map.begin(); it != map.end(); it++ )
            res.emplace_back( it->second );
        
        return res;
    }
};
```

### 两数之和

题目：[两数之和](https://leetcode.cn/problems/two-sum/)

**思路：**

两种思路，一种是哈希表，一种是双指针。

哈希表最好是先查再插入。而不是所有数据插入了再查找，否则相同元素处理起来比较麻烦。

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        unordered_map<int, int> map;
        for ( int i = 0; i < n; i++ )
        {
            int tmp = target - nums[i];
            if ( map.count( tmp ) )
                return { i, map[tmp] };
            map[nums[i]] = i;
        }
        return {};
    }
};
```

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        vector<pair<int, int>> ps; ps.reserve( n );
        for ( int i = 0; i < n; i++ ) ps.push_back( { nums[i], i } );
        sort( ps.begin(), ps.end() );
        int i = 0, j = n - 1;
        while ( i < j )
        {
            int sum = ps[i].first + ps[j].first;
            if ( sum < target ) i++;
            if ( sum > target ) j--;
            if ( sum == target ) return { ps[i].second, ps[j].second };
        }
        return {};
    }
};
```

### 快乐数

题目：[快乐数](https://leetcode.cn/problems/happy-number/)

**题解：**

https://leetcode.cn/problems/happy-number/solutions/224894/kuai-le-shu-by-leetcode-solution/?envType=study-plan-v2&envId=top-interview-150

**哈希表：**

```c++
class Solution {
public:
    int get_next( int n )
    {
        int res = 0;
        while ( n )
        {
            res += ( n % 10 ) * ( n % 10 );
            n /= 10;
        }
        return res;
    }

    bool isHappy(int n) {
        unordered_set<int> hs;
        while ( !hs.count( n ) )
        {
            if ( n == 1 ) return true;
            hs.insert( n );
            n = get_next( n );
        }
        return false;
    }
};
```

**快慢指针：**

```c++
class Solution {
public:
    int get_next( int n )
    {
        int res = 0;
        while ( n )
        {
            int d = n % 10;
            res += d * d;
            n /= 10;
        }
        return res;
    }

    bool isHappy(int n) {
        int fast = get_next( n ), slow = n;
        while ( fast != 1 && fast != slow )
        {
            slow = get_next( slow );
            fast = get_next( get_next( fast ) );
        }
        return fast == 1;
    }
};
```

### 存在重复元素 II

题目：[存在重复元素 II](https://leetcode.cn/problems/contains-duplicate-ii/)

```c++
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        int n = nums.size();
        unordered_map<int, int> map;
        for ( int i = 0; i < n; i++ )
        {
            auto it = map.find( nums[i] );
            if ( it != map.end() && i - it->second <= k )
                return true;
            map[nums[i]] = i;
        }
        return false;
    }
};
```

### 最长连续序列

题目：[最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

**题解：**

https://leetcode.cn/problems/longest-consecutive-sequence/solutions/276931/zui-chang-lian-xu-xu-lie-by-leetcode-solution/?envType=study-plan-v2&envId=top-interview-150

```c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> hash_set;
        for ( int num : nums ) hash_set.insert( num );

        int res = 0;
        for ( int num : hash_set )
        {
            auto it = hash_set.find( num - 1 );
            if ( it != hash_set.end() ) continue;

            int cnt = 0;
            do
            {
                cnt++;
                it = hash_set.find( ++num );
            } while ( it != hash_set.end() );
            if ( cnt > res ) res = cnt;
        }
        return res;
    }
};
```

## 区间

### 汇总区间

题目：[汇总区间](https://leetcode.cn/problems/summary-ranges/)

```c++
class Solution {
public:
    vector<string> summaryRanges(vector<int>& nums) {
        int n = nums.size();
        vector<string> res;
        for ( int i = 0; i < n; i++ )
        {
            int j = i;
            while ( j + 1 < n && nums[j + 1] == nums[j] + 1 ) j++;
            string tmp = to_string( nums[i] );
            if ( i != j ) tmp += "->" + to_string( nums[j] );
            res.emplace_back( tmp );
            i = j;
        }
        return res;
    }
};
```

### 合并区间

题目：[合并区间](https://leetcode.cn/problems/merge-intervals/)

```c++
class Solution {
public:
    void merge( vector<vector<int>>& res, vector<int>& interval )
    {
        if ( res.empty() ) res.push_back( interval );
        else
        {
            vector<int>& last = res.back();
            if ( last[1] < interval[0] ) res.push_back( interval );
            else last[1] = max( last[1], interval[1] );
        }
    }

    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> res;
        sort( intervals.begin(), intervals.end() );
        for ( auto& interval : intervals ) merge( res, interval );
        return res;
    }
};
```

### 插入区间

题目：[插入区间](https://leetcode.cn/problems/insert-interval/)

**题解：**

https://leetcode.cn/problems/insert-interval/solutions/2841141/ben-ti-he-56-he-bing-qu-jian-de-guan-xi-zkcik

```c++
class Solution {
public:
    void merge( vector<vector<int>>& res, vector<int>& interval )
    {
        if ( res.empty() ) res.push_back( interval );
        else
        {
            vector<int>& last = res.back();
            if ( last[1] < interval[0] ) res.push_back( interval );
            else last[1] = max( last[1], interval[1] );
        }
    }

    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
        int n = intervals.size();
        vector<vector<int>> res;
        bool flag = false;
        for ( int i = 0; i < n; i++ )
        {
            if ( intervals[i][0] < newInterval[0] ) res.push_back( intervals[i] );
            else
            {
                if ( !flag )
                {
                    merge( res, newInterval );
                    flag = true;
                }
                merge( res, intervals[i] );
            }
        }
        if ( !flag ) merge( res, newInterval );
        return res;
    }
};
```

### 用最少数量的箭引爆气球

题目：[用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)

```c++
class Solution {
public:
    int findMinArrowShots(vector<vector<int>>& points) {
        int n = points.size();
        sort( points.begin(), points.end(), 
            [](vector<int>& A, vector<int>& B) { return A[1] < B[1]; } );
        
        int x = points[0][1], res = 1;
        for ( auto& point : points )
            if ( x < point[0] )
            {
                x = point[1];
                res++;
            }
        
        return res;
    }
};
```

## 栈

### 有效的括号

题目：[有效的括号](https://leetcode.cn/problems/valid-parentheses/)

```c++
class Solution {
public:
    bool isValid(string s) {
        int n = s.size();
        vector<char> stk(n + 1); int tt = 0;
        for ( char c : s )
        {
            if ( c == '(' || c == '[' || c == '{' )
                stk[++tt] = c;
            else 
            {
                if ( c == ')' && stk[tt] == '(' ) tt--;
                else if ( c == ']' && stk[tt] == '[' ) tt--;
                else if ( c == '}' && stk[tt] == '{' ) tt--;
                else return false;
            }
        }
        return tt == 0;
    }
};
```

### 简化路径

题目：[简化路径](https://leetcode.cn/problems/simplify-path/)

**题解：**

https://leetcode.cn/problems/simplify-path/solutions/1193258/jian-hua-lu-jing-by-leetcode-solution-aucq/?envType=study-plan-v2&envId=top-interview-150

```c++
class Solution {
public:
    string simplifyPath(string path) {
        int n = path.size();
        vector<string> stk; stk.reserve( n / 2 );
        for ( int i = 1; i < n; i++ )
        {
            int j = i;
            while ( j < n && path[j] != '/' ) j++;
            string name = path.substr( i, j - i );
            i = j;

            if ( !name.size() || name == "." ) continue;
            else if ( name == ".." )
            {
                if ( stk.size() ) stk.pop_back();
            }
            else stk.push_back( name );
        }

        string res;
        for ( int i = 0; i < stk.size(); i++ )
            res += "/" + move( stk[i] );
        if ( stk.empty() ) res = "/";

        return res;
    }
};
```

### 最小栈

题目：[最小栈](https://leetcode.cn/problems/min-stack/)

**题解：**

https://leetcode.cn/problems/min-stack/solutions/242190/zui-xiao-zhan-by-leetcode-solution/?envType=study-plan-v2&envId=top-interview-150

```c++
class MinStack {
private:
    stack<int> stk;
    stack<int> min_stk;

public:
    MinStack() {
        min_stk.push( INT_MAX );
    }
    
    void push(int val) {
        stk.push( val );
        int top = min_stk.top();
        min_stk.push( min( val, top ) );
    }
    
    void pop() {
        stk.pop();
        min_stk.pop();
    }
    
    int top() {
        return stk.top();
    }
    
    int getMin() {
        return min_stk.top();
    }
};
```

### 逆波兰表达式求值

题目：[逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

```c++
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        int n = tokens.size();
        stack<int> stk;
        for ( string& s : tokens )
        {
            if ( s == "+" || s == "-" || s == "*" || s == "/" )
            {
                int b = stk.top(); stk.pop();
                int a = stk.top(); stk.pop();
                if ( s == "+" ) stk.push( a + b );
                if ( s == "-" ) stk.push( a - b );
                if ( s == "*" ) stk.push( a * b );
                if ( s == "/" ) stk.push( a / b );
            }
            else stk.push( stoi( s ) );
        }
        return stk.top();
    }
};
```

### 基本计算器

题目：[基本计算器](https://leetcode.cn/problems/basic-calculator/)

**题解：**

https://leetcode.cn/problems/basic-calculator/solutions/646369/ji-ben-ji-suan-qi-by-leetcode-solution-jvir/?envType=study-plan-v2&envId=top-interview-150

**括号展开：**

```c++
class Solution {
public:
    int calculate(string s) {
        int n = s.size();
        stack<int> stk; stk.push( 1 );
        int sign = 1;
        int res = 0;
        for ( int i = 0; i < n; i++ )
        {
            if      ( s[i] == ' ' ) continue;
            else if ( s[i] == '+' ) sign = stk.top();
            else if ( s[i] == '-' ) sign = -stk.top();
            else if ( s[i] == '(' ) stk.push( sign );
            else if ( s[i] == ')' ) stk.pop();
            else
            {
                int num = 0;
                int j = i;
                while ( j < n && s[j] >= '0' && s[j] <= '9' )
                {
                    num = s[j] - '0' + num * 10;
                    j++;
                }
                i = j - 1;
                res += num * sign;
            }
        }
        return res;
    }
};
```

**中缀转后缀：**

```c++
class Solution {
private:
    void calc( stack<char>& opnd, stack<int>& optr )
    {
        int b = optr.top(); optr.pop();
        int a = optr.top(); optr.pop();
        optr.push( opnd.top() == '+' ? a + b : a - b );
        opnd.pop();
    }

    bool is_optr( char c ) { return c == '+' || c == '-'; }

    bool is_pos( char c ) { return c >= '0' && c <= '9'; }

    bool is_neg( char c, char prev ) { return c == '-' && ( !prev || prev == '(' ); }

public:
    int calculate(string s) {
        int n = s.size();
        stack<char> opnd; stack<int> optr;
        char prev = 0;
        for ( int i = 0; i < n; i++ )
        {
            char c = s[i];
            if      ( c == ' ' ) continue;
            else if ( is_pos( c ) )
            {
                int num = 0;
                int j = i;
                while ( j < n && s[j] >= '0' && s[j] <= '9' )
                {
                    num = s[j] - '0' + num * 10;
                    j++;
                }
                optr.push( num );
                i = j - 1;
            }
            else if ( is_neg( c, prev ) )
            {
                opnd.push( c );
                optr.push( 0 );
            }
            else
            {
                if      ( c == '(' ) opnd.push( c );
                else if ( c == ')' )
                {
                    while ( opnd.top() != '(' ) calc( opnd, optr );
                    opnd.pop();
                }
                else
                {
                    if ( opnd.size() && is_optr( opnd.top() ) ) 
                        calc( opnd, optr );
                    opnd.push( c );
                }
            }
            prev = c;
        }
        while ( opnd.size() ) calc( opnd, optr );
        return optr.top();
    }
};
```

## 链表

### 环形链表

题目：[环形链表](https://leetcode.cn/problems/linked-list-cycle/)

**快慢指针：**

```c++
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if ( !head ) return false;
        
        ListNode* slow = head, * fast = head->next;
        while ( fast && slow != fast )
        {
            slow = slow->next;
            fast = fast->next;
            if ( fast ) fast = fast = fast->next;
        }
        return slow == fast;
    }
};
```

**哈希表：**

```c++
class Solution {
public:
    bool hasCycle(ListNode *head) {
        unordered_set<ListNode*> hs;
        auto p = head;
        while ( p )
        {
            if ( hs.find( p ) != hs.end() ) return true;
            hs.insert( p );
            p = p->next;
        }
        return false;
    }
};
```

### 两数相加

题目：[两数相加](https://leetcode.cn/problems/add-two-numbers/)

```c++
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        auto dummy = new ListNode();
        auto pre = dummy;
        int c = 0;
        while ( l1 || l2 )
        {
            int a = l1 ? l1->val : 0;
            int b = l2 ? l2->val : 0;
            int sum = a + b + c;
            pre->next = new ListNode( sum % 10 );
            c = sum / 10;

            pre = pre->next;
            if ( l1 ) l1 = l1->next;
            if ( l2 ) l2 = l2->next;
        }
        if ( c ) pre->next = new ListNode( c );

        auto res = dummy->next;
        delete dummy;
        return res;
    }
};
```

### 合并两个有序链表

题目：[合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

**迭代：**

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        auto dummy = new ListNode( -100, l1 );
        l1 = dummy;
        while ( l1 || l2 )
        {
            if      ( !l2 ) l1 = l1->next;
            else if ( l1->next )
            {
                if ( l1->next->val <= l2->val ) l1 = l1->next;
                else
                {
                    auto tmp = l2->next;
                    l2->next = l1->next;
                    l1->next = l2;
                    l2 = tmp;
                    l1 = l1->next;
                }
            }
            else    // l1->next不存在
            {
                l1->next = l2;
                break;
            }
        }
        return dummy->next;
    }
};
```

**递归：**

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if      ( !l1 ) return l2;
        else if ( !l2 ) return l1;
        else if ( l1->val < l2->val )
        {
            l1->next = mergeTwoLists( l1->next, l2 );
            return l1;
        }
        else    // l2->next <= l1->next
        {
            l2->next = mergeTwoLists( l1, l2->next );
            return l2;
        }
    }
};
```

### 随机链表的复制

题目：[随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)

```c++
class Solution {
public:
    Node* copyRandomList(Node* head) {
        unordered_map<Node*, Node*> map;
        auto dummy = new Node( 0 );
        auto p1 = head, p2 = dummy;
        while ( p1 )
        {
            p2->next = new Node( p1->val );
            map[p1] = p2->next;
            p1 = p1->next, p2 = p2->next;
        }
        p1 = head, p2 = dummy->next;
        while ( p1 )
        {
            p2->random = map[p1->random];
            p1 = p1->next, p2 = p2->next;
        }

        auto res = dummy->next;
        delete dummy;
        return res;
    }
};
```

### 反转链表 II

题目：[反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)

```c++
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        auto dummy = new ListNode( 0, head );
        auto start = dummy;
        for ( int i = 1; i < left; i++ ) start = start->next;
        auto end = start->next;

        ListNode* pre = nullptr, * cur = end;
        for ( int i = left; i <= right; i++ )
        {
            auto tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        start->next = pre, end->next = cur;

        auto res = dummy->next;
        delete dummy;
        return res;
    }
};
```

### K 个一组翻转链表

题目：[K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

**题解：**

https://leetcode.cn/problems/reverse-nodes-in-k-group/solutions/2845603/fen-xiang-di-gui-he-die-dai-liang-chong-t3o43/

**迭代：**

```c++
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* dummy = new ListNode( 0 );
        ListNode* cur = head, * pre = head;
        ListNode* start = dummy, * end = dummy;
        int cnt = k;
        while ( cur )
        {
            start = end; end = cur;
            cnt = 0;
            for ( int i = 1; cur && i <= k; i++ )
            {
                auto tmp = cur->next;
                cur->next = pre;
                pre = cur; cur = tmp;
                cnt++;
            }
            start->next = pre; end->next = cur;
        }
        
        if ( cnt < k )
        {
            cur = pre; end = cur;
            while ( cur )
            {
                auto tmp = cur->next;
                cur->next = pre;
                pre = cur; cur = tmp;
            }
            start->next = pre; end->next = cur;
        }

        auto res = dummy->next;
        delete dummy;
        return res;
    }
};
```

**递归：**

```c++
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        int cnt = 0;
        for ( auto p = head; p; p = p->next )
            if ( ++cnt >= k ) break;
        if ( cnt < k ) return head;

        auto end = head;
        ListNode* cur = head, * pre = nullptr;
        for ( int i = 1; i <= k; i++ )
        {
            auto tmp = cur->next;
            cur->next = pre;
            pre = cur; cur = tmp;
        }
        end->next = reverseKGroup( cur, k );

        return pre;
    }
};
```

### 删除链表的倒数第 N 个结点

题目：[删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

**快慢指针：**

```c++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        auto dummy = new ListNode( 0, head );
        auto slow = dummy, fast = head;
        for ( int i = 1; i <= n; i++ ) fast = fast->next;
        while ( fast )
        {
            fast = fast->next;
            slow = slow->next;
        }
        slow->next = slow->next->next;
        
        auto res = dummy->next; delete dummy;
        return res;
    }
};
```

**递归：**

```c++
class Solution {
public:
    int recur( ListNode* node, int n )
    {
        if ( !node ) return -1;
        int idx = recur( node->next, n ) + 1;
        if ( idx == n ) node->next = node->next->next;
        return idx;
    }

    ListNode* removeNthFromEnd(ListNode* head, int n) {
        auto dummy = new ListNode( 0, head );
        recur( dummy, n );
        auto res = dummy->next; delete dummy;
        return res;
    }
};
```

### 删除排序链表中的重复元素 II

题目：[删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

思想：借鉴了双指针的思想，由于删除需要$pre$指针，所以添加了它。

```c++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        auto dummy = new ListNode( 0, head );
        auto pre = dummy, cur = head;
        while ( cur )
        {
            auto p = cur->next;
            while ( p && p->val == cur->val )
                p = p->next;
            if ( p == cur->next )
            {
                pre = cur;
                cur = cur->next;
            }
            else
            {
                pre->next = p;
                cur = p;
            }
        }
        return dummy->next;
    }
};
```

### 旋转链表

题目：[旋转链表](https://leetcode.cn/problems/rotate-list/)

```c++
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if ( !head || !k ) return head;

        int n = 1;
        auto p = head;
        while ( p->next ) p = p->next, n++;
        k %= n;
        p->next = head;
        p = head;
        for ( int i = 1; i < n - k; i++ )
            p = p->next;
        auto res = p->next;
        p->next = nullptr;
        return res;
    }
};
```

### 分隔链表

题目：[分隔链表](https://leetcode.cn/problems/partition-list/)

**题解：**

https://leetcode.cn/problems/partition-list/?envType=study-plan-v2&envId=top-interview-150

```c++
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        auto small_dum = new ListNode( 0, head );
        auto large_dum = new ListNode();
        auto tail = large_dum;

        auto pre = small_dum, cur = head;
        while ( cur )
        {
            if ( cur->val >= x )
            {
                auto nxt = cur->next;
                cur->next = tail->next;
                tail->next = cur;
                tail = tail->next;
                pre->next = cur = nxt;
            }
            else
            {
                pre = cur;
                cur = cur->next;
            }
        }
        pre->next = large_dum->next;
        return small_dum->next;
    }
};
```

### LRU 缓存

[LRU 缓存](https://leetcode.cn/problems/lru-cache/)

**stl：**

```c++
class LRUCache
{
private:
    int capacity;
    unordered_map<int, list<pair<int, int>>::iterator> map;
    list<pair<int, int>> q;
    
public:
    LRUCache(int capacity)
    {
        this->capacity = capacity;
    }

    int get(int key)
    {
        auto mit = map.find( key );
        if ( mit != map.end() )
        {
            auto qit = mit->second;
            int val = qit->second;
            q.erase( qit );
            map[key] = q.insert( q.end(), { key, val } );
            return val;
        }
        else return -1;
    }

    void put(int key, int value)
    {
        auto mit = map.find( key );
        if ( mit != map.end() )
        {
            q.erase( mit->second );
            map[key] = q.insert( q.end(), { key, value } );
        }
        else
        {
            map[key] = q.insert( q.end(), { key, value } );
            if ( q.size() > capacity )
            {
                auto qit = q.begin();
                map.erase( qit->first );
                q.erase( qit );
            }
        }
    }
};

```

**内部类模拟双链表：**

```c++
class LRUCache {
private:
    struct node
    {
        int key, val;
        node* prev, * next;

        node( int key, int val ): key(key), val(val), prev(nullptr), next(nullptr) {}
    };

    int capacity, size = 0;
    unordered_map<int, node*> map;
    node* dum_head, * dum_tail;

    void remove( node* p )
    {
        p->next->prev = p->prev;
        p->prev->next = p->next;
        size--;
    }

    void push_back( int key, int val )
    {
        auto tmp = new node( key, val );
        tmp->next = dum_tail;
        tmp->prev = dum_tail->prev;
        dum_tail->prev->next = tmp;
        dum_tail->prev = tmp;
        size++;
    }

    void move2back( node* p )
    {
        push_back( p->key, p->val );
        remove( p );
    }

public:
    LRUCache(int capacity) {
        dum_head = new node( 0, 0 );
        dum_tail = new node( 0, 0 );
        dum_head->next = dum_tail;
        dum_tail->prev = dum_head;
        this->capacity = capacity;
    }
    
    int get(int key) {
        if ( map.count( key ) )
        {
            move2back( map[key] );
            auto tail = dum_tail->prev;
            map[key] = tail;
            return tail->val;
        }
        else return -1;
    }
    
    void put(int key, int value) {
        if ( map.count( key ) )
        {
            map[key]->val = value;
            move2back( map[key] );
        }
        else
        {
            push_back( key, value );
            if ( size > capacity )
            {
                auto head = dum_head->next;
                map.erase( head->key );
                remove( head );
            }
        }
        map[key] = dum_tail->prev;
    }
};
```

**数组模拟双链表：**

```c++
class LRUCache {
private:
    const static int N = 2e5 + 10;

    int size = 0, idx = 0;
    pair<int, int> q[N];
    int pre[N], nxt[N];

    unordered_map<int, int> map;
    
    int capacity;

    void remove( int p )
    {
        nxt[pre[p]] = nxt[p];
        pre[nxt[p]] = pre[p];
        size--;
    }

    void push_back( int key, int val )
    {
        q[++idx] = { key, val };
        nxt[idx] = N - 1;
        pre[idx] = pre[N - 1];
        nxt[pre[N - 1]] = idx;
        pre[N - 1] = idx;
        size++;
    }

    void move2back( int p )
    {
        push_back( q[p].first, q[p].second );
        remove( p );
    }

public:
    LRUCache(int capacity) { 
        this->capacity = capacity;
        memset( q, 0, sizeof q );
        memset( pre, 0, sizeof pre );
        memset( nxt, 0, sizeof nxt );
        nxt[0] = N - 1, pre[N - 1] = 0;
    }
    
    int get(int key) {
        if ( map.count( key ) )
        {
            move2back( map[key] );
            map[key] = pre[N - 1];
            return q[pre[N - 1]].second;
        }
        else return -1;
    }
    
    void put(int key, int value) {
        if ( map.count( key ) )
        {
            move2back( map[key] );
            map[key] = pre[N - 1];
            q[pre[N - 1]].second = value;
        }
        else
        {
            push_back( key, value );
            map[key] = pre[N - 1];
            if ( size > capacity )
            {
                key = q[nxt[0]].first;
                remove( nxt[0] );
                map.erase( key );
            }
        }
    }
};
```

## 二叉树

### 二叉树的最大深度

题目：[二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

**题解：**

https://leetcode.cn/problems/maximum-depth-of-binary-tree/?envType=study-plan-v2&envId=top-interview-150

**深度优先遍历（后序）：**

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if ( !root ) return 0;

        return max( maxDepth( root->left ), maxDepth( root->right ) ) + 1;
    }
};
```

**广度优先遍历：**

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        queue<TreeNode*> q; 
        if ( root ) q.push( root );
        int depth = 0;
        while ( q.size() )
        {
            depth++;
            for ( int i = q.size(); i > 0; i-- )
            {
                auto p = q.front(); q.pop();
                if ( p->left ) q.push( p->left );
                if ( p->right ) q.push( p->right );
            }
        }
        return depth;
    }
};
```

### 相同的树

题目：[相同的树](https://leetcode.cn/problems/same-tree/)

**深度优先遍历：**

```c++
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if ( !p && !q ) return true;
        if ( !p || !q ) return false;
        if ( p->val != q->val ) return false;
        return isSameTree( p->left, q->left ) && isSameTree( p->right, q->right );
    }
};
```

**广度优先遍历：**

```c++
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if ( !p && !q ) return true;
        if ( !p || !q ) return false;

        queue<TreeNode*> q1; q1.push( p );
        queue<TreeNode*> q2; q2.push( q );
        while ( q1.size() )
        {
            auto p1 = q1.front(); q1.pop();
            auto p2 = q2.front(); q2.pop();
            if ( p1->val != p2->val ) return false;

            if ( !p1->left ^ !p2->left ) return false;
            if ( !p1->right ^ !p2->right ) return false;

            if ( p1->left ) q1.push( p1->left ), q2.push( p2->left );
            if ( p1->right ) q1.push( p1->right ), q2.push( p2->right );
        }
        return true;
    }
};
```

### 翻转二叉树

题目：[翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

**递归：**

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if ( !root ) return nullptr;

        swap( root->left, root->right );
        invertTree( root->left );
        invertTree( root->right );

        return root;
    }
};
```

**栈：**

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        stack<TreeNode*> stk;
        TreeNode* cur = root, * pre = nullptr;
        while ( cur || stk.size() )
        {
            while ( cur )
            {
                stk.push( cur );
                cur = cur->left;
            }

            cur = stk.top();
            if ( cur->right && cur->right != pre )
                cur = cur->right;
            else
            {
                stk.pop();
                swap( cur->left, cur->right );
                pre = cur;
                cur = nullptr;
            }
        }
        return root;
    }
};
```

### 对称二叉树

题目：[对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

```c++
class Solution {
private:
    bool recur( TreeNode* p1, TreeNode* p2 )
    {
        if ( !p1 && !p2 ) return true;
        if ( ( !p1 ^ !p2 ) || ( p1->val != p2->val ) ) return false;
        return recur( p1->left, p2->right ) && recur( p1->right, p2->left );
    }

public:
    bool isSymmetric(TreeNode* root) {
        return recur( root->left, root->right );
    }
};
```

### 从前序与中序遍历序列构造二叉树

题目：[从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

**题解：**

https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/2361558/105-cong-qian-xu-yu-zhong-xu-bian-li-xu-4lvkz/?envType=study-plan-v2&envId=top-interview-150

```c++
class Solution {
private:
    vector<int> preorder;
    unordered_map<int, int> map;

    TreeNode* recur( int root, int l, int r )
    {
        if ( l > r ) return nullptr;

        auto res = new TreeNode( preorder[root] );
        int idx = map[res->val];
        int left_size = idx - l;
        res->left = recur( root + 1, l, idx - 1 );
        res->right = recur( root + left_size + 1, idx + 1, r );
        return res; 
    }

public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = inorder.size();
        this->preorder = move( preorder );
        for ( int i = 0; i < n; i++ ) map[inorder[i]] = i;
        return recur( 0, 0, n - 1 );
    }
};
```

### 从中序与后序遍历序列构造二叉树

题目：[ 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

**题解：**

https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solutions/426738/cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-14/?envType=study-plan-v2&envId=top-interview-150

```c++
class Solution {
private:
    vector<int> postorder;
    unordered_map<int, int> map;

    TreeNode* recur( int root, int l, int r )
    {
        if ( l > r ) return nullptr;

        auto res = new TreeNode( postorder[root] );
        int idx = map[res->val];
        int right_size = r - idx;
        res->left = recur( root - right_size - 1, l, idx - 1 );
        res->right = recur( root - 1, idx + 1, r );
        return res;
    }

public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        int n = inorder.size();
        this->postorder = move( postorder );
        for ( int i = 0; i < n; i++ ) map[inorder[i]] = i;
        return recur( n - 1, 0, n - 1 );
    }
};
```

### 填充每个节点的下一个右侧节点指针 II

题目：[填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

**题解：**

https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/solutions/2510360/san-chong-fang-fa-dfsbfsbfslian-biao-fu-1bmqp/

**dfs：**

```c++
class Solution {
private:
    vector<Node*> pre;

    void dfs( Node* node, int depth )
    {
        if ( !node ) return;

        if ( depth == pre.size() ) pre.push_back( node );
        else
        {
            pre[depth]->next = node;
            pre[depth] = node;
        }

        dfs( node->left, depth + 1 );
        dfs( node->right, depth + 1 );
    }

public:
    Node* connect(Node* root) {
        dfs( root, 0 );
        return root;
    }
};
```

**bfs：**

```c++
class Solution {
public:
    Node* connect(Node* root) {
        if ( !root ) return nullptr;

        queue<Node*> q; q.push( root );
        while ( q.size() )
        {
            for ( int i = q.size(); i > 0; i-- )
            {
                auto node = q.front(); q.pop();
                if ( i > 1 ) node->next = q.front();

                if ( node->left ) q.push( node->left );
                if ( node->right ) q.push( node->right );
            }
        }
        return root;
    }
};
```

**bfs+链表：**

```c++
class Solution {
public:
    Node* connect(Node* root) {
        auto cur = root;
        auto dum = new Node();
        while ( cur )
        {
            dum->next = nullptr;
            auto nxt = dum;
            while ( cur )
            {
                if ( cur->left )
                {
                    nxt->next = cur->left;
                    nxt = nxt->next;
                }
                if ( cur->right )
                {
                    nxt->next = cur->right;
                    nxt = nxt->next;
                }
                cur = cur->next;
            }
            cur = dum->next;
        }
        return root;
    }
};
```

### 二叉树展开为链表

题目：[二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

**右根左的后序遍历相当于前序的倒序：**

```c++
class Solution {
private:
    TreeNode* pre = nullptr;

    void dfs( TreeNode* root )
    {
        if ( !root ) return;

        dfs( root->right );
        dfs( root->left );

        root->left = nullptr;
        root->right = pre;
        pre = root;
    }

public:
    void flatten(TreeNode* root) {
        dfs( root );
    }
};
```

**寻找前驱节点：**

https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/solutions/356853/er-cha-shu-zhan-kai-wei-lian-biao-by-leetcode-solu/?envType=study-plan-v2&envId=top-interview-150

```c++
class Solution {
public:
    void flatten(TreeNode* root) {
        auto cur = root;
        while ( cur )
        {
            if ( cur->left )
            {
                auto pre = cur->left;
                while ( pre->right ) pre = pre->right;
                pre->right = cur->right;
                cur->right = cur->left;
                cur->left = nullptr;
            }
            cur = cur->right;
        }
    }
};
```

### 路径总和

题目：[路径总和](https://leetcode.cn/problems/path-sum/)

**深度优先搜索：**

```c++
class Solution {
private:
    int targetSum;

    bool dfs( TreeNode* root, int sum )
    {
        if ( !root ) return false;

        sum += root->val;
        if ( !root->left && !root->right)
            return sum == targetSum;
        return dfs( root->left, sum ) || dfs( root->right, sum );
    }

public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        this->targetSum = targetSum;
        return dfs( root, 0 );
    }
};
```

**广度优先遍历：**

```c++
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if ( !root ) return false;

        queue<pair<TreeNode*, int>> q; q.push( { root, root->val } );
        while ( q.size() )
        {
            auto item = q.front(); q.pop();
            auto node = item.first;
            auto sum = item.second;
            if ( sum == targetSum && !node->left && !node->right )
                return true;
            if ( node->left ) 
                q.push( { node->left, node->left->val + sum } );
            if ( node->right ) 
                q.push( { node->right, node->right->val + sum } );
        }
        return false;
    }
};
```

### 求根节点到叶节点数字之和

题目：[求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)

**深度优先遍历：**

```c++
class Solution {
private:
    int sum;

    void dfs( TreeNode* root, int num )
    {
        if ( !root ) return;

        num = num * 10 + root->val;
        if ( !root->left && !root->right ) sum += num;
        else
        {
            dfs( root->left, num );
            dfs( root->right, num );
        }
    }

public:
    int sumNumbers(TreeNode* root) {
        dfs( root, 0 );
        return sum;
    }
};
```

**广度优先遍历：**

```c++
class Solution {
public:
    int sumNumbers(TreeNode* root) {
        int sum = 0;
        queue<pair<TreeNode*, int>> q; 
        q.push( { root, root->val } );
        while ( q.size() )
        {
            auto item = q.front(); q.pop();
            auto node = item.first;
            auto num = item.second;
            auto l = node->left, r = node->right;
            if ( !l && !r ) sum += num;
            else
            {
                num *= 10;
                if ( l ) q.push( { l, num + l->val } );
                if ( r ) q.push( { r, num + r->val } );
            }
        }
        return sum;
    }
};
```

### 二叉树中的最大路径和

题目：[二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

**题解：**

https://leetcode.cn/problems/binary-tree-maximum-path-sum/solutions/2227021/shi-pin-che-di-zhang-wo-zhi-jing-dpcong-n9s91/?envType=study-plan-v2&envId=top-interview-150

```c++
class Solution {
private:
    int ans = -1010;

    int dfs( TreeNode* node )
    {
        if ( !node ) return 0;

        int l = dfs( node->left );
        int r = dfs( node->right );
        ans = max( ans, l + r + node->val );
        return max( max( l + node->val, r + node->val ), 0 );
    }

public:
    int maxPathSum(TreeNode* root) {
        dfs( root );
        return ans;
    }
};
```

```python
class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        ans = -inf
        def dfs( node ):
            if node is None: return 0
            
            l = dfs( node.left )
            r = dfs( node.right )
            nonlocal ans
            ans = max( ans, l + r + node.val )
            return max( 0, max( l + node.val, r + node.val ) )
        dfs( root )
        return ans
```

### 二叉搜索树迭代器

题目：[二叉搜索树迭代器](https://leetcode.cn/problems/binary-search-tree-iterator/)

```c++
class BSTIterator {
private:
    TreeNode * cur;
    stack<TreeNode*> stk;

public:
    BSTIterator(TreeNode* root) { cur = root; }
    
    int next() 
    {
        while ( cur )
        {
            stk.push( cur );
            cur = cur->left;
        }
        cur = stk.top(); stk.pop();
        int res = cur->val;
        cur = cur->right;
        return res;
    }
    
    bool hasNext() 
    {
        return cur || stk.size();
    }
};
```

### 完全二叉树的节点个数

题目：[完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

**题解：**

https://leetcode.cn/problems/count-complete-tree-nodes/solutions/495655/wan-quan-er-cha-shu-de-jie-dian-ge-shu-by-leetco-2/?envType=study-plan-v2&envId=top-interview-150

```c++
class Solution {
private:
    int h = 0, mask = 1;
    TreeNode* root;

    bool exixts( int code )
    {
        auto cur = root;

        for ( int i = 1; i <= h; i++ )
        {
            if ( code & mask ) cur = cur->right;
            else cur = cur->left;
            code <<= 1;
        }
        return cur;
    }

public:
    int countNodes(TreeNode* root) {
        if ( !root ) return 0;
        this->root = root;

        for ( auto p = root; p->left; p = p->left ) h++;
        if ( h > 1 ) mask = 1 << ( h - 1 );

        int l = 1 << h, r = ( 1 << ( h + 1 ) ) - 1;
        while ( l < r )
        {
            int mid = l + r + 1 >> 1;
            if ( exixts( mid ) ) l = mid;
            else r = mid - 1;
        }
        return l;
    }
};
```

### 二叉树的最近公共祖先

题目：[二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (!root || root == p || root == q) return root;

        auto l = lowestCommonAncestor(root->left, p, q);
        auto r = lowestCommonAncestor(root->right, p, q);
        if (l && r) return root;
        return l ? l : r;
    }
};
```

## 二叉树的层序遍历

### 二叉树的右视图

题目：[二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

**层序遍历：**

```c++
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> res;
        if (!root) return res;

        queue<TreeNode*> q; q.push(root);
        while (q.size())
        {
            TreeNode* node = nullptr;
            for (int i = q.size(); i > 0; i--)
            {
                node = q.front(); q.pop();
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
            res.push_back(node->val);
        }

        return res;
    }
};
```

**前序遍历：**

https://leetcode.cn/problems/binary-tree-right-side-view/?envType=study-plan-v2&envId=top-interview-150

```c++
class Solution {
private:
    int max_depth = 0;
    vector<int> res;

    void dfs(TreeNode* node, int depth)
    {
        if (!node) return;

        if (depth > max_depth)
        {
            max_depth = depth;
            res.push_back(node->val);
        }
        
        ++depth;
        dfs(node->right, depth);
        dfs(node->left, depth);
    }

public:
    vector<int> rightSideView(TreeNode* root) {
        dfs(root, 1);
        return res;
    }
};
```

### 二叉树的层平均值

题目：[二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

```c++
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        vector<double> res;
        queue<TreeNode*> q; q.push(root);
        while (q.size())
        {
            double sum = 0;
            int size = q.size();
            for (int i = size; i > 0; i--)
            {
                auto node = q.front(); q.pop();
                sum += node->val;
                auto l = node->left, r = node->right;
                if (l) q.push(l);
                if (r) q.push(r);
            }
            res.push_back(sum / size);
        }
        
        return res;
    }
};
```

### 二叉树的层序遍历

题目：[二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if (!root) return res;

        queue<TreeNode*> q; q.push(root);
        while (q.size())
        {
            vector<int> tmp; tmp.reserve(q.size());
            for (int i = q.size(); i > 0; i--)
            {
                auto node = q.front(); q.pop();
                tmp.push_back(node->val);
                auto l = node->left, r = node->right;
                if (l) q.push(l);
                if (r) q.push(r);
            }
            res.push_back(tmp);
        }

        return res;
    }
};
```

### 二叉树的锯齿形层序遍历

题目：[二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

```c++
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if (!root) return res;

        deque<TreeNode*> q; q.push_back(root);
        while (q.size())
        {
            vector<int> line;
            if (res.size() % 2 == 0)
            {
                for (int i = q.size(); i > 0; i--)
                {
                    auto node = q.front(); q.pop_front();
                    line.push_back(node->val);
                    auto l = node->left, r = node->right;
                    if (l) q.push_back(l);
                    if (r) q.push_back(r);
                }
            }
            else
            {
                for (int i = q.size(); i > 0; i--)
                {
                    auto node = q.back(); q.pop_back();
                    line.push_back(node->val);
                    auto l = node->left, r = node->right;
                    if (r) q.push_front(r);
                    if (l) q.push_front(l);
                }
            }
            res.push_back(line);
        }

        return res;
    }
};
```

## 二叉搜索树

### 二叉搜索树的最小绝对差

题目：[二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)

```c++
class Solution {
public:

    int getMinimumDifference(TreeNode* root) {
        int res = 1e5, pre = -1e5;
        stack<TreeNode*> stk;
        auto cur = root;
        while (cur || stk.size())
        {
            while (cur)
            {
                stk.push(cur);
                cur = cur->left;
            }
            
            cur = stk.top(); stk.pop();
            res = min(res, cur->val - pre);
            pre = cur->val;

            cur = cur->right;
        }
        return res;
    }
};
```

### 二叉搜索树中第K小的元素

题目：[二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

```c++
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        stack<TreeNode*> stk;
        auto cur = root;
        while (cur || stk.size())
        {
            while (cur)
            {
                stk.push(cur);
                cur = cur->left;
            }

            cur = stk.top(); stk.pop();
            if (--k == 0) return cur->val;

            cur = cur->right; 
        }
        
        return -1;
    }
};
```

### 验证二叉搜索树

题目：[验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

```c++
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        int64_t pre_val = -1e10;
        stack<TreeNode*> stk;
        auto cur = root;
        while (cur || stk.size())
        {
            while (cur)
            {
                stk.push(cur);
                cur = cur->left;
            }

            cur = stk.top(); stk.pop();
            if (cur->val <= pre_val) return false;
            pre_val = cur->val;

            cur = cur->right;
        }

        return true;
    }
};
```

## 图

### 岛屿数量

题目：[岛屿数量](https://leetcode.cn/problems/number-of-islands/)

**深度优先搜索：**

```c++
class Solution {
private:
    void dfs(vector<vector<char>>& grid, int x, int y)
    {
        if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size()) return;

        if (grid[x][y] != '1') return;

        grid[x][y] = '3';
        int dx[] = { -1, 1, 0, 0 }, dy[] = { 0, 0, -1, 1 };
        for (int i = 0; i < 4; i++) dfs(grid, x + dx[i], y + dy[i]);
    }

public:
    int numIslands(vector<vector<char>>& grid) {
        int n = grid.size(), m = grid[0].size();
        int cnt = 0;
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                if (grid[i][j] == '1')
                {
                    cnt++;
                    dfs(grid, i, j);
                }
        
        return cnt;
    }
};
```

**广度优先搜索：**

```c++
class Solution {
private:
    int n = 0, m = 0;
    int dx[4] = { -1, 1, 0, 0 }, dy[4] = { 0, 0, -1, 1 };

    void bfs(vector<vector<char>>& grid, int x, int y)
    {
        queue<pair<int, int>> q;
        grid[x][y] = '3'; q.push({ x, y });
        while (q.size())
        {
            auto item = q.front(); q.pop();
            x = item.first, y = item.second;
            for (int i = 0; i < 4; i++)
            {
                int nx = x + dx[i], ny = y + dy[i];
                if (nx < 0 || nx >= grid.size() || ny < 0 || ny >= grid[0].size()) continue;
                if (grid[nx][ny] != '1') continue;
                grid[nx][ny] = '3'; q.push({ nx, ny });
            }
        }
    }

public:
    int numIslands(vector<vector<char>>& grid) {
        n = grid.size(), m = grid[0].size();
        int cnt = 0;
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                if (grid[i][j] == '1')
                {
                    cnt++;
                    bfs(grid, i,  j);
                }
        return cnt;
    }
};
```

### 被围绕的区域

题目：[被围绕的区域](https://leetcode.cn/problems/surrounded-regions/)

**深度优先搜索：**

```c++
class Solution {
private:
    int n = 0, m = 0;
    int dx[4] = { -1, 1, 0, 0 }, dy[4] = { 0, 0, -1, 1 };

    void dfs(vector<vector<char>>& board, int x, int y)
    {
        if (x < 0 || x >= n) return;
        if (y < 0 || y >= m) return;
        if (board[x][y] != 'O') return;

        board[x][y] = 'A';
        for (int i = 0; i < 4; i++) dfs(board, x + dx[i], y + dy[i]);
    }

public:
    void solve(vector<vector<char>>& board) {
        n = board.size(), m = board[0].size();
        
        for (int i = 0; i < n; i++)
        {
            dfs(board, i, 0); 
            dfs(board, i, m - 1);
        }
        for (int j = 0; j < m; j++)
        {
            dfs(board, 0, j);
            dfs(board, n - 1, j);
        }

        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                if      (board[i][j] == 'A') board[i][j] = 'O';
                else if (board[i][j] == 'O') board[i][j] = 'X';
    }
};
```

**广度优先遍历：**

```c++
class Solution {
private:
    int n = 0, m = 0;
    int dx[4] = { -1, 1, 0, 0 }, dy[4] = { 0, 0, -1, 1 };

    void bfs(vector<vector<char>>& board, int x, int y)
    {
        queue<pair<int, int>> q;
        board[x][y] = 'A'; q.push({ x, y });
        while (q.size())
        {
            auto item = q.front(); q.pop();
            x = item.first, y = item.second;
            for (int i = 0; i < 4; i++)
            {
                int nx = x + dx[i], ny = y + dy[i];
                if (nx < 0 || nx >= n) continue;
                if (ny < 0 || ny >= m) continue;
                if (board[nx][ny] != 'O') continue;
                board[nx][ny] = 'A';
                q.push({ nx, ny });
            }
        }
    }

public:
    void solve(vector<vector<char>>& board) {
        n = board.size(), m = board[0].size();
        for (int i = 0; i < n; i++)
        {
            if (board[i][0] == 'O') bfs(board, i, 0);
            if (board[i][m - 1] == 'O') bfs(board, i, m - 1);
        }
        for (int j = 0; j < m; j++)
        {
            if (board[0][j] == 'O') bfs(board, 0, j);
            if (board[n - 1][j] == 'O') bfs(board, n - 1, j);
        }
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
            {
                char& x = board[i][j];
                if      (x == 'A') x = 'O';
                else if (x == 'O') x = 'X';
            }
    }
};
```

### 克隆图

题目：[克隆图](https://leetcode.cn/problems/clone-graph/)

**题解：**

https://leetcode.cn/problems/clone-graph/solutions/370663/ke-long-tu-by-leetcode-solution/?envType=study-plan-v2&envId=top-interview-150

**深度优先遍历：**

```c++
class Solution {
private:
    unordered_map<Node*, Node*> map;

public:
    Node* cloneGraph(Node* node) {
        if (!node) return nullptr;

        auto it = map.find(node);
        if (it != map.end()) return it->second;

        auto clone_node = new Node(node->val);
        map[node] = clone_node;
        auto& vec = clone_node->neighbors;
        for (auto ptr : node->neighbors) vec.push_back(cloneGraph(ptr));

        return clone_node;
    }
};
```

**广度优先遍历：**

本做法必须要理解，加入队列前必须对结点标记，取出结点后复制它们的邻接关系。

```c++
class Solution {
public:
    Node* cloneGraph(Node* node) {
        if (!node) return nullptr;

        unordered_map<Node*, Node*> map;
        auto clone_node = new Node(node->val);
        map[node] = clone_node;
        queue<Node*> q; q.push(node);
        while (q.size())
        {
            auto ptr = q.front(); q.pop();
            auto& vec = map[ptr]->neighbors;
            for (auto nb : ptr->neighbors)
            {
                auto it = map.find(nb);
                if (it != map.end()) vec.push_back(it->second);
                else
                {
                    auto tmp = new Node(nb->val);
                    map[nb] = tmp;
                    vec.push_back(tmp);
                    q.push(nb);
                }
            }
        }

        return clone_node;
    }
};
```

### 除法求值

题目：[除法求值](https://leetcode.cn/problems/evaluate-division/)

题解：https://www.acwing.com/video/1795/

```c++
class Solution {
public:
    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {
        int n = equations.size();
        unordered_set<string> vers;
        unordered_map<string, unordered_map<string, double>> d;
        for (int i = 0; i < n; i++)
        {
            auto a = equations[i][0], b = equations[i][1];
            auto c = values[i];
            vers.insert(a); vers.insert(b);
            d[a][b] = c; d[b][a] = 1 / c;
        }

        for (auto k : vers)
            for (auto i : vers)
                for (auto j : vers)
                    if (d[i][k] && d[k][j])
                        d[i][j] = d[i][k] * d[k][j];

        vector<double> res;
        for (auto vec : queries)
        {
            auto a = vec[0], b = vec[1];
            if (d[a][b]) res.push_back(d[a][b]);
            else res.push_back(-1);
        }

        return res;
    }
};
```

### 课程表

题目：[课程表](https://leetcode.cn/problems/course-schedule/)

题解：https://www.acwing.com/video/1585/

```c++
class Solution {
public:
    bool canFinish(int n, vector<vector<int>>& edges) {
        vector<vector<int>> g(n);
        vector<int> in(n);
        for (auto& edge : edges)
        {
            int a = edge[1], b = edge[0];
            g[a].push_back(b);
            in[b]++;
        }

        queue<int> q;
        for (int i = 0; i < n; i++)
            if (!in[i]) q.push(i);

        int cnt = 0;
        while (q.size())
        {
            cnt++;
            auto v = q.front(); q.pop();
            for (auto tmp : g[v])
                if (--in[tmp] == 0) q.push(tmp);
        }

        return cnt == n;
    }
};
```

### 课程表 II

题目：[课程表 II](https://leetcode.cn/problems/course-schedule-ii/)

```c++
class Solution {
public:
    vector<int> findOrder(int n, vector<vector<int>>& edges) {
        vector<vector<int>> g(n);
        vector<int> in(n);
        for (auto& vec : edges)
        {
            int a = vec[1], b = vec[0];
            g[a].push_back(b);
            in[b]++;
        }

        queue<int> q;
        for (int i = 0; i < n; i++)
            if (!in[i]) q.push(i);

        vector<int> res;
        while (q.size())
        {
            auto v = q.front(); q.pop();
            res.push_back(v);
            for (auto tmp : g[v])
                if (--in[tmp] == 0) q.push(tmp);
        }
        if (res.size() < n) res.clear();
        return res;
    }
};
```

## 图的广度优先搜索

### 蛇梯棋

题目：[蛇梯棋](https://leetcode.cn/problems/snakes-and-ladders/)

题解：https://www.acwing.com/video/3113/

```c++
#define x first
#define y second

typedef pair<int, int> PII;

class Solution {
public:
	int snakesAndLadders(vector<vector<int>>& board) {
		int n = board.size(), ter = n * n;
		vector<vector<int>> id(n, vector<int>(n));
		vector<PII> cor(ter + 1);
		for (int i = n - 1, s = 1, k = 0; i >= 0; i--, s *= -1)
			for (int j = s > 0 ? 0 : n - 1; j >= 0 && j < n; j += s)
			{
				k++;
				id[i][j] = k;
				cor[k] = { i, j };
			}

		vector<int> dist(ter + 1, -1);
		queue<int> q;
		dist[1] = 0; q.push(1);
		while (q.size())
		{
			auto tmp = q.front(); q.pop();
			for (int k = tmp + 1; k <= ter && k <= tmp + 6; k++)
			{
				int x = cor[k].x, y = cor[k].y;
				if (board[x][y] == -1)
				{
					if (dist[k] != -1) continue;
					dist[k] = dist[tmp] + 1;
					q.push(k);
				}
				else
				{
					int nk = board[x][y];
					if (dist[nk] != -1) continue;
					dist[nk] = dist[tmp] + 1;
					q.push(nk);
				}
			}
		}
		return dist[ter];
	}
};
```

### 最小基因变化

题目：[最小基因变化](https://leetcode.cn/problems/minimum-genetic-mutation/)

```c++
class Solution {
public:
    inline bool judge(string& a, string& b)
    {
        int cnt = 0;
        for (int i = 0; i < 8; i++)
            if (a[i] != b[i]) cnt++;
        return cnt == 1;
    }

    int minMutation(string start, string end, vector<string>& bank) {
        bank.push_back(start);
        int n = bank.size();
        unordered_map<string, int> idx;
        for (int i = 0; i < n; i++) idx[bank[i]] = i;
        
        if (!idx.count(end)) return -1;

        vector<vector<int>> g(n);
        for (int i = 0; i < n; i++)
            for (int j = i + 1; j < n; j++)
                if (judge(bank[i], bank[j]))
                {
                    g[i].push_back(j);
                    g[j].push_back(i);
                }

        int start_idx = idx[start], end_idx = idx[end];
        vector<int> is_visited(n);
        queue<int> q;
        is_visited[start_idx] = 1; q.push(start_idx);
        int cnt = 0;
        while (q.size())
        {
            for (int i = q.size(); i > 0; i--)
            {
                auto cur = q.front(); q.pop();
                if (cur == end_idx) return cnt;
                for (auto nxt : g[cur])
                {
                    if (is_visited[nxt]) continue;
                    is_visited[nxt] = 1;
                    q.push(nxt);
                }
            }
            cnt++;
        }

        return -1;
    }
};
```

### 单词接龙

题目：[单词接龙](https://leetcode.cn/problems/word-ladder/)

```c++
class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        unordered_set<string> S;
        for (auto& s : wordList) S.insert(s);
        unordered_map<string, int> dist;
        dist[beginWord] = 1;
        queue<string> q; q.push(beginWord);
        while (q.size())
        {
            auto t = q.front(); q.pop();
            int dt = dist[t];
            for (int i = t.size() - 1; i >= 0; i--)
                for (char c = 'a'; c <= 'z'; c++)
                {
                    if (t[i] == c) continue;
                    auto nxt = t; nxt[i] = c;
                    if (S.count(nxt) && !dist[nxt])
                    {
                        if (nxt == endWord) return dt + 1;
                        dist[nxt] = dt + 1;
                        q.push(nxt);
                    }
                }
        }

        return 0;
    }
};
```

## 字典树

### 实现 Trie (前缀树)

题目：[实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

题解：https://www.acwing.com/video/2784/

```c++
class Trie {
public:
    struct Node
    {
        Node* son[26];
        bool is_end;

        Node()
        {
            for (auto& s : son) s = nullptr;
            is_end = false;
        }
    }* root;

    Trie() {
        root = new Node();
    }
    
    void insert(string word) {
        Node* cur = root;
        for (char c : word)
        {
            int p = c - 'a';
            if (!cur->son[p]) cur->son[p] = new Node();
            cur = cur->son[p];
        }
        cur->is_end = true;
    }
    
    bool search(string word) {
        Node* cur = root;
        for (char c : word)
        {
            int p = c - 'a';
            if (!cur->son[p]) return false;
            cur = cur->son[p];
        }
        return cur->is_end;
    }
    
    bool startsWith(string prefix) {
        Node* cur = root;
        for (char c : prefix)
        {
            int p = c - 'a';
            if (!cur->son[p]) return false;
            cur = cur->son[p];
        }
        return true;
    }
};
```

### 添加与搜索单词 - 数据结构设计

题目：[添加与搜索单词 - 数据结构设计](https://leetcode.cn/problems/design-add-and-search-words-data-structure/)

```c++
class WordDictionary {
public:

    struct Node
    {
        Node* son[26];
        bool is_end;

        Node()
        {
            for (int i = 0; i < 26; i++) son[i] = nullptr;
            is_end = false;
        }
    }* root;

    WordDictionary() {
        root = new Node();
    }
    
    void addWord(string word) {
        auto cur = root;
        for (char c : word)
        {
            int idx = c - 'a';
            if (!cur->son[idx]) cur->son[idx] = new Node();
            cur = cur->son[idx];
        }
        cur->is_end = true;
    }
    
    bool search(string word) {
        return search(word, root, 0);
    }

    bool search(string& s, Node* cur, int start)
    {
        if (start == s.size()) return cur->is_end;

        char c = s[start];
        if (c != '.')
        {
            int idx = c - 'a';
            if (!cur->son[idx]) return false;
            return search(s, cur->son[idx], start + 1);
        }
        else
        {
            for (char idx = 0; idx < 26; idx++)
                if (cur->son[idx] && search(s, cur->son[idx], start + 1))
                    return true;
            
            return false;
        }
    }
};
```

### 单词搜索 II

题目：[单词搜索 II](https://leetcode.cn/problems/word-search-ii/)

题解：https://www.acwing.com/video/1582/

```c++
class Solution {
public:
    struct Node
    {
        int id;
        Node* son[26];

        Node()
        {
            id = -1;
            for (int i = 0; i < 26; i++) son[i] = nullptr;
        }
    }* root;

    void insert(string& s, int id)
    {
        Node* cur = root;
        for (char c : s)
        {
            int u = c - 'a';
            if (!cur->son[u]) cur->son[u] = new Node();
            cur = cur->son[u];
        }
        cur->id = id;
    }

    unordered_set<int> ids;

    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
        root = new Node();
        for (int i = 0; i < words.size(); i++) insert(words[i], i);

        int n = board.size(), m = board[0].size();
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
            {
                int u = board[i][j] - 'a';
                if (root->son[u]) dfs(board, root->son[u], i, j);
            }

        vector<string> res;
        for (int id : ids) res.push_back(words[id]);
        return res;
    }

    int dx[4] = { -1, 1, 0, 0 }, dy[4] = { 0, 0, -1, 1 };
    void dfs(vector<vector<char>>& board, Node* cur, int x, int y)
    {
        if (cur->id != -1) ids.insert(cur->id);

        char tmp = board[x][y];
        board[x][y] = '.';
        for (int i = 0; i < 4; i++)
        {
            int nx = x + dx[i], ny = y + dy[i];
            if (nx < 0 || nx >= board.size() || ny < 0 || ny >= board[0].size()) continue;
            if (board[nx][ny] == '.') continue;
            int u = board[nx][ny] - 'a';
            if (cur->son[u]) dfs(board, cur->son[u], nx, ny);
        }
        board[x][y] = tmp;
    }
};
```

## 回溯

### 电话号码的字母组合

题目：[电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

```c++
class Solution {
public:
    string map[10] = { "", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz" };

    vector<string> letterCombinations(string digits) {
        int n = digits.size();
        vector<string> res;
        if (n == 0) return res;

        string path(n, '\0');
        function<void(int)> dfs = [&](int i)
            {
                if (i == n)
                {
                    res.push_back(path);
                    return;
                }

                for (char c : map[digits[i] - '0'])
                {
                    path[i] = c;
                    dfs(i + 1);
                }
            };
        dfs(0);
        return res;
    }
};
```

### 组合

题目：[组合](https://leetcode.cn/problems/combinations/)

**题解：**

https://leetcode.cn/problems/combinations/solutions/2071017/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-65lh/?envType=study-plan-v2&envId=top-interview-150

**传递当前可选对象：**

```c++
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> res;
        vector<int> path;
        function<void(int)> dfs = [&](int i)
            {
                int d = k - path.size();
                if (!d)
                {
                    res.push_back(path);
                    return;
                }

                for (int j = d; j <= i; j++)
                {
                    path.push_back(j);
                    dfs(j - 1);
                    path.pop_back();
                }
            };
        dfs(n);
        return res;
    }
};
```

**传递选择位置：**

```c++
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> res;
        vector<int> path(k);
        function<void(int)> dfs = [&](int i)
            {
                if (i == k)
                {
                    res.push_back(path);
                    return;
                }

                int mx = n - (k - i) + 1; // 剪枝
                int j = i ? path[i - 1] + 1 : 1; // 维持单增
                for (; j <= mx; j++)
                {
                    path[i] = j;
                    dfs(i + 1);
                }
            };
        dfs(0);
        return res;
    }
};
```

### 全排列

题目：[全排列](https://leetcode.cn/problems/permutations/)

```c++
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> res;
        vector<int> path(n);
        vector<bool> on_path(n);
        function<void(int)> dfs = [&](int i)
            {
                if (i == n)
                {
                    res.push_back(path);
                    return;
                }

                for (int j = 0; j < n; j++)
                {
                    if (on_path[j]) continue;
                    on_path[j] = true;
                    path[i] = nums[j];
                    dfs(i + 1);
                    on_path[j] = false;
                }
            };
        dfs(0);
        return res;
    }
};
```

### 组合总和

题目：[组合总和](https://leetcode.cn/problems/combination-sum/)

```c++
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        int n = candidates.size();
        sort(candidates.begin(), candidates.end());
        vector<vector<int>> res;
        vector<int> path;
        int sum = 0;
        function<void(int)> dfs = [&](int i)
            {
                if (sum >= target || i == n)
                {
                    if (sum == target) res.push_back(path);
                    return;
                }

                int num = candidates[i];
                int mx = (target - sum) / candidates[i];
                int tmp = sum;
                for (int j = 1; j <= mx; j++)
                {
                    sum += num;
                    path.push_back(candidates[i]);
                    dfs(i + 1);
                }
                for (int j = 1; j <= mx; j++) path.pop_back();
                sum = tmp;

                dfs(i + 1); // 不选
            };

        dfs(0);
        return res;
    }
};
```

### N 皇后 II

题目：[N 皇后 II](https://leetcode.cn/problems/n-queens-ii/)

```c++
class Solution {
public:
    int totalNQueens(int n) {
        bitset<9> col;
        bitset<9 * 2> dg, bdg;
        int cnt = 0;
        function<void(int)> dfs = [&](int i)
            {
                if (i == n) { cnt++; return; }

                for (int j = 0; j < n; j++)
                {
                    int idg = i + j, ibdg = n - i + j - 1;
                    if (col[j] || dg[idg] || bdg[ibdg]) continue;
                    col[j] = dg[idg] = bdg[ibdg] = 1;
                    dfs(i + 1);
                    col[j] = dg[idg] = bdg[ibdg] = 0;
                }
            };
        
        dfs(0);
        return cnt;
    }
};
```

### 括号生成

题目：[括号生成](https://leetcode.cn/problems/generate-parentheses/)

```c++
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        int n_2 = n * 2;
        vector<string> res;
        string path(n_2, '\0');
        int l = 0, r = 0;
        function<void(int)> dfs = [&](int i)
            {
                if (i == n_2)
                {
                    res.push_back(path);
                    return;
                }

                if (l < n) // 左括号
                {
                    path[i] = '(';
                    l++;
                    dfs(i + 1);
                    l--;
                }
                if (r < l) // 右括号
                {
                    path[i] = ')';
                    r++;
                    dfs(i + 1);
                    r--;
                }
            };

        dfs(0);
        return res;
    }
};
```

### 单词搜索

题目：[单词搜索](https://leetcode.cn/problems/word-search/)

```c++
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        int n = board.size(), m = board[0].size();
        int len = word.size();

        int dx[] = { -1, 1, 0, 0 }, dy[] = { 0, 0, -1, 1 };
        function<bool(int, int, int)> dfs = [&](int i, int x, int y)->bool
            {
                if (i == len) return true;

                if (x < 0 || x >= n || y < 0 || y >= m) return false;
                if (board[x][y] != word[i] || !board[x][y]) return false;

                board[x][y] = '\0';
                bool res = false;
                for (int j = 0; j < 4; j++) 
                    res |= dfs(i + 1, x + dx[j], y + dy[j]);
                board[x][y] = word[i];
                return res;
            };

        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                if (dfs(0, i, j)) return true;
        return false;
    }
};
```

## 分治

### 将有序数组转换为二叉搜索树

题目：[将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

```c++
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        int n = nums.size();
        function<TreeNode*(int, int)> dfs = [&](int l, int r)->TreeNode*
            {
                if (l > r) return nullptr;

                int mid = l + r >> 1;
                auto cur = new TreeNode(nums[mid]);
                cur->left = dfs(l, mid - 1);
                cur->right = dfs(mid + 1, r);

                return cur;
            };

        return dfs(0, n - 1);
    }
};
```

### 排序链表

题目：[排序链表](https://leetcode.cn/problems/sort-list/)

思路：仿照数组递归排序的非递归实现

```c++
class Solution
{
public:
    ListNode *sortList(ListNode *head)
    {
        int n = 0;
        for (auto p = head; p; p = p->next)
            n++;

        auto dum = new ListNode(0, head);
        for (int len = 1; len < n; len *= 2)
        {
            auto pre = dum, nxt = dum;
            auto l = dum->next, r = dum->next;
            for (int i = 0, j = len; j < n; i += len, j += len)
            {
                int a = i + len, b = min(j + len, n);
                for (int k = i; k < a; k++)
                    r = r->next;
                nxt = r;
                for (int k = j; k < b; k++)
                    nxt = nxt->next;
                auto p = pre;
                while (i < a && j < b)
                {
                    if (l->val < r->val)
                    {
                        p->next = l;
                        l = l->next;
                        i++;
                    }
                    else
                    {
                        p->next = r;
                        r = r->next;
                        j++;
                    }
                    p = p->next;
                }
                while (i < a)
                {
                    p->next = l;
                    l = l->next;
                    p = p->next;
                    i++;
                }
                while (j < b)
                {
                    p->next = r;
                    r = r->next;
                    p = p->next;
                    j++;
                }
                p->next = nxt;
                pre = p;
                l = r = nxt;
            }
        }
        return dum->next;
    }
};
```

### 建立四叉树

题目：[建立四叉树](https://leetcode.cn/problems/construct-quad-tree/)

```c++
class Solution
{
public:
    Node *construct(vector<vector<int>> &g)
    {
        int n = g.size();
        vector<vector<int>> ps(n + 1, vector<int>(n + 1));
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                ps[i + 1][j + 1] = ps[i + 1][j] + ps[i][j + 1] - ps[i][j] + g[i][j];

        function<Node *(int, int, int, int)> dfs = [&](int x1, int y1, int x2, int y2) -> Node *
        {
            int sum = ps[x2 + 1][y2 + 1] - ps[x2 + 1][y1] - ps[x1][y2 + 1] + ps[x1][y1];
            if (!sum || sum == (x2 - x1 + 1) * (y2 - y1 + 1))
                return new Node(g[x1][y1], true);

            int mx = x1 + x2 >> 1, my = y1 + y2 >> 1;
            auto tl = dfs(x1, y1, mx, my);
            auto tr = dfs(x1, my + 1, mx, y2);
            auto bl = dfs(mx + 1, y1, x2, my);
            auto br = dfs(mx + 1, my + 1, x2, y2);

            return new Node(g[x1][y1], false, tl, tr, bl, br);
        };

        return dfs(0, 0, n - 1, n - 1);
    }
};
```

### 合并 K 个升序链表

题目：[合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

**优先队列：**

```c++
class Solution
{
public:
    ListNode *mergeKLists(vector<ListNode *> &lists)
    {
        typedef pair<int, ListNode *> PIL;
        priority_queue<PIL, vector<PIL>, greater<PIL>> heap;
        for (auto node : lists)
            if (node)
                heap.push({node->val, node});

        auto dum = new ListNode();
        auto p = dum;
        while (!heap.empty())
        {
            auto tmp = heap.top();
            heap.pop();
            auto node = tmp.second;
            p->next = node;
            p = node;
            node = node->next;
            if (node)
                heap.push({node->val, node});
        }
        return dum->next;
    }
};
```

**分治：**

```c++
class Solution
{
public:
    ListNode *mergeKLists(vector<ListNode *> &lists)
    {
        int n = lists.size();
        if (!n) return nullptr;
        
        function<ListNode *(int, int)> dfs = [&](int l, int r)
        {
            if (l >= r) return lists[l];

            int mid = l + r >> 1;
            auto l1 = dfs(l, mid), l2 = dfs(mid + 1, r);
            auto dum = new ListNode();
            auto p = dum;
            while (l1 && l2)
            {
                if (l1->val < l2->val)
                {
                    p->next = l1;
                    l1 = l1->next;
                }
                else
                {
                    p->next = l2;
                    l2 = l2->next;
                }
                p = p->next;
            }
            while (l1 || l2)
            {
                p->next = l1 ? l1 : l2;
                l1 = l1 ? l1->next : l1;
                l2 = l2 ? l2->next : l2;
                p = p->next;
            }
            return dum->next;
        };

        return dfs(0, n - 1);
    }
};
```

## Kadane 算法

### 最大子数组和

题目：[最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

**动态规划：**

```c++
class Solution
{
public:
    int maxSubArray(vector<int> &nums)
    {
        int n = nums.size();
        const int INF = 1e5;
        int cur = nums[0], res = nums[0];
        for (int i = 1; i < n; i++)
        {
            cur = max(nums[i], cur + nums[i]);
            res = max(res, cur);
        }
        return res;
    }
};
```

**分治：**

```c++
class Solution
{
public:
    struct Seg
    {
        int ls, rs, ss, sum;
    };
    
    Seg build(vector<int>&nums, int l, int r)
    {
        if (l == r) return { nums[l], nums[l], nums[l], nums[l] };

        int mid = l + r >> 1;
        Seg sl = build(nums, l, mid);
        Seg sr = build(nums, mid + 1, r);

        int ls = max(sl.ls, sl.sum + sr.ls);
        int rs = max(sr.rs, sr.sum + sl.rs);
        int ss = max({sl.ss, sr.ss, sl.rs + sr.ls});
        int sum = sl.sum + sr.sum;

        return {ls, rs, ss, sum};
    }

    int maxSubArray(vector<int> &nums)
    {
        int n = nums.size();
        Seg res = build(nums, 0, n - 1);
        return res.ss;
    }
};
```

### 环形子数组的最大和

题目：[环形子数组的最大和](https://leetcode.cn/problems/maximum-sum-circular-subarray/)

**单调队列：**

https://www.acwing.com/video/3137/

```c++
class Solution {
public:
    int maxSubarraySumCircular(vector<int>& nums) {
        int n = nums.size();
        int n_2 = n * 2;
        vector<int> ps(n_2 + 1);
        for (int i = 1; i < ps.size(); i++)
            ps[i] = ps[i - 1] + nums[(i - 1) % n];
        
        deque<int> q; q.push_back(0);
        int res = INT_MIN;
        for (int i = 1; i <= n_2; i++)
        {
            while (!q.empty() && i - q.front() > n) q.pop_front();
            if (i >= n) res = max(res, ps[i] - ps[q.front()]);
            while (!q.empty() && ps[q.back()] >= ps[i]) q.pop_back();
            q.push_back(i);
        }
        return res;
    }
};
```

**灵神的解法：**

https://leetcode.cn/problems/maximum-sum-circular-subarray/solutions/2351107/mei-you-si-lu-yi-zhang-tu-miao-dong-pyth-ilqh/?envType=study-plan-v2&envId=top-interview-150

```c++
class Solution {
public:
    int maxSubarraySumCircular(vector<int>& nums) {
        int sum = 0;
        int max_f = 0, max_s = INT_MIN;
        int min_f = 0, min_s = INT_MAX;
        for (int num : nums)
        {
            sum += num;
            max_f = max(max_f, 0) + num;
            max_s = max(max_s, max_f);

            min_f = min(num, min_f + num);
            min_s = min(min_s, min_f);
        }
        return min_s == sum ? max_s : max(max_s, sum - min_s);
    }
};
```

## 二分查找

### 搜索插入位置

[搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

```c++
class Solution
{
public:
    int searchInsert(vector<int> &nums, int target)
    {
        int n = nums.size();
        int l = 0, r = n - 1;
        while (l <= r)
        {
            int mid = l + r >> 1;
            if (nums[mid] >= target) r = mid - 1;
            else l = mid + 1;
        }
        
        return l;
    }
};
```

### 搜索二维矩阵

题目：[搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/)

**两次二分：**

```c++
class Solution
{
public:
    bool searchMatrix(vector<vector<int>> &matrix, int x)
    {
        int n = matrix.size(), m = matrix[0].size();
        int l = 0, r = n - 1;
        while (l < r)
        {
            int mid = l + r + 1 >> 1;
            if (matrix[mid][0] <= x) l = mid;
            else r = mid - 1;
        }
        int row = l;
        l = 0, r = m - 1;
        while (l < r)
        {
            int mid = l + r >> 1;
            if (matrix[row][mid] >= x) r = mid;
            else l = mid + 1;
        }
        return matrix[row][l] == x;
    }
};
```

**一次二分（改循环条件）：**

```c++
class Solution
{
public:
    bool searchMatrix(vector<vector<int>> &matrix, int x)
    {
        int n = matrix.size(), m = matrix[0].size();
        int l = 0, r = n * m - 1;
        while (l <= r)
        {
            int mid = l + r >> 1;
            int row = mid / m, col = mid % m;
            if (matrix[row][col] > x) r = mid - 1;
            else if (matrix[row][col] < x) l = mid + 1;
            else return true;
        }
        return false;
    }
};
```

**一次二分：**

```c++
class Solution
{
public:
    bool searchMatrix(vector<vector<int>> &matrix, int x)
    {
        int n = matrix.size(), m = matrix[0].size();
        int l = 0, r = n * m - 1;
        int row = 0, col = 0;
        while (l < r)
        {
            int mid = l + r >> 1;
            row = mid / m, col = mid % m;
            if (matrix[row][col] >= x) r = mid;
            else l = mid + 1;
        }
        row = (l + r >> 1) / m, col = (l + r >> 1) % m;
        return matrix[row][col] == x;
    }
};
```

### 寻找峰值

题目：[寻找峰值](https://leetcode.cn/problems/find-peak-element/)

```c++
class Solution
{
public:
    int findPeakElement(vector<int> &nums)
    {
        int n = nums.size();
        int l = 0, r = n - 1;
        while (l < r)
        {
            int mid = l + r >> 1;
            if (nums[mid] > nums[mid + 1]) r = mid;
            else l = mid + 1;
        }
        return l;
    }
};
```

### 搜索旋转排序数组

题目：[搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

```c++
class Solution
{
public:
    int search(vector<int> &nums, int target)
    {
        int n = nums.size();
        int l = 0, r = n - 1;
        while (l < r)
        {
            int mid = l + r + 1 >> 1;
            if (nums[mid] >= nums[0]) l = mid;
            else r = mid - 1;
        }

        if (target >= nums[0]) l = 0;
        else l += 1, r = n - 1; // l可能会越界，所以返回必须是r
        while (l < r)
        {
            int mid = l + r >> 1;
            if (nums[mid] >= target) r = mid;
            else l = mid + 1;
        }
        return nums[r] == target ? l : -1;
    }
};
```

### 在排序数组中查找元素的第一个和最后一个位置

题目：[在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

```c++
class Solution
{
public:
    vector<int> searchRange(vector<int> &nums, int target)
    {
        int n = nums.size();
        if (!n) return {-1, -1};

        int l = 0, r = n - 1;
        while (l < r)
        {
            int mid = l + r >> 1;
            if (nums[mid] >= target) r = mid;
            else l = mid + 1;
        }
        if (nums[l] != target) return {-1, -1};
        int tmp = l;
        l = 0, r = n - 1;
        while (l < r)
        {
            int mid = l + r + 1 >> 1;
            if (nums[mid] <= target) l = mid;
            else r = mid - 1;
        }
        return {tmp, l};
    }
};
```

### 寻找旋转排序数组中的最小值

题目：[寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)

```c++
class Solution
{
public:
    int findMin(vector<int> &nums)
    {
        int n = nums.size();
        int l = 0, r = n - 1;
        while (l < r)
        {
            int mid = l + r + 1 >> 1;
            if (nums[mid] >= nums[0]) l = mid;
            else r = mid - 1;
        }
        return l == n - 1 ? nums[0] : nums[l + 1];
    }
};
```

### 寻找两个正序数组的中位数

题目：[寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

题解：https://www.acwing.com/solution/content/50/

```c++
class Solution
{
public:
    int find(vector<int>& A, int i, vector<int>& B, int j, int k)
    {
        if (A.size() - i > B.size() - j) return find(B, j, A, i, k);
        if (i == A.size()) return B[j + k - 1]; 
        if (k == 1) return min(A[i], B[j]);

        int ni = min(int(A.size()), i + k / 2) - 1;
        int nj = j + k - k / 2 - 1;
        if (A[ni] < B[nj]) return find(A, ni + 1, B, j, k - (ni + 1 - i));
        else return find(A, i, B, nj + 1, k - (nj + 1 - j));
    }

    double findMedianSortedArrays(vector<int> &nums1, vector<int> &nums2)
    {
        int tot = nums1.size() + nums2.size();
        if (tot % 2)
            return find(nums1, 0, nums2, 0, tot / 2 + 1);
        else
        {
            int l = find(nums1, 0, nums2, 0, tot / 2);
            int r = find(nums1, 0, nums2, 0, tot / 2 + 1);
            return (l + r) / 2.0;
        }
    }
};
```

## 堆

### 数组中的第K个最大元素

题目：[数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

**stl优先队列：**

```c++
class Solution
{
public:
    int findKthLargest(vector<int> &nums, int k)
    {
         priority_queue<int> q;
         for (int num : nums) q.push(num);

         while ((k--) > 1)
            q.pop();
        
        return q.top();
    }
};
```

**模拟堆：**

```c++
class Solution
{
public:
    vector<int> heap{0};

    void up(int u)
    {
        int p = u / 2;
        while (p && heap[p] < heap[u])
        {
            swap(heap[u], heap[p]);
            u = p, p = p / 2;
        }
    }

    void down(int u)
    {
        int n = heap.size();
        int l = u * 2, r = l + 1;
        while (l < n)
        {
            int mx = l;
            if (r < n && heap[r] > heap[l])
                mx = r;
            if (heap[u] >= heap[mx]) return;
            swap(heap[u], heap[mx]);
            u = mx;
            l = 2 * u, r = l + 1;
        }
    }

    int findKthLargest(vector<int> &nums, int k)
    {
        for (int num : nums)
        {
            heap.push_back(num);
            up(heap.size() - 1);
        }

        while ((k--) > 1)
        {
            swap(heap[1], heap.back());
            heap.pop_back();
            down(1);
        }

        return heap[1];
    }
};
```

### IPO

题目：[IPO](https://leetcode.cn/problems/ipo/)

```c++
class Solution
{
public:
    int findMaximizedCapital(int k, int w, vector<int> &profits, vector<int> &capital)
    {
        int n = profits.size();
        vector<pair<int, int>> c2p; c2p.reserve(n);
        for (int i = 0; i < n; i++)
            c2p.push_back({ capital[i], profits[i] });
        sort(c2p.begin(), c2p.end());
        priority_queue<int> q;
        int idx = 0;
        while (k--)
        {
            while (idx < n && c2p[idx].first <= w)
                q.push(c2p[idx++].second);
            if (q.empty()) break;
            auto p = q.top(); q.pop();
            w += p;
        }
        return w;
    }
};
```

### 查找和最小的 K 对数字

题目：[查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/)

**题解：**

https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/solutions/2868760/cong-ying-she-de-jiao-du-qu-li-jie-you-x-il5u/

```c++
typedef pair<int, int> PII;

class Solution
{
public:
    vector<vector<int>> kSmallestPairs(vector<int> &nums1, vector<int> &nums2, int k)
    {
        int n = nums1.size(), m = nums2.size();
        vector<int> ptr(n);
        priority_queue<PII, vector<PII>, greater<PII>> q;
        for (int i = 0; i < n; i++)
            q.push({ nums1[i] + nums2[0], i });

        vector<vector<int>> res;
        while (k--)
        {
            auto [val, i] = q.top(); q.pop();
            res.push_back({ nums1[i], nums2[ptr[i]] });
            if (++ptr[i] < m)
                q.push({ nums1[i] + nums2[ptr[i]], i });
        }
        return res;
    }
};
```

### 数据流的中位数

题目：[数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/)

```c++
class MedianFinder
{
public:
    const int INF = 1e5 + 10;

    priority_queue<int, vector<int>, less<int>> q1;
    priority_queue<int, vector<int>, greater<int>> q2;

    MedianFinder() 
    {
        q1.push(-INF); q2.push(INF);
    }

    void addNum(int num)
    {
        if (q1.size() > q2.size()) q2.push(num);
        else q1.push(num);
        if (q1.top() > q2.top())
        {
            q1.push(q2.top()); q2.pop();
            q2.push(q1.top()); q1.pop();
        }
    }

    double findMedian()
    {
        if (q1.size() == q2.size()) 
            return (q1.top() + q2.top()) / 2.0;
        return q1.top();
    }
};
```

## 位运算

### 二进制求和

题目：[二进制求和](https://leetcode.cn/problems/add-binary/)

**模拟：**

```c++
class Solution
{
public:
    string addBinary(string a, string b)
    {        
        string res;
        int i = a.size() - 1, j = b.size() - 1;
        int c = 0;
        while (i >= 0 || j >= 0)
        {
            int d = c;
            d += i >= 0 ? a[i--] - '0' : 0;
            d += j >= 0 ? b[j--] - '0' : 0;
            res += char(d % 2 + '0');
            c = d / 2;
        }
        if (c) res += char(c + '0');
        reverse(res.begin(), res.end());
        return res;
    }
};
```

### 颠倒二进制位

题目：[颠倒二进制位](https://leetcode.cn/problems/reverse-bits/)

**位运算：**

https://leetcode.cn/problems/reverse-bits/solutions/685436/dian-dao-er-jin-zhi-wei-by-leetcode-solu-yhxz

```c++
class Solution
{
public:
    const uint32_t M0 = 0x55555555;
    const uint32_t M1 = 0x33333333;
    const uint32_t M2 = 0x0f0f0f0f;
    const uint32_t M3 = 0x00ff00ff;

    uint32_t reverseBits(uint32_t n)
    {
        n = (n >> 1) & M0 | ((n & M0) << 1);
        n = (n >> 2) & M1 | ((n & M1) << 2);
        n = (n >> 4) & M2 | ((n & M2) << 4);
        n = (n >> 8) & M3 | ((n & M3) << 8);
        return n >> 16 | n << 16;
    }
};
```

### 位1的个数

题目：[位1的个数](https://leetcode.cn/problems/number-of-1-bits/)

**lowbit：**

```c++
class Solution
{
public:
    inline int lowbit(int x) { return x & (-x); };

    int hammingWeight(int n)
    {
        int cnt = 0;
        while (n)
        {
            n -= lowbit(n);
            cnt++;
        }
        return cnt;
    }
};
```

$n\&(n - 1)$：

```c++
class Solution
{
public:
    int hammingWeight(int n)
    {
        int cnt = 0;
        while (n)
        {
            n &= (n - 1);
            cnt++;
        }
        return cnt;
    }
};
```

### 只出现一次的数字

题目：[只出现一次的数字](https://leetcode.cn/problems/single-number/)

```c++
class Solution
{
public:
    int singleNumber(vector<int> &nums)
    {
        int res = 0;
        for (int num : nums) res ^= num;
        return res;
    }
};
```

### 只出现一次的数字 II

题目：[只出现一次的数字 II](https://leetcode.cn/problems/single-number-ii/)

```c++
class Solution
{
public:
    int singleNumber(vector<int> &nums)
    {
        int ones = 0, twos = 0;
        for (int num : nums)
        {
            twos ^= (ones & num);
            ones ^= num;
            int mask = ~(ones & twos);
            ones &= mask;
            twos &= mask;
        }
        return ones;
    }
};
```

### 数字范围按位与

题目：[数字范围按位与](https://leetcode.cn/problems/bitwise-and-of-numbers-range/)

```c++
class Solution
{
public:
    int rangeBitwiseAnd(int left, int right)
    {
        int res = 0;
        bitset<31> l(left), r(right);
        for (int i = 30; i >= 0; i--)
        {
            if (l[i] != r[i]) break;
            res += l[i] ? 1 << i : 0;
        }
        return res;
    }
};
```

## 数学

### 回文数

题目：[回文数](https://leetcode.cn/problems/palindrome-number/)

**题解：**

https://leetcode.cn/problems/palindrome-number/solutions/281686/hui-wen-shu-by-leetcode-solution

```c++
class Solution
{
public:
    bool isPalindrome(int x)
    {
        if (x < 0|| (x && x % 10 == 0)) return false;

        int y = 0;
        while (x > y)
        {
            y = y * 10 + x % 10;
            x /= 10;
        }
        return x == y || x == y / 10;
    }
};
```

### 加一

题目：[加一](https://leetcode.cn/problems/plus-one/)

**题解：**

https://leetcode.cn/problems/plus-one/solutions/1057162/jia-yi-by-leetcode-solution-2hor

**模拟：**

```c++
class Solution
{
public:
    vector<int> plusOne(vector<int> &digits)
    {
        vector<int> res; 
        int c = 0;
        (*digits.rbegin())++;
        for_each(digits.rbegin(), digits.rend(),
                 [&](int d)
                 {
                     int sum = d + c;
                     res.push_back(sum % 10);
                     c = sum / 10;
                 });
        if (c) res.push_back(1);
        reverse(res.begin(), res.end());
        return res;
    }
};

```

**统计结尾9：**

```c++
class Solution
{
public:
    vector<int> plusOne(vector<int> &ds)
    {
        int n = ds.size();
        for (int i = n - 1; i >= 0; i--)
        {
            if (ds[i] != 9)
            {
                ds[i]++;
                for (int j = i + 1; j < n; j++)
                    ds[j] = 0;
                return ds;
            }
        }

        vector<int> res(n + 1); res[0] = 1;
        return res;
    }
};
```

### 阶乘后的零

题目：[阶乘后的零](https://leetcode.cn/problems/factorial-trailing-zeroes/)

**题解：**

https://www.acwing.com/video/1549/

https://leetcode.cn/problems/factorial-trailing-zeroes/solutions/1360892/jie-cheng-hou-de-ling-by-leetcode-soluti-1egk

```c++
class Solution
{
public:
    int trailingZeroes(int n)
    {
        int res = 0;
        while (n)
        {
            res += n / 5;
            n /= 5;
        }
        return res;
    }
};
```

### x 的平方根

题目：[x 的平方根 ](https://leetcode.cn/problems/sqrtx/)

**题解：**

https://leetcode.cn/problems/sqrtx/solutions/238553/x-de-ping-fang-gen-by-leetcode-solution

**二分查找：**

```c++
class Solution
{
public:
    int mySqrt(int x)
    {
        int l = 0, r = x;
        while (l < r)
        {
            int mid = l + (r - l) / 2 + 1;
            if (mid <= x / mid) l = mid;
            else r = mid - 1;
        }
        return l;
    }
};
```

**牛顿迭代：**

```c++
class Solution
{
public:
    int mySqrt(int x)
    {
        if (!x) return 0;

        double x0 = x;
        double x1 = (x0 + x / x0) / 2;
        while (x0 - x1 >= 1e-6)
        {
            x0 = x1;
            x1 = (x0 + x / x0) / 2;
        }
        return int(x1);
    }
};
```

### Pow(x, n)

题目：[Pow(x, n)](https://leetcode.cn/problems/powx-n/)

```c++
class Solution
{
public:
    double myPow(double x, long long n)
    {
        if (x == 1 || x == 0) return x;

        double res = 1;
        if (n < 0)
        {
            x = 1 / x;
            n = -n;
        }
        while (n)
        {
            if (n & 1) res *= x;
            x *= x;
            n >>= 1;
        }
        return res;
    }
};
```

### 直线上最多的点数

题目：[直线上最多的点数](https://leetcode.cn/problems/max-points-on-a-line/)

**题解：**

https://www.acwing.com/video/1520/

https://leetcode.cn/problems/max-points-on-a-line/solutions/842114/zhi-xian-shang-zui-duo-de-dian-shu-by-le-tq8f

```c++
class Solution
{
public:
    int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }

    int maxPoints(vector<vector<int>> &points)
    {
        int res = 0;
        for (auto& p0 : points)
        {
            int x0 = p0[0], y0 = p0[1];
            unordered_map<int, int> cnt;
            for (auto& p1 : points)
            {
                int x1 = p1[0], y1 = p1[1];
                if (x0 == x1) cnt[0]++;
                else
                {
                    int dy = y1 - y0, dx = x1 - x0;
                    if (dy < 0) dy = -dy, dx = -dx;
                    int g = gcd(dx, dy);
                    dy /= g, dx /= g;
                    cnt[(dx << 16) + dy]++;
                }
            }
            cnt[0]--; // 多算了自己一次
            for (auto [key, val] : cnt)
                res = max(res, val + 1);
        }
        return res;
    }
};
```

## 一维动态规划

### 爬楼梯

题目：[爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

```c++
class Solution
{
public:
    int climbStairs(int n)
    {
        int f0 = 1, f1 = 1;
        while ((n--) > 1)
        {
            int f2 = f0 + f1;
            f0 = f1;
            f1 = f2;
        }
        return f1;
    }
};
```

### 打家劫舍

题目：[打家劫舍](https://leetcode.cn/problems/house-robber/)

**题解：**

https://leetcode.cn/problems/house-robber/solutions/2870248/tou-huan-shi-bu-tou-de-er-wei-dong-tai-g-qbn9

```c++
class Solution
{
public:
    int rob(vector<int>& W)
    {
        int n = W.size();
        int f0 = 0, f1 = W[0];
        for (int i = 1; i < n; i++)
        {
            int nf0 = max(f0, f1);
            int nf1 = f0 + W[i];
            f0 = nf0, f1 = nf1;
        }
        return max(f0, f1);
    }
};
```

### 单词拆分

题目：[单词拆分](https://leetcode.cn/problems/word-break/)

题解：https://www.acwing.com/video/1505/

```c++
typedef unsigned long long ULL;

class Solution
{
public:
    const int P = 131;

    bool wordBreak(string s, vector<string> &wordDict)
    {
        unordered_set<ULL> hs;
        for (string& word : wordDict)
        {
            ULL val = 0;
            for (int i = word.size() - 1; i >= 0; i--)
                val = val * P + word[i];
            hs.insert(val);
        }

        int n = s.size();
        vector<bool> f(n + 1, false);
        f[n] = true;
        for (int i = n; i >= 0; i--)
        {
            if (!f[i]) continue;
            ULL val = 0;
            for (int j = i - 1; j >= 0; j--)
            {
                val = P * val + s[j];
                if (hs.count(val)) f[j] = true;
            }
        }

        return f[0];
    }
};
```

### 零钱兑换

题目：[零钱兑换](https://leetcode.cn/problems/coin-change/)

思路：完全背包

```c++
class Solution
{
public:
    const int INF = 1e4 + 10;

    int coinChange(vector<int> &coins, int amount)
    {
        int n = coins.size();
        vector<int> f(amount + 1, INF);
        f[0] = 0;
        for (int i = 1; i <= n; i++)
            for (int j = coins[i - 1]; j <= amount; j++)
                f[j] = min(f[j], f[j - coins[i - 1]] + 1);
        
        int res = f[amount];
        return res < INF ? res : -1;
    }
};
```

### 最长递增子序列

题目：[最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

题解：https://www.acwing.com/video/1656/

```c++
class Solution
{
public:
    int lengthOfLIS(vector<int> &nums)
    {
        int n = nums.size();
        vector<int> g(n + 1);
        g[1] = nums[0]; 
        int len = 1;
        for (int i = 1; i < n; i++)
        {
            int l = 1, r = len;
            while (l < r)
            {
                int mid = l + r + 1 >> 1;
                if (g[mid] < nums[i]) l = mid;
                else r = mid - 1;
            }
            if (g[l] < nums[i])
            {
                g[l + 1] = nums[i];
                len = max(len, l + 1);
            }
            else g[1] = nums[i];
        }

        return len;
    }
};
```

## 多维动态规划

### 三角形最小路径和

题目：[三角形最小路径和](https://leetcode.cn/problems/triangle/)

```c++
class Solution
{
public:
    int minimumTotal(vector<vector<int>> &W)
    {
        int n = W.size();
        vector<int> f(n);
        for (int j = 0; j < n; j++) f[j] = W[n - 1][j];
        for (int i = n - 2; i >= 0; i--)
            for (int j = 0; j <= i; j++)
                f[j] = min(f[j], f[j + 1]) + W[i][j];

        return f[0];
    }
};
```

### 最小路径和

题目：[最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

```c++
class Solution
{
public:
    const int INF = 1e4 + 10;

    int minPathSum(vector<vector<int>> &G)
    {
        int n = G.size(), m = G[0].size();
        vector<int> f(m + 1, INF);
        f[1] = 0;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++)
                f[j] = min(f[j], f[j - 1]) + G[i - 1][j - 1];

        return f[m];
    }
};
```

### 不同路径 II

题目：[不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

**注意：**

本题最好不要用滚动数组优化，有一些坑。

```c++
class Solution
{
public:
    int uniquePathsWithObstacles(vector<vector<int>> &G)
    {
        int n = G.size(), m = G[0].size();
        vector<int> f(m + 1, 0);
        for (int j = 1; j <= m; j++)
            if (!G[0][j - 1]) f[j] = 1;
            else break;
        for (int i = 2; i <= n; i++)
            for (int j = 1; j <= m; j++)
                if (G[i - 1][j - 1]) f[j] = 0;
                else f[j] += f[j - 1];

        return f[m];
    }
};
```

### 最长回文子串

题目：[最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

**动态规划：**

```c++
class Solution
{
public:
    string longestPalindrome(string s)
    {
        int n = s.size();
        vector<vector<bool>> f(n, vector<bool>(n, true));
        pair<int, int> res;
        int mx = 0;
        for (int i = n - 2; i >= 0; i--)
            for (int j = i + 1; j < n; j++)
            {
                f[i][j] = s[i] == s[j] && f[i + 1][j - 1];
                if (f[i][j] && j - i + 1 > mx)
                {
                    mx = j - i + 1;
                    res = {i, j};
                }
            }

        auto [l, r] = res;
        return s.substr(l, r - l + 1);
    }
};
```

**中心扩展：**

```c++
class Solution
{
public:
    string longestPalindrome(string s)
    {
        int n = s.size();
        pair<int, int> res = {0, 0}; 
        int mx = 1;
        for (int k = 1; k < n; k++)
        {
            int i = k - 1, j = k;
            while (i >= 0 && j < n && s[i] == s[j])
                i--, j++;
            if (j - i - 1 > mx) 
                mx = j - i - 1, res = {i + 1, j - 1};
            i = k - 1, j = k + 1;
            while (i >= 0 && j < n && s[i] == s[j])
                i--, j++;
            if (j - i - 1 > mx)
                mx = j - i - 1, res = {i + 1, j - 1};
        }
        auto [l, r] = res;
        return s.substr(l, r - l + 1);
    }
};
```

### 交错字符串

题目：[交错字符串](https://leetcode.cn/problems/interleaving-string/)

题解：https://www.acwing.com/video/1442/

```c++
class Solution
{
public:
    bool isInterleave(string s1, string s2, string s3)
    {
        int n = s1.size(), m = s2.size();
        if (n + m != s3.size()) return false;

        vector<vector<bool>> f(n + 1, vector<bool>(m + 1));
        for (int i = 0; i <= n; i++)
            for (int j = 0; j <= m; j++)
            {
                if (!i && !j) f[i][j] = true;
                else
                {
                    if (i && s1[i - 1] == s3[i + j - 1])
                        f[i][j] = f[i - 1][j];
                    if (j && s2[j - 1] == s3[i + j - 1])
                        f[i][j] = f[i][j] || f[i][j - 1];
                }
            }

        return f[n][m];
    }
};
```

### 编辑距离

题目：[编辑距离](https://leetcode.cn/problems/edit-distance/)

```c++
class Solution
{
public:
    int minDistance(string s1, string s2)
    {
        int n = s1.size(), m = s2.size();
        auto&& pre = vector<int>(m + 1);
        auto&& cur = vector<int>(m + 1);
        for (int j = 1; j <= m; j++) pre[j] = j;
        for (int i = 1; i <= n; i++)
        {
            cur[0] = i;
            for (int j = 1; j <= m; j++)
            {
                if (s1[i - 1] == s2[j - 1]) cur[j] = pre[j - 1];
                else cur[j] = pre[j - 1] + 1;
                cur[j] = min(cur[j], cur[j - 1] + 1);
                cur[j] = min(cur[j], pre[j] + 1);
            }
            auto tmp = pre; pre = cur; cur = tmp;
        }

        return pre[m];
    }
};
```

### 买卖股票的最佳时机 III

题目：[买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

题解：https://www.acwing.com/video/1487/

```c++
class Solution
{
public:
    int maxProfit(vector<int> &prices)
    {
        int n = prices.size();
        vector<int> f(n + 1);
        int mn = prices[0];
        for (int i = 1; i <= n; i++)
        {
            f[i] = max(f[i - 1], prices[i - 1] - mn);
            mn = min(mn, prices[i - 1]);
        }

        int res = 0, mx = prices[n - 1];
        for (int i = n; i >= 1; i--)
        {
            res = max(res, mx - prices[i - 1] + f[i]);
            mx = max(mx, prices[i - 1]);
        }

        return res;
    }
};
```

### 买卖股票的最佳时机 IV

题目：[买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

**题解：**

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/solutions/537731/mai-mai-gu-piao-de-zui-jia-shi-ji-iv-by-8xtkp

**状态转移DP：**

```c++
class Solution
{
public:
    const int INF = 1e6 + 10;

    int maxProfit(int k, vector<int> &prices)
    {
        int n = prices.size();
        int res = 0;
        vector<vector<int>> buy(n + 1, vector<int>(k + 1, -INF));
        vector<vector<int>> sell(n + 1, vector<int>(k + 1, -INF));
        for (int i = 0; i <= n; i++) sell[i][0] = 0;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= k; j++)
            {
                buy[i][j] = max(buy[i - 1][j], sell[i - 1][j - 1] - prices[i - 1]);
                sell[i][j] = max(sell[i - 1][j], buy[i - 1][j] + prices[i - 1]);
                res = max(res, sell[i][j]);
            }

        return res;
    }
};
```

**滚动数组优化：**

```c++
class Solution
{
public:
    const int INF = 1e6 + 10;

    int maxProfit(int k, vector<int> &prices)
    {
        int n = prices.size();
        vector<int> buy(k + 1, -INF), sell(k + 1, -INF);
        sell[0] = 0;

        for (int i = 1; i <= n; i++)
            for (int j = k; j >= 1; j--)
            {
                sell[j] = max(sell[j], buy[j] + prices[i - 1]);
                buy[j] = max(buy[j], sell[j - 1] - prices[i - 1]);
            }
  
        return *max_element(sell.begin(), sell.end());
    }
};
```

### 最大正方形

题目：[最大正方形](https://leetcode.cn/problems/maximal-square/)

**题解：**

https://leetcode.cn/problems/maximal-square/solutions/234964/zui-da-zheng-fang-xing-by-leetcode-solution

```c++
class Solution
{
public:
    int maximalSquare(vector<vector<char>> &matrix)
    {
        int n = matrix.size(), m = matrix[0].size();
        vector<vector<int>> f(n + 1, vector<int>(m + 1));
        int res = 0;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++)
                if (matrix[i - 1][j - 1] == '1')
                {
                    f[i][j] = min({f[i - 1][j], f[i][j - 1], f[i - 1][j - 1]}) + 1;
                    res = max(res, f[i][j]);
                }
        res *= res;
        return res;
    }
};
```

