# 字符串

## KMP

### 扩展KMP

时间复杂度为$O(n)$。

模板：

```c++
int Z[N], ext[N];

void getZ(char P[], int n)
{
    Z[1] = n;
    for (int i = 2, l = 0, r = 0; i <= n; i++)
    {
        if (i <= r) Z[i] = std::min(Z[i - l + 1], r - i + 1);
        while (i + Z[i] <= n && P[i + Z[i]] == P[Z[i] + 1]) ++Z[i];
        if (i + Z[i] - 1 > r) l = i, r = i + Z[i] - 1;
    }
}

void getExt(char S[], int n, char P[], int m)
{
    for (int i = 1, l = 0, r = 0; i <= n; i++)
    {
        if (i <= r) ext[i] = std::min(Z[i - l + 1], r - i + 1);
        while (i + ext[i] <= n && S[i + ext[i]] == P[ext[i] + 1]) ++ext[i];
        if (i + ext[i] - 1 >= r) l = i, r = i + ext[i] - 1;
    }
}
```



#### P5410 【模板】扩展 KMP/exKMP（Z 函数）

题目：https://www.luogu.com.cn/problem/P5410

题解：https://www.luogu.com.cn/article/qynzfhcm

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;

const int N = 2e7 + 5;

int la, lb;
char A[N], B[N];
int Z[N], ext[N];

void getZ(char P[], int n)
{
    Z[1] = n;
    for (int i = 2, l = 0, r = 0; i <= n; i++)
    {
        if (i <= r) Z[i] = std::min(Z[i - l + 1], r - i + 1);
        while (i + Z[i] <= n && P[i + Z[i]] == P[Z[i] + 1]) ++Z[i];
        if (i + Z[i] - 1 > r) l = i, r = i + Z[i] - 1;
    }
}

void getExt(char S[], int n, char P[], int m)
{
    for (int i = 1, l = 0, r = 0; i <= n; i++)
    {
        if (i <= r) ext[i] = std::min(Z[i - l + 1], r - i + 1);
        while (i + ext[i] <= n && S[i + ext[i]] == P[ext[i] + 1]) ++ext[i];
        if (i + ext[i] - 1 >= r) l = i, r = i + ext[i] - 1;
    }
}

int main()
{
    scanf("%s%s", A + 1, B + 1);
    la = strlen(A + 1);
    lb = strlen(B + 1);

    getZ(B, lb), getExt(A, la, B, lb);

    LL wa = 0, wb = 0;
    for (int i = 1; i <= la; i++) wa ^= LL(i) * (ext[i] + 1);
    for (int i = 1; i <= lb; i++) wb ^= LL(i) * (Z[i] + 1);

    printf("%lld\n", wb);
    printf("%lld\n", wa);
    return 0;
}
```



#### Simpsons’ Hidden Talents

题目：https://acm.hdu.edu.cn/showproblem.php?pid=2594

找一个串的前缀和另一个串的后缀相匹配的最大长度。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

const int N = 5e4 + 5;

int ls, lp;
char S[N], P[N];

int Z[N], ext[N];

void getZ()
{
    memset(Z, 0, sizeof Z);
    Z[1] = lp;
    for (int i = 2, l = 0, r = 0; i <= lp; i++)
    {
        if (i <= r) Z[i] = std::min(Z[i - l + 1], r - i + 1);
        while (i + Z[i] <= lp && P[i + Z[i]] == P[Z[i] + 1]) ++Z[i];
        if (i + Z[i] - 1 >= r) l = i, r = i + Z[i] - 1;
    }
}

void getExt()
{
    memset(ext, 0, sizeof ext);
    for (int i = 1, l = 0, r = 0; i <= ls; i++)
    {
        if (i <= r) ext[i] = std::min(Z[i - l + 1], r - i + 1);
        while (i + ext[i] <= ls && S[i + ext[i]] == P[ext[i] + 1]) ++ext[i];
        if (i + ext[i] - 1 > r) l = i, r = i + ext[i] - 1;
    }
}

int main()
{
    while (scanf("%s%s", P + 1, S + 1) != EOF)
    {
        ls = strlen(S + 1);
        lp = strlen(P + 1);

        getZ(), getExt();

        int res = 0;
        for (int i = 1; i <= ls; i++)
            if (i + ext[i] - 1 == ls)
                res = std::max(res, ext[i]);

        if (res) printf("%s %d\n", S + (ls - res + 1), res);
        else puts("0");
    }

    return 0;
}
```

