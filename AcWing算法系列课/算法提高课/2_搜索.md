# 搜索

## Flood Fill

### 池塘计数

题目：https://www.acwing.com/problem/content/description/1099/

```c++
#include <iostream>

using namespace std;

const int N = 1010, M = N * N;

struct pt
{
    int x, y;
};

int n, m;
char G[N][N];
bool st[N][N];
pt Q[M];

void bfs(int sx, int sy)
{
    int hh = 0, tt = -1;
    st[sx][sy] = true;
    Q[++tt] = { sx, sy };
    while (hh <= tt)
    {
        pt cur = Q[hh++];
        for (int x = cur.x - 1; x <= cur.x + 1; x++)
            for (int y = cur.y - 1; y <= cur.y + 1; y++)
            {
                if (x < 1 || x > n || y < 1 || y > m) continue;
                if (G[x][y] != 'W' || st[x][y]) continue;
                st[x][y] = true;
                Q[++tt] = { x, y };
            }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%s", G[i] + 1);

    int cnt = 0;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            if (G[i][j] == 'W' && !st[i][j])
            {
                bfs(i, j);
                cnt++;
            }

    printf("%d\n", cnt);

    return 0;
}
```

### 城堡问题

题目：https://www.acwing.com/problem/content/description/1100/

```c++
#include <iostream>

using namespace std;

const int N = 55, M = N * N;

struct pt { int x, y; };

int n, m;
int G[N][N];
bool st[N][N];
pt Q[M]; int hh, tt;
int dx[4] = { 0, -1, 0, 1 }, dy[4] = { -1, 0, 1, 0 };

int bfs(int sx, int sy)
{
    int area = 1;

    hh = 0, tt = -1;
    st[sx][sy] = true;
    Q[++tt] = { sx, sy };

    while (hh <= tt)
    {
        pt cur = Q[hh++];
        int w = G[cur.x][cur.y];
        for (int i = 0; i < 4; i++)
            if (!(w >> i & 1))
            {
                int x = cur.x + dx[i], y = cur.y + dy[i];
                if (st[x][y]) continue;
                st[x][y] = true;
                area++;
                Q[++tt] = { x, y };
            }
    }

    return area;
}


int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            scanf("%d", &G[i][j]);
    
    int area = 0, cnt = 0;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            if (!st[i][j])
            {
                cnt++;
                area = max(area, bfs(i, j));
            }

    printf("%d\n%d\n", cnt, area);

    return 0;
}
```

### 山峰和山谷

题目：https://www.acwing.com/problem/content/description/1108/

```c++
#include <iostream>

using namespace std;

const int N = 1010, M = N * N;

struct pt { int x, y; };

int n;
int G[N][N];
bool st[N][N];
pt Q[M]; int hh, tt;

int bfs(int sx, int sy)
{
    int f = 0; // 0-初始值，1-山底，2-山顶，-1-其他状态
    hh = 0, tt = -1;
    st[sx][sy] = true;
    int h = G[sx][sy];
    Q[++tt] = { sx, sy };

    while (hh <= tt)
    {
        pt cur = Q[hh++];
        for (int x = cur.x - 1; x <= cur.x + 1; x++)
            for (int y = cur.y - 1; y <= cur.y + 1; y++)
            {
                if (x < 1 || x > n || y < 1 || y > n) continue;
                if (G[x][y] != h)
                {
                    if (f == -1) continue;
                    if      (G[x][y] > h && (f == 0 || f == 1)) f = 1;
                    else if (G[x][y] < h && (f == 0 || f == 2)) f = 2;
                    else f = -1;
                }
                else
                {
                    if (st[x][y]) continue;
                    st[x][y] = true;
                    Q[++tt] = { x, y };
                }
            }
    }

    return f;
}

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            scanf("%d", &G[i][j]);

    int top = 0, down = 0;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            if (!st[i][j])
            {
                int f = bfs(i, j);
                if      (f == 0) top++, down++;
                else if (f == 1) down++;
                else if (f == 2) top++;
            }

    printf("%d %d\n", top, down);

    return 0;
}
```

## 最短路模型

### 迷宫问题

题目：https://www.acwing.com/problem/content/description/1078/

```c++
#include <iostream>

using namespace std;

const int N = 1010, M = 1e6 + 10;

struct pt { int x, y; };

int n;
int G[N][N];
pt P[N][N];
pt Q[M]; int hh, tt;
bool st[N][N];

int dx[4] = { -1, 0, 1, 0 }, dy[4] = { 0, 1, 0, -1 };
void bfs(int sx, int sy)
{
    hh = 0, tt = -1;
    st[sx][sy] = true;
    P[sx][sy] = { 0, 0 };
    Q[++tt] = { sx, sy };

    while (hh <= tt)
    {
        pt cur = Q[hh++];
        for (int i = 0; i < 4; i++)
        {
            int x = cur.x + dx[i], y = cur.y + dy[i];
            if (x < 1 || x > n || y < 1 || y > n) continue;
            if (G[x][y] == 1 || st[x][y]) continue;
            st[x][y] = true;
            P[x][y] = { cur.x, cur.y };
            Q[++tt] = { x, y };
        }
    }
}

void print(int x, int y)
{
    if (!x && !y) return;

    printf("%d %d\n", x - 1, y - 1);
    auto [px, py] = P[x][y];
    print(px, py);
}

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            scanf("%d", &G[i][j]);

    bfs(n, n);

    print(1, 1);

    return 0;
}
```

### 武士风度的牛

题目：https://www.acwing.com/problem/content/description/190/

题解：https://www.acwing.com/solution/content/140308/

```c++
#include <iostream>

using namespace std;

const int N = 160, M = N * N;

struct pt { int x, y, s; };

int n, m;
char G[N][N];
pt Q[M]; int hh, tt;
bool st[N][N];

int dx[8] = { -2, -2, -1, 1, 2, 2, 1, -1 };
int dy[8] = { -1, 1, 2, 2, 1, -1, -2, -2 };
int bfs(int sx, int sy)
{
    hh = 0, tt = -1;
    st[sx][sy] = true;
    Q[++tt] = { sx, sy, 0 };

    while (hh <= tt)
    {
        pt cur = Q[hh++];
        for (int i = 0; i < 8; i++)
        {
            int x = cur.x + dx[i], y = cur.y + dy[i];
            if (x < 1 || x > n || y < 1 || y > m) continue;
            if (st[x][y] || G[x][y] == '*') continue;
            if (G[x][y] == 'H') return cur.s + 1;
            st[x][y] = true;
            Q[++tt] = { x, y, cur.s + 1 };
        }
    }

    return -1;
}

int main()
{
    scanf("%d%d", &m, &n);
    for (int i = 1; i <= n; i++)
        scanf("%s", G[i] + 1);

    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            if (G[i][j] == 'K')
            {
                printf("%d\n", bfs(i, j));
                return 0;
            }

    return 0;
}
```

### 抓住那头牛

题目：https://www.acwing.com/problem/content/description/1102/

```c++
#include <iostream>

using namespace std;

const int N = 1e5 + 10;

struct pt { int x, s; };

int n, m;
pt Q[N]; int hh, tt;
bool st[N];

int bfs()
{
    hh = 0, tt = -1;
    if (n == m) return 0;
    st[n] = true;
    Q[++tt] = { n, 0 };

    while (hh <= tt)
    {
        pt cur = Q[hh++];
        
        if (cur.x - 1 >= 0 && !st[cur.x - 1])
        {
            if (cur.x - 1 == m) return cur.s + 1;
            st[cur.x - 1] = true;
            Q[++tt] = { cur.x - 1, cur.s + 1 };
        }
        if (cur.x + 1 < N && !st[cur.x + 1])
        {
            if (cur.x + 1 == m) return cur.s + 1;
            st[cur.x + 1] = true;
            Q[++tt] = { cur.x + 1, cur.s + 1 };
        }
        if (cur.x * 2 < N && !st[cur.x * 2])
        {
            if (cur.x * 2 == m) return cur.s + 1;
            st[cur.x * 2] = true;
            Q[++tt] = { cur.x * 2, cur.s + 1 };
        }
    }
    return -1;
}

int main()
{
    scanf("%d%d", &n, &m);

    printf("%d\n", bfs());

    return 0;
}
```

## 多源BFS

### 矩阵距离

题目：https://www.acwing.com/problem/content/description/175/

题解：https://www.acwing.com/solution/content/40236/

```c++
#include <cstring>
#include <iostream>

using namespace std;

const int N = 1010;

struct pt
{
    int x, y;
};

int n, m;
char A[N][N];
int B[N][N];
pt Q[N * N]; int hh, tt;

int dx[4] = { -1, 0, 1, 0 }, dy[4] = { 0, 1, 0, -1 };
void bfs()
{
    memset(B, -1, sizeof B);
    hh = 0, tt = -1;

    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            if (A[i][j] == '1')
            {
                B[i][j] = 0;
                Q[++tt] = { i, j };
            }

    while (hh <= tt)
    {
        pt cur = Q[hh++];
        for (int i = 0; i < 4; i++)
        {
            int x = cur.x + dx[i], y = cur.y + dy[i];
            if (x < 1 || x > n || y < 1 || y > m) continue;
            if (B[x][y] != -1) continue;
            B[x][y] = B[cur.x][cur.y] + 1;
            Q[++tt] = { x, y };
        }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%s", A[i] + 1);

    bfs();

    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
            printf("%d ", B[i][j]);
        puts("");
    }

    return 0;
}
```

## 最小步数模型

### 魔板

题目：https://www.acwing.com/problem/content/description/1109/

```c++
#include <iostream>
#include <unordered_map>
#include <algorithm>

using namespace std;

const int N = 40330;

struct QNode
{
    string status;
    int step;
};

struct TNode
{
    string status;
    char trans;
};

string start = "12345678", tar;
QNode Q[N]; int hh, tt;
unordered_map<string, TNode> pre;

string A(string s)
{
    int l = 0, r = s.size() - 1;
    while (l < r) swap(s[l++], s[r--]);
    return s;
}

string B(string s)
{
    for (int i = 3; i >= 1; i--) swap(s[i], s[i - 1]);
    for (int i = 4; i <= 6; i++) swap(s[i], s[i + 1]);
    return s;
}

string C(string s)
{
    char t = s[1];
    swap(t, s[2]), swap(t, s[5]), swap(t, s[6]);
    s[1] = t;
    return s;
}

void print(string cur)
{
    if (cur == start) return;

    auto [ps, t] = pre[cur];
    print(ps);
    printf("%c", t);
}

int main()
{
    for (int i = 0; i < 8; i++)
    {
        int d; scanf("%d", &d);
        tar += char(d + '0');
    }

    hh = 0, tt = -1;
    if (start == tar)
    {
        printf("0\n");
        return 0;
    }
    Q[++tt] = { start, 0 };
    while (hh <= tt)
    {
        auto& [cs, step] = Q[hh++];
        string ns[3];
        ns[0] = A(cs), ns[1] = B(cs), ns[2] = C(cs);
        for (int i = 0; i < 3; i++)
            if (!pre.count(ns[i]))
            {
                pre[ns[i]] = { cs, char('A' + i) };
                Q[++tt] = { ns[i], step + 1 };
                if (ns[i] == tar)
                {
                    printf("%d\n", Q[tt].step);
                    print(tar); puts("");
                    return 0;
                }
            }
    }

    return 0;
}
```

**另一种做法：**

```c++
#include <iostream>
#include <algorithm>
#include <unordered_set>

using namespace std;

const int N = 40330;

struct QNode
{
    string status;
    string steps;
};

string start = "12345678", tar;
QNode Q[N]; int hh, tt;
unordered_set<string> st;

string A(string s)
{
    int l = 0, r = s.size() - 1;
    while (l < r) swap(s[l++], s[r--]);
    return s;
}

string B(string s)
{
    for (int i = 3; i >= 1; i--) swap(s[i], s[i - 1]);
    for (int i = 4; i <= 6; i++) swap(s[i], s[i + 1]);
    return s;
}

string C(string s)
{
    char t = s[1];
    swap(t, s[2]), swap(t, s[5]), swap(t, s[6]);
    s[1] = t;
    return s;
}

int main()
{
    for (int i = 0; i < 8; i++)
    {
        int d; scanf("%d", &d);
        tar += char(d + '0');
    }

    hh = 0, tt = -1;
    if (start == tar)
    {
        printf("0\n");
        return 0;
    }
    Q[++tt] = { start, "" };
    while (hh <= tt)
    {
        auto& [cs, step] = Q[hh++];
        string ns[3];
        ns[0] = A(cs), ns[1] = B(cs), ns[2] = C(cs);
        for (int i = 0; i < 3; i++)
            if (!st.count(ns[i]))
            {
                st.insert(ns[i]);
                Q[++tt] = { ns[i], step + char('A' + i) };
                if (ns[i] == tar)
                {
                    string& s = Q[tt].steps;
                    printf("%d\n", s.size());
                    printf("%s\n", s.c_str());
                }
            }
    }

    return 0;
}
```

## 双端队列广搜

### 电路维修

题目：https://www.acwing.com/problem/content/description/177/

题解：https://www.acwing.com/solution/content/140385/

本算法实际上可以看成堆优化的dijkstra算法的进一步优化，当边权只有0和1的时候可以考虑双端队列广搜

```c++
#include <cstring>
#include <iostream>
#include <deque>

using namespace std;

const int N = 510, M = N * N;

struct pt { int x, y; };

int T;
int n, m;
char G[N][N];
int dx[4] = { -1, -1, 1, 1 };
int dy[4] = { -1, 1, 1, -1 };
char trans[4] = { '\\', '/', '\\', '/' };

bool check(int x, int y, int i)
{
    int a = x, b = y;
    if      (i == 0) a--, b--;
    else if (i == 1) a--;
    else if (i == 3) b--;

    return G[a][b] == trans[i];
}

bool st[N][N];
int dist[N][N];
int bfs()
{
    memset(st, false, sizeof st);
    memset(dist, 0x3f, sizeof dist);
    dist[0][0] = 0;

    deque<pt> dq; dq.push_back({ 0, 0 });
    while (!dq.empty())
    {
        pt cur = dq.front(); dq.pop_front();
        if (st[cur.x][cur.y]) continue;
        st[cur.x][cur.y] = true;
        for (int i = 0; i < 4; i++)
        {
            int nx = cur.x + dx[i], ny = cur.y + dy[i];
            if (nx < 0 || nx > n || ny < 0 || ny > m) continue;
            if (check(cur.x, cur.y, i))
            {
                if (dist[cur.x][cur.y] < dist[nx][ny])
                {
                    dist[nx][ny] = dist[cur.x][cur.y];
                    dq.push_front({ nx, ny });
                }
            }
            else
            {
                if (dist[cur.x][cur.y] + 1 < dist[nx][ny])
                {
                    dist[nx][ny] = dist[cur.x][cur.y] + 1;
                    dq.push_back({ nx, ny });
                }
            }
            if (nx == n && ny == m) break;
        }
    }

    return dist[n][m];
}

int main()
{
    scanf("%d", &T);
    while (T--)
    {
        scanf("%d%d", &n, &m);
        for (int i = 0; i < n; i++) scanf("%s", G[i]);

        if ((n + m) % 2) puts("NO SOLUTION");
        else printf("%d\n", bfs());
    }
    return 0;
}
```

## 双向广搜

### 字串变换

题目：https://www.acwing.com/problem/content/description/192/

题解：https://www.acwing.com/solution/content/5434/

一点优化是用`string::find`代替暴力搜索，速度会快一倍。

```c++
#include <iostream>
#include <unordered_map>
#include <queue>

using namespace std;

const int N = 10;

int n;
string sa, sb;
string A[N], B[N];

unordered_map<string, int> da, db;
queue<string> qa, qb;

int extend(queue<string> &q, unordered_map<string, int> &da, unordered_map<string, int> &db,
           string A[], string B[])
{
    int d = da[q.front()];
    while (!q.empty() && d == da[q.front()])
    {
        string cur = q.front(); q.pop();
        for (int i = 0; i < n; i++)
            for (int j = 0; j < cur.size(); j++)
            {
                j = cur.find(A[i], j);
                if (j == cur.npos) break;
                string nxt = cur.substr(0, j) + B[i] + cur.substr(j + A[i].size());
                if (da.count(nxt)) continue;
                if (db.count(nxt)) return db[nxt] + d + 1;
                da[nxt] = d + 1;
                q.push(nxt);
            }
    }

    return -1;
}

int bfs()
{
    if (sa == sb) return 0;

    da[sa] = db[sb] = 0;
    qa.push(sa), qb.push(sb);

    int step = 0;
    while (!qa.empty() && !qb.empty() && ++step <= 10)
    {
        int dist = -1;
        if (qa.size() < qb.size()) dist = extend(qa, da, db, A, B);
        else dist = extend(qb, db, da, B, A);
        if (dist > 0) return dist;
    }

    return -1;
}

int main()
{
    cin >> sa >> sb;
    while (cin >> A[n] >> B[n]) n++;

    int res = bfs();
    if (res >= 0) printf("%d\n", res);
    else puts("NO ANSWER!");

    return 0;
}
```

## A*

### 第K短路

题目：https://www.acwing.com/problem/content/description/180/

题解：算法竞赛p137/p645

本题关键在于理解一些细节，`if (cnt[v] < K) heap.push({ v, g, g + dist[v]});`这里是为了防止环而导致的无法停止。

```c++
#include <cstring>
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

const int N = 1010, M = 2e4 + 10, INF = 0x3f3f3f3f;

int n, m, S, T, K;
int H[N], RH[N];
struct ListNode
{
    int v, w, n;
} L[M]; int idx = 1;

void add(int H[], int a, int b, int w)
{
    L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

int dist[N];
bool st[N];
void dijkstra()
{
    struct Node
    {
        int d, v;
        bool operator< (const Node& ct) const
        {
            return d > ct.d;
        }
    };
    priority_queue<Node> heap;

    memset(dist, 0x3f, sizeof dist);
    dist[T] = 0;
    heap.push({ 0, T });

    while (!heap.empty())
    {
        auto cur = heap.top(); heap.pop();

        if (st[cur.v]) continue;
        else st[cur.v] = true;

        for (int p = RH[cur.v]; p; p = L[p].n)
        {
            int v = L[p].v, w = L[p].w;
            if (st[v]) continue;
            if (cur.d + w < dist[v])
            {
                dist[v] = cur.d + w;
                heap.push({ dist[v], v });
            }
        }
    }
}

int cnt[N];
int astar()
{
    dijkstra();

    if (S == T) K++;
    if (dist[S] == INF) return -1;

    struct Node
    {
        int v, g, f; // 估价函数：f = g + h，但h不用存

        bool operator< (const Node& ct) const
        {
            return f > ct.f;
        }
    };
    priority_queue<Node> heap;
    heap.push({ S, 0, dist[S] });

    while (!heap.empty())
    {
        auto cur = heap.top(); heap.pop();
        cnt[cur.v]++;
        if (cnt[T] == K) return cur.g;

        for (int p = H[cur.v]; p; p = L[p].n)
        {
            int v = L[p].v, w = L[p].w, g = cur.g + w;
            if (cnt[v] < K) heap.push({ v, g, g + dist[v]});
        }
    }

    return -1;
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++)
    {
        int a, b, w; scanf("%d%d%d", &a, &b, &w);
        add(H, a, b, w), add(RH, b, a, w);
    }
    scanf("%d%d%d", &S, &T, &K);

    printf("%d\n", astar());

    return 0;
}
```

### 八数码

题目：https://www.acwing.com/problem/content/description/181/

题解：https://www.acwing.com/solution/content/35528/

本题其实很简单，堆优化的dijkstra算法，只是把堆的排序元素改成了估值函数$f$.

**char版本（不推荐）：**

```c++
#include <iostream>
#include <unordered_set>
#include <unordered_map>
#include <queue>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 3, M = N * N;

char start[N][N];
char dest[N][N] = {{'1', '2', '3'},
                  {'4', '5', '6'},
                  {'7', '8', 'x'}};

int h(char G[N][N]) // 曼哈顿距离
{
    int dt = 0;
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
        {
            int t = G[i][j] - '1';
            int x = t / 3, y = t % 3;
            dt += abs(x - i) + abs(y - j);
        }

    return dt;
}

int hashCode(char G[N][N])
{
    int code = 0;
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
        {
            code *= 10;
            if (G[i][j] != 'x') code += G[i][j] - '0';
        }

    return code;
}

bool equal(char A[N][N], char B[N][N])
{
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
            if (A[i][j] != B[i][j])
                return false;

    return true;
}

void getX(char G[N][N], int& x, int& y)
{
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
            if (G[i][j] == 'x')
            {
                x = i, y = j;
                return;
            }
}

struct Node1
{
    int code;
    char op;
    int g;

    Node1() {}
    Node1(int code, char op, int g) : code(code), op(op), g(g) {}
};
unordered_map<int, Node1> pre;
void astar()
{
    struct Node2
    {
        int f, g; // 估值函数：f = g + h
        char G[N][N];

        Node2(int f, int g, char in[N][N]) : f(f), g(g)
        {
            memcpy(G, in, sizeof G);
        }

        bool operator< (const Node2& ct) const
        {
            return f > ct.f;
        }
    };
    priority_queue<Node2> heap;
    unordered_set<int> st;
    heap.push(Node2(h(start), 0, start));

    char op[] = {'u', 'r', 'd', 'l'};
    int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};
    while (!heap.empty())
    {
        auto cur = heap.top(); heap.pop();
        if (equal(cur.G, dest)) return;

        int curCode = hashCode(cur.G);
        if (st.count(curCode)) continue;
        else st.insert(curCode);

        int x, y;
        getX(cur.G, x, y);

        char G[N][N];
        memcpy(G, cur.G, sizeof G);
        for (int i = 0; i < 4; i++)
        {
            int a = x + dx[i], b = y + dy[i];
            if (a < 0 || a >= N || b < 0 || b >= N) continue;
            swap(G[x][y], G[a][b]);
            int GCode = hashCode(G);
            if (!st.count(GCode))
            {
                int g = cur.g + 1;
                if (!pre.count(GCode) || g < pre[GCode].g) 
                    pre[GCode] = Node1(curCode, op[i], g);
                heap.push(Node2(g + h(G), g, G));
            }
            swap(G[x][y], G[a][b]);
        }
    }

}

int inverseNum(char G[N][N])
{
    char S[M]; int len = 0;
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
            if (G[i][j] != 'x')
                S[len++] = G[i][j];

    int cnt = 0;
    for (int i = 0; i < len; i++)
        for (int j = i + 1; j < len; j++)
            if (S[i] > S[j]) cnt++;

    return cnt;
}

int main()
{
    char in[2];
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
        {
            scanf("%s", in);
            start[i][j] = in[0];
        }
    
    int cnt = inverseNum(start);
    if (cnt % 2)
    {
        puts("unsolvable");
        return 0;
    }

    astar();

    string res;
    int code = hashCode(dest);
    while (pre.count(code))
    {
        res += pre[code].op;
        code = pre[code].code;
    }
    reverse(res.begin(), res.end());

    printf("%s", res.c_str());

    return 0;
}
```

**string版本：**

在答案的版本中，并没有采用`st`表，本题因为通过逆序数进行了判断，所以一定会到达终点，也许不用`st`表。但一个奇怪的事情是，下面这个版本的代码删掉`st`表会超时。

```c++
#include <iostream>
#include <unordered_map>
#include <unordered_set>
#include <queue>
#include <algorithm>

using namespace std;

const int N = 3, M = N * N;

string start, dest = "12345678x";

int h(string& s) // 曼哈顿距离
{
    int dt = 0;
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
        {
            int k = s[i * N + j] - '1';
            dt += abs(i - k / N) + abs(j - k % N);
        }

    return dt;
}

struct Node1
{
    string s;
    char op;

    Node1() {}
    Node1(string s, char op) : s(s), op(op) {}
};
unordered_map<string, Node1> pre;
void astar()
{

    unordered_map<string, int> dist;
    unordered_set<string> st;

    struct Node2
    {
        int f, g;
        string s;

        Node2() {}
        Node2(int f, int g, string s) : f(f), g(g), s(s) {}

        bool operator< (const Node2& ct) const
        {
            return f > ct.f;
        }
    };
    priority_queue<Node2> heap;
    heap.push(Node2(h(start), 0, start));

    char op[] = {'u', 'r', 'd', 'l'};
    int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};
    while (!heap.empty())
    {
        auto cur = heap.top(); heap.pop();

        if (cur.s == dest) return;

        if (st.count(cur.s)) continue;
        else st.insert(cur.s);

        string ns = cur.s;

        int x = 0, y = 0;
        for (int i = 0; i < M; i++)
            if (ns[i] == 'x')
            {
                x = i / N, y = i % N;
                break;
            }

        for (int i = 0; i < 4; i++)
        {
            int nx = x + dx[i], ny = y + dy[i];
            if (nx < 0 || nx >= N || ny < 0 || ny >= N) continue;

            swap(ns[x * 3 + y], ns[nx * 3 + ny]);
            if (!st.count(ns) && (!dist.count(ns) || cur.g + 1 < dist[ns]))
            {
                int g = cur.g + 1;
                dist[ns] = g;
                pre[ns] = Node1(cur.s, op[i]);
                heap.push(Node2(h(ns) + g, g, ns));
            }
            swap(ns[x * 3 + y], ns[nx * 3 + ny]);
        }
    }
}

int inverseNum(string& state)
{
    string tmp;
    for (char c : state)
        if (c != 'x')
            tmp += c;
    int cnt = 0;
    for (int i = 0; i < tmp.size(); i++)
        for (int j = i + 1; j < tmp.size(); j++)
            if (tmp[i] > tmp[j]) cnt++;
    return cnt;
}

int main()
{
    char in[2];
    for (int i = 0; i < M; i++)
    {
        scanf("%s", in);
        start += in[0];
    }

    int cnt = inverseNum(start);
    if (cnt % 2)
    {
        puts("unsolvable");
        return 0;
    }

    astar();

    string res, s = dest;
    while (pre.count(s))
    {
        res += pre[s].op;
        s = pre[s].s;
    }
    reverse(res.begin(), res.end());

    printf("%s", res.c_str());

    return 0;
}
```

## DFS之连通性模型

### 迷宫

题目：https://www.acwing.com/problem/content/1114/

```c++
#include <iostream>
#include <cstring>

using namespace std;

const int N = 110;

struct pt
{
    int x, y;

    bool operator== (const pt& ct) const
    {
        return x == ct.x && y == ct.y;
    }
};

int n;
char G[N][N];
pt start, dest;

int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
bool st[N][N];
bool dfs(pt cur)
{
    if (G[cur.x][cur.y] == '#') return false;

    if (cur == dest) return true;
    st[cur.x][cur.y] = true;

    for (int i = 0; i < 4; i++)
    {
        pt nxt = {cur.x + dx[i], cur.y + dy[i]};
        if (nxt.x < 0 || nxt.x >= n || nxt.y < 0 || nxt.y >= n) continue;
        if (st[nxt.x][nxt.y]) continue;
        if (dfs(nxt)) return true;
    }

    return false;
}

int main()
{
    int T; scanf("%d", &T);

    while (T--)
    {
        scanf("%d", &n);

        for (int i = 0; i < n; i++) scanf("%s", G[i]);
        scanf("%d%d%d%d", &start.x, &start.y, &dest.x, &dest.y);

        memset(st, false, sizeof st);
        if (dfs(start)) puts("YES");
        else puts("NO");
    }

    return 0;
}
```

### 红与黑

题目：https://www.acwing.com/problem/content/1115/

```c++
#include <iostream>
#include <cstring>

using namespace std;

const int N = 25;

struct pt
{
    int x, y;
};

int n, m;
char G[N][N];
pt start;

bool st[N][N];
int cnt;
int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
void dfs(pt cur)
{
    if (cur.x < 1 || cur.x > n || cur.y < 1 || cur.y > m) return;
    if (st[cur.x][cur.y] || G[cur.x][cur.y] == '#') return;

    cnt++;
    st[cur.x][cur.y] = true;

    for (int i = 0; i < 4; i++)
        dfs({cur.x + dx[i], cur.y + dy[i]});
}

int main()
{
    while (scanf("%d%d", &m, &n), m || n)
    {
        for (int i = 1; i <= n; i++) scanf("%s", G[i] + 1);

        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++)
                if (G[i][j] == '@')
                {
                    start = {i, j};
                    goto DFS;
                }

    DFS:
        cnt = 0;
        memset(st, false, sizeof st);
        dfs(start);

        printf("%d\n", cnt);
    }

    return 0;
}
```

## DFS之搜索顺序

### 马走日

题目：https://www.acwing.com/problem/content/1118/

DFS的剪枝或结束判断一般有两个位置，一个是调用时判断，一个是进入时判断。根据这个题来看，进入时判断由于栈开销，比调用时判断要多花一些时间。区别有点像`do while`和`while`的区别。

```c++
#include <cstring>
#include <iostream>

using namespace std;

const int N = 10;

struct Point
{
    int x, y;
};

int n, m, tot;
Point start;
bool st[N][N];
int cnt, res;

int dx[8] = {-2, -2, -1, 1, 2, 2, -1, 1};
int dy[8] = {-1, 1, 2, 2, 1, -1, -2, -2};
void dfs(Point cur)
{
    if (cur.x < 0 || cur.x >= n || cur.y < 0 || cur.y >= m) return;
    if (st[cur.x][cur.y]) return;

    if (cnt + 1 == tot)
    {
        res++;
        return;
    }

    cnt++;
    st[cur.x][cur.y] = true;
    for (int i = 0; i < 8; i++)
        dfs({ cur.x + dx[i], cur.y + dy[i] });
    cnt--;
    st[cur.x][cur.y] = false;
}

int main()
{
    int T; scanf("%d", &T);
    
    while (T--)
    {
        scanf("%d%d%d%d", &n, &m, &start.x, &start.y);
        memset(st, false, sizeof st);
        cnt = res = 0;
        tot = n * m;
        dfs(start);
        printf("%d\n", res);
    }

    return 0;
}
```

### 单词接龙

题目：https://www.acwing.com/problem/content/description/1119/

这个写法是一种典型的调用时判断，调用时判断的特点是，调用时判断需要写两次，初次调用时要写，每次递归时也要写。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 25;

int n;
string ss[N];
int cnt[N];
int len;
int res;

int check(int a, int b)
{
    for (int i = ss[a].size() - 1; i >= 1; i--)
    {
        if (ss[a].size() - i >= ss[b].size()) continue;
        int j = i, k = 0;
        while (j < ss[a].size() && ss[a][j] == ss[b][k]) j++, k++;
        if (j == ss[a].size()) return k;
    }

    return 0;
}

void dfs(int i)
{
    for (int j = 0; j < n; j++)
        if (cnt[j] < 2)
        {
            int k = check(i, j);
            if (k > 0)
            {
                len += ss[j].size() - k;
                cnt[j]++;
                res = max(res, len);
                dfs(j);
                cnt[j]--;
                len -= ss[j].size() - k;
            }
        }
}

int main()
{
    cin >> n;
    for (int i = 0; i <= n; i++) cin >> ss[i];
    
    char start = ss[n][0];
    for (int i = 0; i < n; i++)
        if (ss[i][0] == start)
        {
            len += ss[i].size();
            cnt[i]++;
            res = max(res, len);
            dfs(i);
            cnt[i]--;
            len -= ss[i].size();
        }

    cout << res << endl;

    return 0;
}
```

### 分成互质组

题目：https://www.acwing.com/problem/content/description/1120/

思路比较简单，每次递归枚举放在最后一组还是新建一组。

```c++
#include <climits>
#include <iostream>
#include <vector>

using namespace std;

const int N = 15;

int n;
int arr[N];
bool st[N];
vector<int> gs[N];
int cnt, res = INT_MAX;

int gcd(int x, int y)
{
    return y ? gcd(y, x % y) : x;
}

void dfs(int g, int i)
{
    if (cnt == n)
    {
        res = min(res, g + !gs[g].empty());
        return;
    }

    bool flag = false;
    for (int j = i; j <= n; j++)
    {
        if (st[j]) continue;
        int k = 0;
        while (k < gs[g].size() && gcd(gs[g][k], arr[j]) == 1) k++;
        if (k == gs[g].size())
        {
            flag = true;

            cnt++;
            st[j] = true;
            gs[g].push_back(arr[j]);
            dfs(g, j + 1);
            cnt--;
            st[j] = false;
            gs[g].pop_back();
        }
    }

    if (!flag)
    {
        for (int j = 1; j <= n; j++)
            if (!st[j])
            {
                g++;
                cnt++;
                st[j] = true;
                gs[g] = {arr[j]};
                dfs(g, 1);
                g--;
                cnt--;
                st[j] = false;
                return;
            }
    }

}

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &arr[i]);

    gs[0] = {arr[1]};
    cnt++;
    st[1] = true;
    dfs(0, 1);

    printf("%d\n", res);

    return 0;
}
```

## DFS之剪枝与优化

### 小猫爬山

题目：https://www.acwing.com/problem/content/description/167/

题解：https://www.acwing.com/solution/content/32118/

```c++
#include <climits>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 20;

int n, m;
int W[N], C[N];
int res;

void dfs(int a, int b)
{
    if (b >= res) return;
    if (a == n + 1)
    {
        res = b;
        return;
    }

    for (int i = 1; i <= b; i++)
        if (C[i] + W[a] <= m)
        {
            C[i] += W[a];
            dfs(a + 1, b);
            C[i] -= W[a];
        }

    C[b + 1] = W[a];
    dfs(a + 1, b + 1);
    C[b + 1] = 0;
}


int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%d", &W[i]);

    sort(W + 1, W + 1 + n, [](int a, int b) { return a > b; } );

    res = n;
    dfs(1, 1);

    printf("%d\n", res);

    return 0;
}
```

### 数独

题目：https://www.acwing.com/problem/content/description/168/

题解：https://www.acwing.com/solution/content/173662/

```c++
#include <cstring>
#include <iostream>

using namespace std;

const int N = 9, M = N * N, S = 1 << N;

char G[N][N + 1];
int row[N], col[N], box[N];
int ones[S], digit[S];

inline int boxId(int x, int y)
{
    return (x / 3) * 3 + y / 3;
}

void draw(int x, int y, int d)
{
    G[x][y] = char(d + '0');
    int mask = ~(1 << (d - 1));
    row[x] &= mask;
    col[y] &= mask;
    box[boxId(x, y)] &= mask;
}

void erase(int x, int y)
{
    int d = G[x][y] - '0';
    G[x][y] = '.';
    int mask = 1 << (d - 1);
    row[x] |= mask;
    col[y] |= mask;
    box[boxId(x, y)] |= mask;
}

inline int lowbit(int x)
{
    return x & -x;
}

inline int getState(int x, int y)
{
    return row[x] & col[y] & box[boxId(x, y)];
}

bool dfs(int cnt)
{

    if (cnt == 0) return true;
    
    int mn = N + 1;
    int x, y;
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
            if (G[i][j] == '.')
            {
                int s = getState(i, j);
                if (ones[s] < mn)
                {
                    mn = ones[s];
                    x = i, y = j;
                }
            }

    int s = getState(x, y);
    for (int i = s; i > 0; i -= lowbit(i))
    {
        int d = digit[lowbit(i)];
        draw(x, y, d);
        if (dfs(cnt - 1)) return true;
        erase(x, y);
    }

    return false;
}

int main()
{
    for (int i = 0; i < S; i++)
        for (int j = 0; j < N; j++)
            if (i >> j & 1) ones[i]++;

    for (int i = 0; i < N; i++)
        digit[1 << i] = i + 1;

    char in[M + 1];
    while (scanf("%s", in), in[0] != 'e')
    {
        for (int i = 0; i < N; i++)
            row[i] = col[i] = box[i] = S - 1;

        memset(G, '.', sizeof G);
        for (int i = 0; i < N; i++) G[i][N] = '\0';

        int cnt = M;
        for (int i = 0; i < N; i++)
            for (int j = 0; j < N; j++)
            {
                int idx = i * N + j;
                if (in[idx] != '.')
                {
                    draw(i, j, in[idx] - '0');
                    cnt--;
                }
            }
                    
        dfs(cnt);

        for (int i = 0; i < N; i++) printf("%s", G[i]);
        puts("");
    }

    return 0;
}
```

### 木棒

题目：https://www.acwing.com/problem/content/description/169/

题解：https://www.acwing.com/solution/content/36030/

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 70;

int n;
int W[N];
bool st[N];
int sum, len;

bool dfs(int u, int cur, int start)
{
    if (u * len == sum) return true;
    if (cur == len) return dfs(u + 1, 0, 1);

    for (int i = start; i <= n; i++)
    {
        if (st[i] || cur + W[i] > len) continue;
        st[i] = true;
        if (dfs(u, cur + W[i], i + 1)) return true;
        st[i] = false;

        if (cur == 0 || cur + W[i] == len) return false;
        int j = i + 1;
        while (j <= n && W[i] == W[j]) j++;
        i = j - 1;
    }

    return false;
}

int main()
{
    while (scanf("%d", &n), n)
    {
        len = sum = 0;
        for (int i = 1; i <= n; i++)
        {
            scanf("%d", &W[i]);
            sum += W[i];
            len = max(len, W[i]);
        }
        memset(st, false, sizeof st);

        sort(W + 1, W + 1 + n, greater<int>());
        
        while (true)
        {
            if (sum % len == 0 && dfs(0, 0, 1))
            {
                printf("%d\n", len);
                break;
            }
            len++;
        }
    }

    return 0;
}
```

### 生日蛋糕

题目：https://www.acwing.com/problem/content/description/170/

题解：https://www.acwing.com/solution/content/31876/

这个推导稍微有点错误，但是优化得非常好。

```c++
#include <cmath>
#include <climits>
#include <iostream>

using namespace std;

const int M = 25;

int n, m;
int R[M], H[M];
int res = INT_MAX;
int mnv[M], mns[M];

void dfs(int u, int s, int v)
{
    if (v + mnv[u] > n) return;

    if (s + mns[u] >= res) return;
    if (s + 2 * (n - v) / R[u + 1] >= res) return;
    
    if (u == 0)
    {
        if (v == n) res = s;
        return;
    }

    int mxv = n - mnv[u - 1] - v;
    for (int r = min(R[u + 1] - 1, int(sqrt(mxv / u))); r >= u; r--)
        for (int h = min(H[u + 1] - 1, mxv / (r * r)); h >= u; h--)
        {
            H[u] = h, R[u] = r;
            int t = u == m ? r * r : 0;
            dfs(u - 1, s + 2 * r * h + t, v + r * r * h);
        }
}

int main()
{
    scanf("%d%d", &n, &m);

    for (int i = 1; i <= m; i++)
    {
        mnv[i] = mnv[i - 1] + i * i * i;
        mns[i] = mns[i - 1] + 2 * i * i;
    }

    R[m + 1] = H[m + 1] = INT_MAX;
    dfs(m, 0, 0);

    if (res == INT_MAX) res = 0;
    printf("%d\n", res);

    return 0;
}
```

## 迭代加深

### 加成序列

题目：https://www.acwing.com/problem/content/description/172/

题解：https://www.acwing.com/solution/content/38248/

```c++
#include <iostream>

using namespace std;

const int N = 110;

int n;
int X[N];

bool dfs(int u, int depth)
{
    if (u > depth) return X[u - 1] == n;

    bool st[N] = {false};
    for (int i = u - 1; i >= 1; i--)
        for (int j = i; j >= 1; j--)
        {
            int s = X[i] + X[j];
            if (s <= X[u - 1]) return false;
            if (st[s] || s > n) continue;

            X[u] = s;
            st[s] = true;
            if (dfs(u + 1, depth)) return true;
        }

    return false;
}

int main()
{
    X[1] = 1;
    while (scanf("%d", &n), n)
    {
        int depth = 1;
        while (!dfs(2, depth)) depth++;
        for (int i = 1; i <= depth; i++) printf("%d ", X[i]);
        puts("");
    }

    return 0;
}
```

### 送礼物

题目：https://www.acwing.com/problem/content/description/173/

题解：https://www.acwing.com/solution/content/38250/

```c++
#include <iostream>
#include <algorithm>

using namespace std;
using LL = long long;

const int N = 50, M = 1 << 25;

int n, m, K;
int G[N];
int W[M], cnt;

void dfs(int u, int s)
{
    if (u == K)
    {
        W[cnt++] = s;
        return;
    }

    dfs(u + 1, s);

    if ((LL)G[u] + s <= m)
        dfs(u + 1, s + G[u]);
}

int res;
void dfs1(int u, int s)
{
    if (u >= n)
    {
        int l = 0, r = cnt - 1;
        while (l < r)
        {
            int mid = l + r + 1 >> 1;
            if (W[mid] <= m - s) l = mid;
            else r = mid - 1;
        }
        res = max(res, W[l] + s);

        return;
    }

    dfs1(u + 1, s);

    if ((LL)s + G[u] <= m) 
        dfs1(u + 1, s + G[u]);
}

int main()
{
    scanf("%d%d", &m, &n);
    for (int i = 0; i < n; i++) scanf("%d", &G[i]);

    sort(G, G + n, greater<int>());
    K = n / 2;
    dfs(0, 0);

    sort(W, W + cnt);
    int j = 1;
    for (int i = 1; i < cnt; i++)
        if (W[i] != W[i - 1])
            W[j++] = W[i];
    cnt = j;

    dfs1(K, 0);

    printf("%d\n", res);

    return 0;
}
```

## IDA*

### 排书

题目：https://www.acwing.com/problem/content/description/182/

题解：https://www.acwing.com/solution/content/4050/

```c++
#include <cstring>
#include <iostream>

using namespace std;

const int N = 20;

int n;
int seq[N];

int f()
{
    int cnt = 0;
    for (int i = 1; i < n; i++)
        if (seq[i] + 1 != seq[i + 1])
            cnt++;
    return (cnt + 2) / 3;
}

int maxDepth;
bool dfs(int depth)
{
    int t = f();
    if (t == 0) return true;
    if (depth + t > maxDepth) return false;
    
    int tmp[N];
    for (int l = 1; l <= n; l++)
        for (int r = l; r <= n; r++)
            for (int k = r + 1; k <= n; k++)
            {
                memcpy(tmp, seq, sizeof seq);
                int len = r - l + 1;
                for (int i = l, j = r + 1; j <= k; i++, j++)
                    seq[i] = tmp[j];
                for (int i = k - len + 1, j = l; j <= r; i++, j++)
                    seq[i] = tmp[j];
                if (dfs(depth + 1)) return true;
                memcpy(seq, tmp, sizeof seq);
            }

    return false;
}

int main()
{
    int T; scanf("%d", &T);

    while (T--)
    {
        scanf("%d", &n);
        for (int i = 1; i <= n; i++) scanf("%d", &seq[i]);
        
        maxDepth = 0;
        while (maxDepth < 5 && !dfs(0)) maxDepth++;

        if (maxDepth < 5) printf("%d\n", maxDepth);
        else puts("5 or more");
    }

    return 0;
}
```

### 回转游戏

题目：https://www.acwing.com/problem/content/description/183/

题解：https://www.acwing.com/solution/content/4056/

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int map[8][7] = 
{
    {0, 2, 6, 11, 15, 20, 22},
    {1, 3, 8, 12, 17, 21, 23},
    {10, 9, 8, 7, 6, 5, 4},
    {19, 18, 17, 16, 15, 14, 13},
    {23, 21, 17, 12, 8, 3, 1},
    {22, 20, 15, 11, 6, 2, 0},
    {13, 14, 15, 16, 17, 18, 19},
    {4, 5, 6, 7, 8, 9, 10}
};
const int opp[8] = {5, 4, 7, 6, 1, 0, 3, 2};
const int cen[8] = {6, 7, 8, 11, 12, 15, 16, 17};

const int N = 24, M = 128;

int arr[N];
char path[M];

int f()
{
    static int cnt[4];
    memset(cnt, 0, sizeof cnt);

    for (int i = 0; i < 8; i++)
        cnt[arr[cen[i]]]++;
    
    int mx = *max_element(cnt, cnt + 4);
    return 8 - mx;
}

void moveBy(int x)
{
    int t = arr[map[x][0]];
    for (int i = 0; i < 6; i++)
        arr[map[x][i]] = arr[map[x][i + 1]];
    arr[map[x][6]] = t;
}

int maxDepth;
bool dfs(int depth, int last)
{
    int t = f();
    if (depth + t > maxDepth) return false;
    if (t == 0) return true;

    for (int i = 0; i < 8; i++)
        if (opp[i] != last)
        {
            moveBy(i);
            path[depth] = char(i + 'A');
            if (dfs(depth + 1, i)) return true;
            moveBy(opp[i]);
        }

    return false;
}

int main()
{
    while (scanf("%d", &arr[0]), arr[0])
    {
        for (int i = 1; i < N; i++) scanf("%d", &arr[i]);

        maxDepth = 0;
        while (!dfs(0, -1)) maxDepth++;

        if (maxDepth == 0) puts("No moves needed");
        else
        {
            path[maxDepth] = '\0';
            printf("%s\n", path);
        }
        printf("%d\n", arr[cen[0]]);
    }

    return 0;
}
```

