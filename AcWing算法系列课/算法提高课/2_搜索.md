# 搜索

## Flood Fill

### 池塘计数

题目：https://www.acwing.com/problem/content/description/1099/

标签：模板题

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1010;

int n, m;
char G[N][N];

bool st[N][N];
int dx[8] = {-1, -1, 0, 1, 1, 1, 0, -1};
int dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};

void dfs(int x, int y)
{
    st[x][y] = true;

    for (int i = 0; i < 8; i++)
    {
        int nx = x + dx[i], ny = y + dy[i];
        if (nx >= 0 && nx < n && ny >= 0 && ny < m)
            if (!st[nx][ny] && G[nx][ny] == 'W')
                dfs(nx, ny);
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < n; i++) cin >> G[i];

    int res = 0;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            if (!st[i][j] && G[i][j] == 'W')
            {
                dfs(i, j);
                res++;
            }

    cout << res << '\n';
    return 0;
}
```

### 城堡问题

题目：https://www.acwing.com/problem/content/description/1100/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 60;

int n, m;
int G[N][N];

bool st[N][N];
int dx[4] = {0, -1, 0, 1}, dy[4] = {-1, 0, 1, 0};

int dfs(int x, int y)
{
    st[x][y] = true;
    int res = 1;

    for (int i = 0; i < 4; i++)
        if (!(G[x][y] >> i & 1))
        {
            int nx = x + dx[i], ny = y + dy[i];
            if (nx >= 0 && nx < n && ny >= 0 && ny < m)
                if (!st[nx][ny])
                    res += dfs(nx, ny);
        }

    return res;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            cin >> G[i][j];

    int cnt = 0, area = 0;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            if (!st[i][j])
            {
                cnt++;
                area = std::max(area, dfs(i, j));
            }

    cout << cnt << '\n' << area << '\n';

    return 0;
}
```

### 山峰和山谷

题目：https://www.acwing.com/problem/content/description/1108/

这个题的原题只有32MB的内存空间，写dfs是肯定不够的，必须用bfs。在洛谷上给了128MB的内存，所以能通过dfs。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1010;

int n;
int G[N][N];

struct Point
{
    int x, y;
} Q[N * N];
bool st[N][N];
int dx[8] = {-1, -1, 0, 1, 1, 1, 0, -1};
int dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};

// 0-初始，1-山峰，2-山谷，3-什么也不是
int bfs(int sx, int sy)
{
    int hh = 0, tt = 0;
    Q[tt++] = {sx, sy};
    int state = 0;

    while (hh < tt)
    {
        Point p = Q[hh++];
        for (int i = 0; i < 8; i++)
        {
            int x = p.x + dx[i], y = p.y + dy[i];
            if (x >= 0 && x < n && y >= 0 && y < n)
            {
                if (!st[x][y] && G[p.x][p.y] == G[x][y])
                {
                    st[x][y] = true;
                    Q[tt++] = {x, y};
                }
                else if (state != 3)
                {
                    if (G[p.x][p.y] > G[x][y])
                    {
                        state = state != 2 ? 1 : 3;
                    }
                    else if (G[p.x][p.y] < G[x][y])
                    {
                        state = state != 1 ? 2 : 3;
                    }
                }
            }
        }
    }

    return state;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            cin >> G[i][j];

    int up = 0, dn = 0;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            if (!st[i][j])
            {
                int ret = bfs(i, j);
                if (ret == 0 || ret == 1) up++;
                if (ret == 0 || ret == 2) dn++;
            }

    cout << up << ' ' << dn << '\n';

    return 0;
}
```

## 最短路模型

### 迷宫问题

题目：https://www.acwing.com/problem/content/description/1078/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1010;

int n;
int G[N][N];

struct Point
{
    int x, y;
};
Point Q[N * N];
bool st[N][N];
Point pre[N][N];
int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

void bfs()
{
    int hh = 0, tt = 0;
    Q[tt++] = {0, 0};

    while (hh < tt)
    {
        auto p = Q[hh++];
        for (int i = 0; i < 4; i++)
        {
            int x = p.x + dx[i], y = p.y + dy[i];
            if (x >= 0 && x < n && y >= 0 && y < n)
                if (!st[x][y] && G[x][y] == 0)
                {
                    st[x][y] = true;
                    pre[x][y] = p;
                    Q[tt++] = {x, y};
                }
        }
    }
}

void dfs(int x, int y)
{
    if (x == 0 && y == 0)
    {
        cout << 0 << ' ' << 0 << '\n';
        return;
    }

    auto p = pre[x][y];
    dfs(p.x, p.y);
    cout << x << ' ' << y << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            cin >> G[i][j];

    bfs();
    dfs(n - 1, n - 1);
    
    return 0;
}
```

### 武士风度的牛

题目：https://www.acwing.com/problem/content/description/190/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 160;

int n, m;
char G[N][N];

struct Point
{
    int x, y;
} Q[N * N];
bool st[N][N];
int dist[N][N];
int dx[8] = {-2, -1, 1, 2, 2, 1, -1, -2};
int dy[8] = {1, 2, 2, 1, -1, -2, -2, -1};

int bfs(int sx, int sy)
{
    int hh = 0, tt = 0;
    Q[tt++] = {sx, sy};

    while (hh < tt)
    {
        auto p = Q[hh++];
        for (int i = 0; i < 8; i++)
        {
            int x = p.x + dx[i], y = p.y + dy[i];
            if (x >= 0 && x < n && y >= 0 && y < m)
                if (G[x][y] != '*' && !st[x][y])
                {
                    st[x][y] = true;
                    dist[x][y] = dist[p.x][p.y] + 1;
                    if (G[x][y] == 'H') return dist[x][y];
                    Q[tt++] = {x, y};
                }
        }
    }

    return -1;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> m >> n;
    for (int i = 0; i < n; i++) cin >> G[i];

    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            if (G[i][j] == 'K')
            {
                cout << bfs(i, j) << '\n';
                return 0;
            }

    return 0;
}
```

### 抓住那头牛

题目：https://www.acwing.com/problem/content/description/1102/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e5 + 5;

int start, end;
bool st[N];
int dist[N];
int Q[N], hh, tt;

bool visit(int x, int y)
{
    st[y] = true, dist[y] = dist[x] + 1, Q[tt++] = y;
    return y == end;
}

int bfs()
{
    if (start == end) return 0;

    Q[tt++] = start;
    while (hh < tt)
    {
        int x = Q[hh++];
        if (x < end)
        {
            if (int y = x + 1; y < N && !st[y] && visit(x, y)) 
                return dist[y]; 
            if (int y = x * 2; y < N && !st[y] && visit(x, y)) 
                return dist[y];
        }
        if (int y = x - 1; y >= 0 && !st[y] && visit(x, x - 1))
            return dist[y];
    }
    
    return -1;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> start >> end;
    cout << bfs() << '\n';

    return 0;
}
```

## 多源BFS

### 矩阵距离

题目：https://www.acwing.com/problem/content/description/175/

标签：模板题

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1010;

int n, m;
char G[N][N];

struct Point
{
    int x, y;
} Q[N * N];
bool st[N][N];
int dist[N][N];
int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

void bfs()
{
    int tt = 0, hh = 0;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            if (G[i][j] == '1')
            {
                st[i][j] = true;
                Q[tt++] = {i, j};
            }

    while (hh < tt)
    {
        auto p = Q[hh++];
        int d = dist[p.x][p.y];
        for (int i = 0; i < 4; i++)
        {
            int x = p.x + dx[i], y = p.y + dy[i];
            if (x >= 0 && x < n && y >= 0 && y < m)
                if (!st[x][y])
                {
                    st[x][y] = true;
                    dist[x][y] = d + 1;
                    Q[tt++] = {x, y};
                }
        }
    }
}


int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < n; i++) cin >> G[i];

    bfs();
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
            cout << dist[i][j] << ' ';
        cout << '\n';
    }       

    return 0;
}
```

## 最小步数模型

### 魔板

题目：https://www.acwing.com/problem/content/description/1109/

和[八数码](../算法基础课/3_搜索与图论.md#八数码)差不多。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <unordered_map>

using LL = long long;
using std::cin, std::cout;
using std::string;

const int N = 40330; // 8! + 10

string start = "12345678", end;
string Q[N];
std::unordered_map<string, int> dist;

struct Node
{
    string s;
    char op;
};
std::unordered_map<string, Node> pre;

string trans(string &s, char op)
{
    static int A[] = {8, 7, 6, 5, 4, 3, 2, 1};
    static int B[] = {4, 1, 2, 3, 6, 7, 8, 5};
    static int C[] = {1, 7, 2, 4, 5, 3, 6, 8};

    int *T = nullptr;
    switch (op)
    {
    case 'A': T = A; break;
    case 'B': T = B; break;
    case 'C': T = C; break;
    }

    string res(8, '\0');
    for (int i = 0; i < 8; i++) res[i] = s[T[i] - 1];
    return res;
}

int bfs()
{
    if (start == end) return 0;

    dist[start] = 0;
    int hh = 0, tt = 0;
    Q[tt++] = start;

    while (hh < tt)
    {
        string s = Q[hh++];
        int d = dist[s];
        for (char op = 'A'; op <= 'C'; op++)
        {
            string ns = trans(s, op);
            if (!dist.count(ns))
            {
                pre[ns] = {s, op};
                if (ns == end) return d + 1;
                dist[ns] = d + 1;
                Q[tt++] = ns;
            }
        }
    }

    return -1;
}

void dfs(string s)
{
    if (s == start) return;

    auto [ps, op] = pre[s];
    dfs(ps);

    cout << op;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    for (int i = 0; i < 8; i++)
    {
        char c; cin >> c;
        end += c;
    }

    cout << bfs() << '\n';
    dfs(end);

    return 0;
}
```



## 双端队列广搜

### 电路维修

题目：https://www.acwing.com/problem/content/description/177/

本算法实际上可以看成堆优化的dijkstra算法的进一步优化，当边权只有0和1的时候可以考虑双端队列广搜

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <deque>

using LL = long long;
using std::cin, std::cout;

const int N = 510;

int n, m;
char G[N][N];

bool st[N][N];
int dist[N][N];
struct Point
{
    int x, y;
};

int dx[4] = {-1, -1, 1, 1}, dy[4] = {-1, 1, 1, -1};
char trans[4] = {'\\', '/', '\\', '/'};

int weight(int x, int y, int i)
{
    if      (i == 0) x--, y--;
    else if (i == 1) x--;
    else if (i == 3) y--;

    return trans[i] != G[x][y];
}

int bfs()
{
    memset(st, 0, sizeof st);
    memset(dist, 0x3f, sizeof dist);
    std::deque<Point> dq;

    dist[0][0] = 0;
    dq.push_back({0, 0});

    while (!dq.empty())
    {
        auto p = dq.front(); dq.pop_front();

        if (st[p.x][p.y]) continue;
        st[p.x][p.y] = true;

        for (int i = 0; i < 4; i++)
        {
            int x = p.x + dx[i], y = p.y + dy[i];
            if (x >= 0 && x <= n && y >= 0 && y <= m)
            {
                int w = weight(p.x, p.y, i);
                if (dist[p.x][p.y] + w < dist[x][y])
                {
                    dist[x][y] = dist[p.x][p.y] + w;
                    if (x == n && y == m) return dist[x][y];
                    if (w) dq.push_back({x, y});
                    else dq.push_front({x, y});
                }
            }
        }
    }

    return -1;
}

void solve()
{
    cin >> n >> m;
    for (int i = 0; i < n; i++) cin >> G[i];

    if ((n + m) % 2) cout << "NO SOLUTION" << '\n';
    else cout << bfs() << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int T; cin >> T;
    while (T--)
        solve();

    return 0;
}
```

## 双向广搜

### 字串变换

题目：https://www.acwing.com/problem/content/description/192/

题解：https://www.acwing.com/solution/content/5434/

一点优化是用`string::find`代替暴力搜索，速度会快一倍。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <unordered_map>
#include <queue>

using LL = long long;
using std::cin, std::cout;
using std::string, std::unordered_map, std::queue;

const int N = 10;

int n;
string sa, sb;
string A[N], B[N];

unordered_map<string, int> da, db;
queue<string> qa, qb;

int extend(queue<string> &Q, unordered_map<string, int> &da,
            unordered_map<string, int> &db, string A[], string B[])
{
    int cnt = Q.size(), d = da[Q.front()];
    while (cnt--)
    {
        string u = Q.front(); Q.pop();
        for (int i = 0; i < n; i++)
            for (int j = 0; j < u.size(); j++)
            {
                j = u.find(A[i], j);
                if (j == string::npos) break;
                string v = u.substr(0, j) + B[i] +
                           u.substr(j + A[i].size());
                if (!da.count(v))
                {
                    if (db.count(v)) return db[v] + d + 1;
                    da[v] = d + 1;
                    Q.push(v);
                }
            }
    }

    return -1;
}

int bfs()
{
    if (sa == sb) return 0;

    da[sa] = 0, db[sb] = 0;
    qa.push(sa), qb.push(sb);

    for (int i = 0; i < 10; i++)
    {
        if (qa.empty() || qb.empty()) break;

        int ret = 0;
        if (qa.size() < qb.size()) ret = extend(qa, da, db, A, B);
        else ret = extend(qb, db, da, B, A);
        if (ret >= 0) return ret;
    }

    return -1;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> sa >> sb;
    while (cin >> A[n] >> B[n]) n++;

    int ret = bfs();
    if (ret >= 0) cout << ret << '\n';
    else cout << "NO ANSWER!" << '\n';
    
    return 0;
}
```

## A*

### 第K短路

题目：https://www.acwing.com/problem/content/description/180/

题解：算法竞赛p137/p645

本题关键在于理解一些细节，`if (cnt[v] < K) heap.push({ v, g, g + dist[v]});`这里是为了防止环而导致的无法停止。

```c++
#include <cstring>
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

const int N = 1010, M = 2e4 + 10, INF = 0x3f3f3f3f;

int n, m, S, T, K;
int H[N], RH[N];
struct ListNode
{
    int v, w, n;
} L[M]; int idx = 1;

void add(int H[], int a, int b, int w)
{
    L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

int dist[N];
bool st[N];
void dijkstra()
{
    struct Node
    {
        int d, v;
        bool operator< (const Node& ct) const
        {
            return d > ct.d;
        }
    };
    priority_queue<Node> heap;

    memset(dist, 0x3f, sizeof dist);
    dist[T] = 0;
    heap.push({ 0, T });

    while (!heap.empty())
    {
        auto cur = heap.top(); heap.pop();

        if (st[cur.v]) continue;
        else st[cur.v] = true;

        for (int p = RH[cur.v]; p; p = L[p].n)
        {
            int v = L[p].v, w = L[p].w;
            if (st[v]) continue;
            if (cur.d + w < dist[v])
            {
                dist[v] = cur.d + w;
                heap.push({ dist[v], v });
            }
        }
    }
}

int cnt[N];
int astar()
{
    dijkstra();

    if (S == T) K++;
    if (dist[S] == INF) return -1;

    struct Node
    {
        int v, g, f; // 估价函数：f = g + h，但h不用存

        bool operator< (const Node& ct) const
        {
            return f > ct.f;
        }
    };
    priority_queue<Node> heap;
    heap.push({ S, 0, dist[S] });

    while (!heap.empty())
    {
        auto cur = heap.top(); heap.pop();
        cnt[cur.v]++;
        if (cnt[T] == K) return cur.g;

        for (int p = H[cur.v]; p; p = L[p].n)
        {
            int v = L[p].v, w = L[p].w, g = cur.g + w;
            if (cnt[v] < K) heap.push({ v, g, g + dist[v]});
        }
    }

    return -1;
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++)
    {
        int a, b, w; scanf("%d%d%d", &a, &b, &w);
        add(H, a, b, w), add(RH, b, a, w);
    }
    scanf("%d%d%d", &S, &T, &K);

    printf("%d\n", astar());

    return 0;
}
```

### 八数码

题目：https://www.acwing.com/problem/content/description/181/

题解：https://www.acwing.com/solution/content/35528/

本题其实很简单，堆优化的dijkstra算法，只是把堆的排序元素改成了估值函数$f$.

**char版本（不推荐）：**

```c++
#include <iostream>
#include <unordered_set>
#include <unordered_map>
#include <queue>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 3, M = N * N;

char start[N][N];
char dest[N][N] = {{'1', '2', '3'},
                  {'4', '5', '6'},
                  {'7', '8', 'x'}};

int h(char G[N][N]) // 曼哈顿距离
{
    int dt = 0;
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
        {
            int t = G[i][j] - '1';
            int x = t / 3, y = t % 3;
            dt += abs(x - i) + abs(y - j);
        }

    return dt;
}

int hashCode(char G[N][N])
{
    int code = 0;
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
        {
            code *= 10;
            if (G[i][j] != 'x') code += G[i][j] - '0';
        }

    return code;
}

bool equal(char A[N][N], char B[N][N])
{
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
            if (A[i][j] != B[i][j])
                return false;

    return true;
}

void getX(char G[N][N], int& x, int& y)
{
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
            if (G[i][j] == 'x')
            {
                x = i, y = j;
                return;
            }
}

struct Node1
{
    int code;
    char op;
    int g;

    Node1() {}
    Node1(int code, char op, int g) : code(code), op(op), g(g) {}
};
unordered_map<int, Node1> pre;
void astar()
{
    struct Node2
    {
        int f, g; // 估值函数：f = g + h
        char G[N][N];

        Node2(int f, int g, char in[N][N]) : f(f), g(g)
        {
            memcpy(G, in, sizeof G);
        }

        bool operator< (const Node2& ct) const
        {
            return f > ct.f;
        }
    };
    priority_queue<Node2> heap;
    unordered_set<int> st;
    heap.push(Node2(h(start), 0, start));

    char op[] = {'u', 'r', 'd', 'l'};
    int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};
    while (!heap.empty())
    {
        auto cur = heap.top(); heap.pop();
        if (equal(cur.G, dest)) return;

        int curCode = hashCode(cur.G);
        if (st.count(curCode)) continue;
        else st.insert(curCode);

        int x, y;
        getX(cur.G, x, y);

        char G[N][N];
        memcpy(G, cur.G, sizeof G);
        for (int i = 0; i < 4; i++)
        {
            int a = x + dx[i], b = y + dy[i];
            if (a < 0 || a >= N || b < 0 || b >= N) continue;
            swap(G[x][y], G[a][b]);
            int GCode = hashCode(G);
            if (!st.count(GCode))
            {
                int g = cur.g + 1;
                if (!pre.count(GCode) || g < pre[GCode].g) 
                    pre[GCode] = Node1(curCode, op[i], g);
                heap.push(Node2(g + h(G), g, G));
            }
            swap(G[x][y], G[a][b]);
        }
    }

}

int inverseNum(char G[N][N])
{
    char S[M]; int len = 0;
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
            if (G[i][j] != 'x')
                S[len++] = G[i][j];

    int cnt = 0;
    for (int i = 0; i < len; i++)
        for (int j = i + 1; j < len; j++)
            if (S[i] > S[j]) cnt++;

    return cnt;
}

int main()
{
    char in[2];
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
        {
            scanf("%s", in);
            start[i][j] = in[0];
        }
    
    int cnt = inverseNum(start);
    if (cnt % 2)
    {
        puts("unsolvable");
        return 0;
    }

    astar();

    string res;
    int code = hashCode(dest);
    while (pre.count(code))
    {
        res += pre[code].op;
        code = pre[code].code;
    }
    reverse(res.begin(), res.end());

    printf("%s", res.c_str());

    return 0;
}
```

**string版本：**

在答案的版本中，并没有采用`st`表，本题因为通过逆序数进行了判断，所以一定会到达终点，也许不用`st`表。但一个奇怪的事情是，下面这个版本的代码删掉`st`表会超时。

```c++
#include <iostream>
#include <unordered_map>
#include <unordered_set>
#include <queue>
#include <algorithm>

using namespace std;

const int N = 3, M = N * N;

string start, dest = "12345678x";

int h(string& s) // 曼哈顿距离
{
    int dt = 0;
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
        {
            int k = s[i * N + j] - '1';
            dt += abs(i - k / N) + abs(j - k % N);
        }

    return dt;
}

struct Node1
{
    string s;
    char op;

    Node1() {}
    Node1(string s, char op) : s(s), op(op) {}
};
unordered_map<string, Node1> pre;
void astar()
{

    unordered_map<string, int> dist;
    unordered_set<string> st;

    struct Node2
    {
        int f, g;
        string s;

        Node2() {}
        Node2(int f, int g, string s) : f(f), g(g), s(s) {}

        bool operator< (const Node2& ct) const
        {
            return f > ct.f;
        }
    };
    priority_queue<Node2> heap;
    heap.push(Node2(h(start), 0, start));

    char op[] = {'u', 'r', 'd', 'l'};
    int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};
    while (!heap.empty())
    {
        auto cur = heap.top(); heap.pop();

        if (cur.s == dest) return;

        if (st.count(cur.s)) continue;
        else st.insert(cur.s);

        string ns = cur.s;

        int x = 0, y = 0;
        for (int i = 0; i < M; i++)
            if (ns[i] == 'x')
            {
                x = i / N, y = i % N;
                break;
            }

        for (int i = 0; i < 4; i++)
        {
            int nx = x + dx[i], ny = y + dy[i];
            if (nx < 0 || nx >= N || ny < 0 || ny >= N) continue;

            swap(ns[x * 3 + y], ns[nx * 3 + ny]);
            if (!st.count(ns) && (!dist.count(ns) || cur.g + 1 < dist[ns]))
            {
                int g = cur.g + 1;
                dist[ns] = g;
                pre[ns] = Node1(cur.s, op[i]);
                heap.push(Node2(h(ns) + g, g, ns));
            }
            swap(ns[x * 3 + y], ns[nx * 3 + ny]);
        }
    }
}

int inverseNum(string& state)
{
    string tmp;
    for (char c : state)
        if (c != 'x')
            tmp += c;
    int cnt = 0;
    for (int i = 0; i < tmp.size(); i++)
        for (int j = i + 1; j < tmp.size(); j++)
            if (tmp[i] > tmp[j]) cnt++;
    return cnt;
}

int main()
{
    char in[2];
    for (int i = 0; i < M; i++)
    {
        scanf("%s", in);
        start += in[0];
    }

    int cnt = inverseNum(start);
    if (cnt % 2)
    {
        puts("unsolvable");
        return 0;
    }

    astar();

    string res, s = dest;
    while (pre.count(s))
    {
        res += pre[s].op;
        s = pre[s].s;
    }
    reverse(res.begin(), res.end());

    printf("%s", res.c_str());

    return 0;
}
```

## DFS之连通性模型

### 迷宫

题目：https://www.acwing.com/problem/content/1114/

```c++
#include <iostream>
#include <cstring>

using namespace std;

const int N = 110;

struct pt
{
    int x, y;

    bool operator== (const pt& ct) const
    {
        return x == ct.x && y == ct.y;
    }
};

int n;
char G[N][N];
pt start, dest;

int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
bool st[N][N];
bool dfs(pt cur)
{
    if (G[cur.x][cur.y] == '#') return false;

    if (cur == dest) return true;
    st[cur.x][cur.y] = true;

    for (int i = 0; i < 4; i++)
    {
        pt nxt = {cur.x + dx[i], cur.y + dy[i]};
        if (nxt.x < 0 || nxt.x >= n || nxt.y < 0 || nxt.y >= n) continue;
        if (st[nxt.x][nxt.y]) continue;
        if (dfs(nxt)) return true;
    }

    return false;
}

int main()
{
    int T; scanf("%d", &T);

    while (T--)
    {
        scanf("%d", &n);

        for (int i = 0; i < n; i++) scanf("%s", G[i]);
        scanf("%d%d%d%d", &start.x, &start.y, &dest.x, &dest.y);

        memset(st, false, sizeof st);
        if (dfs(start)) puts("YES");
        else puts("NO");
    }

    return 0;
}
```

### 红与黑

题目：https://www.acwing.com/problem/content/1115/

```c++
#include <iostream>
#include <cstring>

using namespace std;

const int N = 25;

struct pt
{
    int x, y;
};

int n, m;
char G[N][N];
pt start;

bool st[N][N];
int cnt;
int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
void dfs(pt cur)
{
    if (cur.x < 1 || cur.x > n || cur.y < 1 || cur.y > m) return;
    if (st[cur.x][cur.y] || G[cur.x][cur.y] == '#') return;

    cnt++;
    st[cur.x][cur.y] = true;

    for (int i = 0; i < 4; i++)
        dfs({cur.x + dx[i], cur.y + dy[i]});
}

int main()
{
    while (scanf("%d%d", &m, &n), m || n)
    {
        for (int i = 1; i <= n; i++) scanf("%s", G[i] + 1);

        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++)
                if (G[i][j] == '@')
                {
                    start = {i, j};
                    goto DFS;
                }

    DFS:
        cnt = 0;
        memset(st, false, sizeof st);
        dfs(start);

        printf("%d\n", cnt);
    }

    return 0;
}
```

## DFS之搜索顺序

### 马走日

题目：https://www.acwing.com/problem/content/1118/

DFS的剪枝或结束判断一般有两个位置，一个是调用时判断，一个是进入时判断。根据这个题来看，进入时判断由于栈开销，比调用时判断要多花一些时间。区别有点像`do while`和`while`的区别。

```c++
#include <cstring>
#include <iostream>

using namespace std;

const int N = 10;

struct Point
{
    int x, y;
};

int n, m, tot;
Point start;
bool st[N][N];
int cnt, res;

int dx[8] = {-2, -2, -1, 1, 2, 2, -1, 1};
int dy[8] = {-1, 1, 2, 2, 1, -1, -2, -2};
void dfs(Point cur)
{
    if (cur.x < 0 || cur.x >= n || cur.y < 0 || cur.y >= m) return;
    if (st[cur.x][cur.y]) return;

    if (cnt + 1 == tot)
    {
        res++;
        return;
    }

    cnt++;
    st[cur.x][cur.y] = true;
    for (int i = 0; i < 8; i++)
        dfs({ cur.x + dx[i], cur.y + dy[i] });
    cnt--;
    st[cur.x][cur.y] = false;
}

int main()
{
    int T; scanf("%d", &T);
    
    while (T--)
    {
        scanf("%d%d%d%d", &n, &m, &start.x, &start.y);
        memset(st, false, sizeof st);
        cnt = res = 0;
        tot = n * m;
        dfs(start);
        printf("%d\n", res);
    }

    return 0;
}
```

### 单词接龙

题目：https://www.acwing.com/problem/content/description/1119/

这个写法是一种典型的调用时判断，调用时判断的特点是，调用时判断需要写两次，初次调用时要写，每次递归时也要写。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 25;

int n;
string ss[N];
int cnt[N];
int len;
int res;

int check(int a, int b)
{
    for (int i = ss[a].size() - 1; i >= 1; i--)
    {
        if (ss[a].size() - i >= ss[b].size()) continue;
        int j = i, k = 0;
        while (j < ss[a].size() && ss[a][j] == ss[b][k]) j++, k++;
        if (j == ss[a].size()) return k;
    }

    return 0;
}

void dfs(int i)
{
    for (int j = 0; j < n; j++)
        if (cnt[j] < 2)
        {
            int k = check(i, j);
            if (k > 0)
            {
                len += ss[j].size() - k;
                cnt[j]++;
                res = max(res, len);
                dfs(j);
                cnt[j]--;
                len -= ss[j].size() - k;
            }
        }
}

int main()
{
    cin >> n;
    for (int i = 0; i <= n; i++) cin >> ss[i];
    
    char start = ss[n][0];
    for (int i = 0; i < n; i++)
        if (ss[i][0] == start)
        {
            len += ss[i].size();
            cnt[i]++;
            res = max(res, len);
            dfs(i);
            cnt[i]--;
            len -= ss[i].size();
        }

    cout << res << endl;

    return 0;
}
```

### 分成互质组

题目：https://www.acwing.com/problem/content/description/1120/

思路比较简单，每次递归枚举放在最后一组还是新建一组。

```c++
#include <climits>
#include <iostream>
#include <vector>

using namespace std;

const int N = 15;

int n;
int arr[N];
bool st[N];
vector<int> gs[N];
int cnt, res = INT_MAX;

int gcd(int x, int y)
{
    return y ? gcd(y, x % y) : x;
}

void dfs(int g, int i)
{
    if (cnt == n)
    {
        res = min(res, g + !gs[g].empty());
        return;
    }

    bool flag = false;
    for (int j = i; j <= n; j++)
    {
        if (st[j]) continue;
        int k = 0;
        while (k < gs[g].size() && gcd(gs[g][k], arr[j]) == 1) k++;
        if (k == gs[g].size())
        {
            flag = true;

            cnt++;
            st[j] = true;
            gs[g].push_back(arr[j]);
            dfs(g, j + 1);
            cnt--;
            st[j] = false;
            gs[g].pop_back();
        }
    }

    if (!flag)
    {
        for (int j = 1; j <= n; j++)
            if (!st[j])
            {
                g++;
                cnt++;
                st[j] = true;
                gs[g] = {arr[j]};
                dfs(g, 1);
                g--;
                cnt--;
                st[j] = false;
                return;
            }
    }

}

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &arr[i]);

    gs[0] = {arr[1]};
    cnt++;
    st[1] = true;
    dfs(0, 1);

    printf("%d\n", res);

    return 0;
}
```

## DFS之剪枝与优化

### 小猫爬山

题目：https://www.acwing.com/problem/content/description/167/

题解：https://www.acwing.com/solution/content/32118/

```c++
#include <climits>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 20;

int n, m;
int W[N], C[N];
int res;

void dfs(int a, int b)
{
    if (b >= res) return;
    if (a == n + 1)
    {
        res = b;
        return;
    }

    for (int i = 1; i <= b; i++)
        if (C[i] + W[a] <= m)
        {
            C[i] += W[a];
            dfs(a + 1, b);
            C[i] -= W[a];
        }

    C[b + 1] = W[a];
    dfs(a + 1, b + 1);
    C[b + 1] = 0;
}


int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%d", &W[i]);

    sort(W + 1, W + 1 + n, [](int a, int b) { return a > b; } );

    res = n;
    dfs(1, 1);

    printf("%d\n", res);

    return 0;
}
```

### 数独

题目：https://www.acwing.com/problem/content/description/168/

题解：https://www.acwing.com/solution/content/173662/

```c++
#include <cstring>
#include <iostream>

using namespace std;

const int N = 9, M = N * N, S = 1 << N;

char G[N][N + 1];
int row[N], col[N], box[N];
int ones[S], digit[S];

inline int boxId(int x, int y)
{
    return (x / 3) * 3 + y / 3;
}

void draw(int x, int y, int d)
{
    G[x][y] = char(d + '0');
    int mask = ~(1 << (d - 1));
    row[x] &= mask;
    col[y] &= mask;
    box[boxId(x, y)] &= mask;
}

void erase(int x, int y)
{
    int d = G[x][y] - '0';
    G[x][y] = '.';
    int mask = 1 << (d - 1);
    row[x] |= mask;
    col[y] |= mask;
    box[boxId(x, y)] |= mask;
}

inline int lowbit(int x)
{
    return x & -x;
}

inline int getState(int x, int y)
{
    return row[x] & col[y] & box[boxId(x, y)];
}

bool dfs(int cnt)
{

    if (cnt == 0) return true;
    
    int mn = N + 1;
    int x, y;
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
            if (G[i][j] == '.')
            {
                int s = getState(i, j);
                if (ones[s] < mn)
                {
                    mn = ones[s];
                    x = i, y = j;
                }
            }

    int s = getState(x, y);
    for (int i = s; i > 0; i -= lowbit(i))
    {
        int d = digit[lowbit(i)];
        draw(x, y, d);
        if (dfs(cnt - 1)) return true;
        erase(x, y);
    }

    return false;
}

int main()
{
    for (int i = 0; i < S; i++)
        for (int j = 0; j < N; j++)
            if (i >> j & 1) ones[i]++;

    for (int i = 0; i < N; i++)
        digit[1 << i] = i + 1;

    char in[M + 1];
    while (scanf("%s", in), in[0] != 'e')
    {
        for (int i = 0; i < N; i++)
            row[i] = col[i] = box[i] = S - 1;

        memset(G, '.', sizeof G);
        for (int i = 0; i < N; i++) G[i][N] = '\0';

        int cnt = M;
        for (int i = 0; i < N; i++)
            for (int j = 0; j < N; j++)
            {
                int idx = i * N + j;
                if (in[idx] != '.')
                {
                    draw(i, j, in[idx] - '0');
                    cnt--;
                }
            }
                    
        dfs(cnt);

        for (int i = 0; i < N; i++) printf("%s", G[i]);
        puts("");
    }

    return 0;
}
```

### 木棒

题目：https://www.acwing.com/problem/content/description/169/

题解：https://www.acwing.com/solution/content/36030/

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 70;

int n;
int W[N];
bool st[N];
int sum, len;

bool dfs(int u, int cur, int start)
{
    if (u * len == sum) return true;
    if (cur == len) return dfs(u + 1, 0, 1);

    for (int i = start; i <= n; i++)
    {
        if (st[i] || cur + W[i] > len) continue;
        st[i] = true;
        if (dfs(u, cur + W[i], i + 1)) return true;
        st[i] = false;

        if (cur == 0 || cur + W[i] == len) return false;
        int j = i + 1;
        while (j <= n && W[i] == W[j]) j++;
        i = j - 1;
    }

    return false;
}

int main()
{
    while (scanf("%d", &n), n)
    {
        len = sum = 0;
        for (int i = 1; i <= n; i++)
        {
            scanf("%d", &W[i]);
            sum += W[i];
            len = max(len, W[i]);
        }
        memset(st, false, sizeof st);

        sort(W + 1, W + 1 + n, greater<int>());
        
        while (true)
        {
            if (sum % len == 0 && dfs(0, 0, 1))
            {
                printf("%d\n", len);
                break;
            }
            len++;
        }
    }

    return 0;
}
```

### 生日蛋糕

题目：https://www.acwing.com/problem/content/description/170/

题解：https://www.acwing.com/solution/content/31876/

这个推导稍微有点错误，但是优化得非常好。

```c++
#include <cmath>
#include <climits>
#include <iostream>

using namespace std;

const int M = 25;

int n, m;
int R[M], H[M];
int res = INT_MAX;
int mnv[M], mns[M];

void dfs(int u, int s, int v)
{
    if (v + mnv[u] > n) return;

    if (s + mns[u] >= res) return;
    if (s + 2 * (n - v) / R[u + 1] >= res) return;
    
    if (u == 0)
    {
        if (v == n) res = s;
        return;
    }

    int mxv = n - mnv[u - 1] - v;
    for (int r = min(R[u + 1] - 1, int(sqrt(mxv / u))); r >= u; r--)
        for (int h = min(H[u + 1] - 1, mxv / (r * r)); h >= u; h--)
        {
            H[u] = h, R[u] = r;
            int t = u == m ? r * r : 0;
            dfs(u - 1, s + 2 * r * h + t, v + r * r * h);
        }
}

int main()
{
    scanf("%d%d", &n, &m);

    for (int i = 1; i <= m; i++)
    {
        mnv[i] = mnv[i - 1] + i * i * i;
        mns[i] = mns[i - 1] + 2 * i * i;
    }

    R[m + 1] = H[m + 1] = INT_MAX;
    dfs(m, 0, 0);

    if (res == INT_MAX) res = 0;
    printf("%d\n", res);

    return 0;
}
```

## 迭代加深

### 加成序列

题目：https://www.acwing.com/problem/content/description/172/

题解：https://www.acwing.com/solution/content/38248/

```c++
#include <iostream>

using namespace std;

const int N = 110;

int n;
int X[N];

bool dfs(int u, int depth)
{
    if (u > depth) return X[u - 1] == n;

    bool st[N] = {false};
    for (int i = u - 1; i >= 1; i--)
        for (int j = i; j >= 1; j--)
        {
            int s = X[i] + X[j];
            if (s <= X[u - 1]) return false;
            if (st[s] || s > n) continue;

            X[u] = s;
            st[s] = true;
            if (dfs(u + 1, depth)) return true;
        }

    return false;
}

int main()
{
    X[1] = 1;
    while (scanf("%d", &n), n)
    {
        int depth = 1;
        while (!dfs(2, depth)) depth++;
        for (int i = 1; i <= depth; i++) printf("%d ", X[i]);
        puts("");
    }

    return 0;
}
```

### 送礼物

题目：https://www.acwing.com/problem/content/description/173/

题解：https://www.acwing.com/solution/content/38250/

```c++
#include <iostream>
#include <algorithm>

using namespace std;
using LL = long long;

const int N = 50, M = 1 << 25;

int n, m, K;
int G[N];
int W[M], cnt;

void dfs(int u, int s)
{
    if (u == K)
    {
        W[cnt++] = s;
        return;
    }

    dfs(u + 1, s);

    if ((LL)G[u] + s <= m)
        dfs(u + 1, s + G[u]);
}

int res;
void dfs1(int u, int s)
{
    if (u >= n)
    {
        int l = 0, r = cnt - 1;
        while (l < r)
        {
            int mid = l + r + 1 >> 1;
            if (W[mid] <= m - s) l = mid;
            else r = mid - 1;
        }
        res = max(res, W[l] + s);

        return;
    }

    dfs1(u + 1, s);

    if ((LL)s + G[u] <= m) 
        dfs1(u + 1, s + G[u]);
}

int main()
{
    scanf("%d%d", &m, &n);
    for (int i = 0; i < n; i++) scanf("%d", &G[i]);

    sort(G, G + n, greater<int>());
    K = n / 2;
    dfs(0, 0);

    sort(W, W + cnt);
    int j = 1;
    for (int i = 1; i < cnt; i++)
        if (W[i] != W[i - 1])
            W[j++] = W[i];
    cnt = j;

    dfs1(K, 0);

    printf("%d\n", res);

    return 0;
}
```

## IDA*

### 排书

题目：https://www.acwing.com/problem/content/description/182/

题解：https://www.acwing.com/solution/content/4050/

```c++
#include <cstring>
#include <iostream>

using namespace std;

const int N = 20;

int n;
int seq[N];

int f()
{
    int cnt = 0;
    for (int i = 1; i < n; i++)
        if (seq[i] + 1 != seq[i + 1])
            cnt++;
    return (cnt + 2) / 3;
}

int maxDepth;
bool dfs(int depth)
{
    int t = f();
    if (t == 0) return true;
    if (depth + t > maxDepth) return false;
    
    int tmp[N];
    for (int l = 1; l <= n; l++)
        for (int r = l; r <= n; r++)
            for (int k = r + 1; k <= n; k++)
            {
                memcpy(tmp, seq, sizeof seq);
                int len = r - l + 1;
                for (int i = l, j = r + 1; j <= k; i++, j++)
                    seq[i] = tmp[j];
                for (int i = k - len + 1, j = l; j <= r; i++, j++)
                    seq[i] = tmp[j];
                if (dfs(depth + 1)) return true;
                memcpy(seq, tmp, sizeof seq);
            }

    return false;
}

int main()
{
    int T; scanf("%d", &T);

    while (T--)
    {
        scanf("%d", &n);
        for (int i = 1; i <= n; i++) scanf("%d", &seq[i]);
        
        maxDepth = 0;
        while (maxDepth < 5 && !dfs(0)) maxDepth++;

        if (maxDepth < 5) printf("%d\n", maxDepth);
        else puts("5 or more");
    }

    return 0;
}
```

### 回转游戏

题目：https://www.acwing.com/problem/content/description/183/

题解：https://www.acwing.com/solution/content/4056/

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int map[8][7] = 
{
    {0, 2, 6, 11, 15, 20, 22},
    {1, 3, 8, 12, 17, 21, 23},
    {10, 9, 8, 7, 6, 5, 4},
    {19, 18, 17, 16, 15, 14, 13},
    {23, 21, 17, 12, 8, 3, 1},
    {22, 20, 15, 11, 6, 2, 0},
    {13, 14, 15, 16, 17, 18, 19},
    {4, 5, 6, 7, 8, 9, 10}
};
const int opp[8] = {5, 4, 7, 6, 1, 0, 3, 2};
const int cen[8] = {6, 7, 8, 11, 12, 15, 16, 17};

const int N = 24, M = 128;

int arr[N];
char path[M];

int f()
{
    static int cnt[4];
    memset(cnt, 0, sizeof cnt);

    for (int i = 0; i < 8; i++)
        cnt[arr[cen[i]]]++;
    
    int mx = *max_element(cnt, cnt + 4);
    return 8 - mx;
}

void moveBy(int x)
{
    int t = arr[map[x][0]];
    for (int i = 0; i < 6; i++)
        arr[map[x][i]] = arr[map[x][i + 1]];
    arr[map[x][6]] = t;
}

int maxDepth;
bool dfs(int depth, int last)
{
    int t = f();
    if (depth + t > maxDepth) return false;
    if (t == 0) return true;

    for (int i = 0; i < 8; i++)
        if (opp[i] != last)
        {
            moveBy(i);
            path[depth] = char(i + 'A');
            if (dfs(depth + 1, i)) return true;
            moveBy(opp[i]);
        }

    return false;
}

int main()
{
    while (scanf("%d", &arr[0]), arr[0])
    {
        for (int i = 1; i < N; i++) scanf("%d", &arr[i]);

        maxDepth = 0;
        while (!dfs(0, -1)) maxDepth++;

        if (maxDepth == 0) puts("No moves needed");
        else
        {
            path[maxDepth] = '\0';
            printf("%s\n", path);
        }
        printf("%d\n", arr[cen[0]]);
    }

    return 0;
}
```

