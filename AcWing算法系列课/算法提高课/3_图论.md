# 图论

## 单源最短路的建图方式

### 热浪

题目：https://www.acwing.com/problem/content/description/1131/

**堆优化dijkstra：**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using LL = long long;
using std::cin, std::cout;

const int N = 2510, M = 6210;

int n, m;
int start, end;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M * 2];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

bool st[N];
int dist[N];

void dijkstra()
{
    struct Node
    {
        int d, v;

        bool operator< (const Node &ct) const
        {
            return d >= ct.d;
        }
    };
    std::priority_queue<Node> Q;

    memset(dist, 0x3f, sizeof dist);
    dist[start] = 0;
    Q.push({0, start});

    while (!Q.empty())
    {
        auto [d, u] = Q.top(); Q.pop();

        if (st[u]) continue;
        st[u] = true;

        if (u == end) return;

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (d + w < dist[v])
            {
                dist[v] = d + w;
                Q.push({dist[v], v});
            }
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m >> start >> end;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w), add(b, a, w);
    }

    dijkstra();

    cout << dist[end] << '\n';

    return 0;
}
```

**spfa：**

```c++
#include <cstring>
#include <iostream>
#include <queue>

using namespace std;

const int N = 2510, M = 6210, INF = 0x3f3f3f3f;

int n, m, start, dest;
int H[N];
struct ListNode
{
    int v, w, n;
} L[M * 2]; int idx = 1;

void add(int a, int b, int w)
{
    L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

int dist[N];
bool st[N];
void spfa()
{
    memset(dist, 0x3f, sizeof dist);
    queue<int> Q;
    dist[start] = 0;
    st[start] = true;
    Q.push(start);
    
    while (!Q.empty())
    {
        int cur = Q.front(); Q.pop();
        st[cur] = false;

        for (int p = H[cur]; p; p = L[p].n)
        {
            int v = L[p].v, w = L[p].w;
            if (dist[cur] + w < dist[v])
            {
                dist[v] = dist[cur] + w;
                if (!st[v])
                {
                    st[v] = true;
                    Q.push(v);
                }
            }
        }
    }
}

int main()
{
    scanf("%d%d%d%d", &n, &m, &start, &dest);
    for (int i = 1; i <= m; i++)
    {
        int a, b, w; scanf("%d%d%d", &a, &b, &w);
        add(a, b, w), add(b, a, w);
    }

    spfa();

    printf("%d\n", dist[dest]);

    return 0;
}
```

### 信使

题目：https://www.acwing.com/problem/content/description/1130/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using LL = long long;
using std::cin, std::cout;

const int N = 110, M = 210, INF = 0x3f3f3f3f;

int n, m;
int G[N][N];

bool st[N];
int dist[N];
int res;

bool dijkstra()
{
    struct Node
    {
        int d, v;

        bool operator< (const Node &ct) const
        {
            return d >= ct.d;
        }
    };
    std::priority_queue<Node> Q;
    Q.push({0, 1});
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    int cnt = 0;
    while (!Q.empty())
    {
        auto [d, u] = Q.top(); Q.pop();

        if (st[u]) continue;
        st[u] = true;

        cnt++;
        res = std::max(res, dist[u]);

        for (int v = 1; v <= n; v++)
            if (d + G[u][v] < dist[v])
            {
                dist[v] = d + G[u][v];
                Q.push({dist[v], v});
            }
    }

    return cnt == n;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    memset(G, 0x3f, sizeof G);
    for (int i = 0; i < N; i++) G[i][i] = 0;

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        G[a][b] = G[b][a] = std::min(G[a][b], w);
    }

    if (dijkstra()) cout << res << '\n';
    else cout << -1 << '\n';
    
    return 0;
}
```

### 香甜的黄油

题目：https://www.acwing.com/problem/content/description/1129/

本题用floyd算法无法通过。

**spfa：**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using LL = long long;
using std::cin, std::cout;

const int N = 1000, M = 3000, INF = 0x3f3f3f3f;

int n, m, numCow;
int cow[N];
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

int dist[N];
bool st[N];

void spfa(int start)
{
    memset(dist, 0x3f, sizeof dist);
    memset(st, 0, sizeof st);
    std::queue<int> Q;
    Q.push(start);
    st[start] = true;
    dist[start] = 0;

    while (!Q.empty())
    {
        int u = Q.front(); Q.pop();
        st[u] = false;

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[u] + w < dist[v])
            {
                dist[v] = dist[u] + w;
                if (!st[v])
                {
                    Q.push(v);
                    st[v] = true;
                }
            }
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> numCow >> n >> m;
    for (int i = 1; i <= numCow; i++) cin >> cow[i];
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w), add(b, a, w);
    }

    int res = INF;
    for (int i = 1; i <= n; i++)
    {
        spfa(i);
        int sum = 0;
        for (int i = 1; i <= numCow; i++)
        {
            if (dist[cow[i]] == INF)
            {
                sum = INF;
                break;
            }
            sum += dist[cow[i]];
        }
        res = std::min(res, sum);
    }

    cout << res << '\n';

    return 0;
}
```

**堆优化dijkstra：**

就本题来说，dijkstra比spfa慢多了。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using LL = long long;
using std::cin, std::cout;

const int N = 1000, M = 3000, INF = 0x3f3f3f3f;

int n, m;
int cow[N], numCow;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

int dist[N];
bool st[N];

void dijkstra(int start)
{
    struct Node
    {
        int d, v;

        bool operator< (const Node &ct) const
        {
            return d >= ct.d;
        }
    };
    std::priority_queue<Node> Q;
    Q.push({0, start});
    memset(dist, 0x3f, sizeof dist);
    dist[start] = 0;
    memset(st, 0, sizeof st);

    while (!Q.empty())
    {
        auto [d, u] = Q.top(); Q.pop();

        if (st[u]) continue;
        st[u] = true;

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (d + w < dist[v])
            {
                dist[v] = d + w;
                Q.push({dist[v], v});
            }
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> numCow >> n >> m;
    for (int i = 1; i <= numCow; i++) cin >> cow[i];
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w), add(b, a, w);
    }

    int res = INF;
    for (int i = 1; i <= n; i++)
    {
        dijkstra(i);
        int sum = 0;
        for (int j = 1; j <= numCow; j++)
        {
            if (dist[cow[j]] == INF)
            {
                sum = INF;
                break;
            }
            sum += dist[cow[j]];
        }
        res = std::min(res, sum);
    }

    cout << res << '\n';

    return 0;
}
```

### 最小花费

题目：https://www.acwing.com/problem/content/description/1128/

题解：https://www.acwing.com/solution/content/94237/

**dijkstra：**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 2005;

int n, m;
int start, end;
double G[N][N];

double dist[N];
bool st[N];

void dijkstra()
{
    dist[start] = 1;

    for (int i = 0; i < n; i++)
    {
        int u = -1;
        for (int j = 1; j <= n; j++)
            if (!st[j] && (u == -1 || dist[j] > dist[u]))
                u = j;

        st[u] = true;
        if (u == end) return;

        for (int v = 1; v <= n; v++)
            dist[v] = std::max(dist[v], dist[u] * G[u][v]);
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    for (int i = 0; i < N; i++) G[i][i] = 1;

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        G[a][b] = G[b][a] = std::max(G[a][b], double(100 - w) / 100);
    }
    cin >> start >> end;

    dijkstra();

    printf("%.8lf\n", 100 / dist[end]);

    return 0;
}
```

**spfa：**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 2010;

int n, m;
int start, end;
double G[N][N];

double dist[N];
bool st[N];
int Q[N], hh, tt;

void spfa()
{
    dist[start] = 1;
    Q[tt++] = start;
    st[start] = true;

    while (hh != tt)
    {
        int u = Q[hh++]; hh %= N;
        st[u] = false;

        for (int v = 1; v <= n; v++)
            if (dist[u] * G[u][v] > dist[v])
            {
                dist[v] = dist[u] * G[u][v];
                if (!st[v])
                {
                    Q[tt++] = v; tt %= N;
                    st[v] = true;
                }
            }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    for (int i = 0; i < N; i++) G[i][i] = 1;

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        G[a][b] = G[b][a] = std::max(G[a][b], double(100 - w) / 100);
    }
    cin >> start >> end;

    spfa();

    printf("%.8lf\n", 100 / dist[end]);

    return 0;
}
```



### 最优乘车

题目：https://www.acwing.com/problem/content/description/922/

本题难在建图。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <sstream>

using LL = long long;
using std::cin, std::cout;

const int N = 510, M = 110;

int n, m;
bool G[N][N];
int stop[M];

int Q[N], hh, tt;
bool st[N];
int dist[N];

bool bfs()
{
    Q[tt++] = 1;
    st[1] = true;
    dist[1] = -1;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int v = 1; v <= n; v++)
            if (G[u][v] && !st[v])
            {
                dist[v] = dist[u] + 1;
                st[v] = true;
                if (v == n) return true;
                Q[tt++] = v;
            }
    }

    return false;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> m >> n; 
    std::string line;
    std::getline(cin, line); // 读回车
    for (int i = 0; i < m; i++)
    {
        std::getline(cin, line);
        std::stringstream ss(line);
        int p = 0, cnt = 0;
        while (ss >> p) stop[++cnt] = p;
        for (int j = 1; j <= cnt; j++)
            for (int k = j + 1; k <= cnt; k++)
                G[stop[j]][stop[k]] = true;
    }

    if (bfs()) cout << dist[n] << '\n';
    else cout << "NO" << '\n';

    return 0;
}
```

### 昂贵的聘礼

题目：https://www.acwing.com/problem/content/description/905/

思路是反向建图，0号点是虚拟原点，从0号点到其他点的边权是直接购买该物品需要的钱。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 110, INF = 0x3f3f3f3f;

int n, m;
int G[N][N];
int L[N];

int dist[N];
bool st[N];

bool dijkstra(int dn, int up)
{
    memset(dist, 0x3f, sizeof dist);
    memset(st, 0, sizeof st);
    dist[0] = 0;

    for (int i = 0; i <= n; i++)
    {
        int u = -1;
        for (int j = 0; j <= n; j++)
            if (!st[j] && (u == -1 || dist[j] < dist[u]))
                u = j;

        st[u] = true;
        if (u == 1) return true;

        for (int v = 1; v <= n; v++)
            if (L[v] >= dn && L[v] <= up)
                dist[v] = std::min(dist[v], dist[u] + G[u][v]);
    }

    return false;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    memset(G, 0x3f, sizeof G);
    for (int i = 0; i < N; i++) G[i][i] = 0;

    cin >> m >> n;
    for (int i = 1; i <= n; i++)
    {
        int p, l, x; cin >> p >> l >> x;
        G[0][i] = std::min(G[0][i], p);
        L[i] = l;
        while (x--)
        {
            int t, v; cin >> t >> v;
            G[t][i] = std::min(G[t][i], v);
        }
    }

    int res = INF;
    for (int i = L[1] - m; i <= L[1]; i++)
        if (dijkstra(i, i + m))
            res = std::min(res, dist[1]);

    cout << res << '\n';
    return 0;
}
```

## 单源最短路的综合应用

### 新年好

题目：https://www.acwing.com/problem/content/description/1137/

先将1和输入给的五个点分别做源点使用dijkstra，之后通过dfs搜索访问顺序。

```c++
#include <cstring>
#include <iostream>
#include <queue>

using namespace std;

const int N = 5e4 + 10, M = 2e5 + 10, INF = 0x3f3f3f3f;

int n, m;
int sou[6];
int H[N];
struct ListNode
{
   int v, w, n;
} L[M];
int idx = 1;

void add(int a, int b, int w)
{
   L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

int dist[6][N];
bool st[N];
void dijkstra(int start, int dist[])
{
   memset(st, false, sizeof st);
   memset(dist, 0x3f, N * sizeof(int));
   dist[start] = 0;

   struct Node
   {
      int v, d;

      Node(int v, int d) : v(v), d(d) {}

      bool operator<(const Node &ct) const
      {
         return d > ct.d;
      }
   };
   priority_queue<Node> heap;
   heap.push(Node(start, 0));

   while (!heap.empty())
   {
      auto cur = heap.top();
      heap.pop();

      if (st[cur.v]) continue;
      else st[cur.v] = true;

      for (int p = H[cur.v]; p; p = L[p].n)
      {
         int v = L[p].v, w = L[p].w;
         if (dist[cur.v] + w < dist[v])
         {
            dist[v] = dist[cur.v] + w;
            heap.push(Node(v, dist[v]));
         }
      }
   }
}

int res;
void dfs(int i, int pre, int path)
{
   if (i == 6)
   {
      res = min(res, path);
      return;
   }

   for (int j = 1; j <= 5; j++)
      if (!st[j])
      {
         st[j] = true;
         dfs(i + 1, j, path + dist[pre][sou[j]]);
         st[j] = false;
      }
}

int main()
{
   scanf("%d%d", &n, &m);
   sou[0] = 1;
   for (int i = 1; i <= 5; i++)
      scanf("%d", &sou[i]);
   for (int i = 1; i <= m; i++)
   {
      int a, b, w; scanf("%d%d%d", &a, &b, &w);
      add(a, b, w), add(b, a, w);
   }

   for (int i = 0; i < 6; i++)
      dijkstra(sou[i], dist[i]);

   res = INF;
   for (int i = 1; i <= 5; i++) st[i] = false;
   dfs(1, 0, 0);

   printf("%d\n", res);

   return 0;
}
```

### 通信线路

题目：https://www.acwing.com/problem/content/description/342/

题解：https://www.acwing.com/solution/content/13645/

```c++
#include <cstring>
#include <iostream>
#include <deque>

using namespace std;

const int N = 1010, M = 2e4 + 10, INF = 0x3f3f3f3f, MAX_LEN = 1e6;

int n, m, K;
int H[N];
struct ListNode
{
   int v, w, n;
} L[M]; int idx = 1;

void add(int a, int b, int w)
{
   L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

bool st[N];
int dist[N];
void dijkstra(int x) // 双端队列广搜
{
   memset(st, false, sizeof st);
   memset(dist, 0x3f, sizeof dist);
   dist[1] = 0;
   deque<int> dq;
   dq.push_back(1);

   while (!dq.empty())
   {
      int cur = dq.front(); dq.pop_front();
      
      if (st[cur]) continue;
      else st[cur] = true;

      for (int p = H[cur]; p; p = L[p].n)
      {
         int v = L[p].v, w = L[p].w > x ? 1 : 0;
         if (dist[cur] + w < dist[v])
         {
            dist[v] = dist[cur] + w;
            if (w) dq.push_back(v);
            else dq.push_front(v);
         }
      }
   }
}

bool check(int x)
{
   dijkstra(x);
   return dist[n] <= K;
}

int main()
{
   scanf("%d%d%d", &n, &m, &K);
   for (int i = 1; i <= m; i++)
   {
      int a, b, w; scanf("%d%d%d", &a, &b, &w);
      add(a, b, w), add(b, a, w);
   }

   dijkstra(0);
   if (dist[n] == INF) // 检查是否可达
   {
      puts("-1");
      return 0;
   }

   int l = 0, r = MAX_LEN;
   while (l < r)
   {
      int mid = l + r >> 1;
      if (check(mid)) r = mid;
      else l = mid + 1;
   }
   printf("%d\n", l);

   return 0;
}
```

### 道路与航线

题目：https://www.acwing.com/problem/content/description/344/

题解：https://www.acwing.com/solution/content/33202/

```c++
#include <iostream>
#include <cstring>
#include <vector>
#include <queue>

using namespace std;

const int N = 25010, M = 15e4 + 10, INF = 0x3f3f3f3f;

int n, mr, mp, s;
int H[N];
struct ListNode
{
   int v, w, n;
} L[M]; int idx = 1;

void add(int a, int b, int w)
{
   L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

int bcnt;
vector<int> block[N];
int bid[N];
void dfs(int u)
{
   bid[u] = bcnt;
   block[bcnt].push_back(u);
   for (int p = H[u]; p; p = L[p].n)
   {
      int v = L[p].v;
      if (!bid[v]) dfs(v);
   }
}

struct Node
{
   int v, d;
   Node(int v, int d) : v(v), d(d) {}
   bool operator< (const Node& ct) const
   {
      return d > ct.d;
   }
};
int bin[N];
queue<int> q; // 记录bid
int dist[N];
bool st[N];

void dijkstra(int id)
{
   priority_queue<Node> heap;
   for (auto v : block[id]) heap.push(Node(v, dist[v]));

   while (!heap.empty())
   {
      auto cur = heap.top(); heap.pop();

      if (st[cur.v]) continue;
      else st[cur.v] = true;

      for (int p = H[cur.v]; p; p = L[p].n)
      {
         int v = L[p].v, w = L[p].w;
         if (bid[cur.v] != bid[v] && --bin[bid[v]] == 0) q.push(bid[v]);
         if (dist[cur.v] + w < dist[v])
         {
            dist[v] = dist[cur.v] + w;
            if (bid[cur.v] == bid[v]) heap.push(Node(v, dist[v]));
         }
      }
   }
}

void topsort()
{
   for (int i = 1; i <= bcnt; i++)
      if (bin[i] == 0) 
         q.push(i);

   memset(dist, 0x3f, sizeof dist);
   dist[s] = 0;

   while (!q.empty())
   {
      int cur = q.front(); q.pop();
      dijkstra(cur);
   }
}

int main()
{
   scanf("%d%d%d%d", &n, &mr, &mp, &s);
   for (int i = 1; i <= mr; i++)
   {
      int a, b, w; scanf("%d%d%d", &a, &b, &w);
      add(a, b, w), add(b, a, w);
   }

   for (int i = 1; i <= n; i++)
      if (!bid[i])
      {
         bcnt++;
         dfs(i);
      }

   for (int i = 1; i <= mp; i++)
   {
      int a, b, w; scanf("%d%d%d", &a, &b, &w);
      add(a, b, w);
      bin[bid[b]]++;
   }

   topsort();

   for (int i = 1; i <= n; i++)
   {
      if (dist[i] > INF / 2) puts("NO PATH");
      else printf("%d\n", dist[i]);
   }

   return 0;
}
```

### 最优贸易

题目：https://www.acwing.com/problem/content/description/343/

题解：https://www.acwing.com/solution/content/3709/

```c++
#include <iostream>
#include <cstring>
#include <queue>

using namespace std;

const int N = 1e5 + 10, M = 2e6 + 10, INF = 0x3f3f3f3f;

int n, m;
int H[N], RH[N];
struct ListNode
{
   int v, n;
} L[M]; int idx = 1;

void Add(int H[], int a, int b)
{
   L[idx].v = b, L[idx].n = H[a], H[a] = idx++;
}

int W[N];

bool st[N];
int mn[N], mx[N];
void Spfa(int d[], int H[], int start, bool flag)
{
   if (flag) memset(mn, 0x3f, sizeof mn);

   memset(st, false, sizeof st);
   queue<int> q;
   q.push(start);
   st[start] = true;
   d[start] = W[start];

   while (!q.empty())
   {
      int cur = q.front(); q.pop();
      st[cur] = false;

      for (int p = H[cur]; p; p = L[p].n)
      {
         int v = L[p].v;
         if ((flag && min(d[cur], W[v]) < d[v]) || (!flag && max(d[cur], W[v]) > d[v]))
         {
            if (flag) d[v] = min(d[cur], W[v]);
            else d[v] = max(d[cur], W[v]);

            if (!st[v])
            {
               q.push(v);
               st[v] = true;
            }
         }
      }
   }
}

int main()
{
   scanf("%d%d", &n, &m);
   for (int i = 1; i <= n; i++) scanf("%d", &W[i]);
   for (int i = 1; i <= m; i++)
   {
      int a, b, c; scanf("%d%d%d", &a, &b, &c);
      Add(H, a, b), Add(RH, b, a);
      if (c == 2) Add(H, b, a), Add(RH, a, b);
   }

   Spfa(mn, H, 1, true);
   Spfa(mx, RH, n, false);

   int res = 0;
   for (int i = 1; i <= n; i++)
      res = max(res, mx[i] - mn[i]);

   printf("%d\n", res);

   return 0;
}
```

## 单源最短路的扩展应用

### 选择最佳线路

题目：https://www.acwing.com/problem/content/description/1139/

可以把不显示地建立虚拟源点。也可以显示地建立虚拟源点，可以设定0号点为虚拟源点，那么这个时候应该改为`memset(H, -1, sizeof H)`，相应的后续遍历也要修改`for (int p = H[cur]; ~p; p = L[p].n)`，并且需要为增加`M`存多出来的虚拟边。

```c++
#include <cstring>
#include <iostream>
#include <queue>

using namespace std;

const int N = 1010, M = 2e4 + 10, INF = 0x3f3f3f3f;


int n, m, dest;
int H[N];
struct ListNode
{
	int v, w, n;
} L[M]; int idx = 1;

void Add(int a, int b, int w)
{
	L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

int start[N], cnt;
int dist[N];
bool st[N];
void Spfa()
{
	memset(dist, 0x3f, sizeof dist);
	queue<int> q;
	for (int i = 1; i <= cnt; i++)
	{
		q.push(start[i]);
		dist[start[i]] = 0;
		st[start[i]] = true;
	}

	while (!q.empty())
	{
		int cur = q.front(); q.pop();
		st[cur] = false;

		for (int p = H[cur]; p; p = L[p].n)
		{
			int v = L[p].v, w = L[p].w;
			if (dist[cur] + w < dist[v])
			{
				dist[v] = dist[cur] + w;

				if (!st[v])
				{
					q.push(v);
					st[v] = true;
				}
			}
		}
	}
}

int main()
{
	while (scanf("%d%d%d", &n, &m, &dest) != EOF)
	{
		memset(H, 0, sizeof H);
		idx = 1;
		for (int i = 1; i <= m; i++)
		{
			int a, b, w; scanf("%d%d%d", &a, &b, &w);
			Add(a, b, w);
		}

		scanf("%d", &cnt);
		for (int i = 1; i <= cnt; i++) scanf("%d", &start[i]);
		
		Spfa();

		if (dist[dest] == INF) puts("-1");
		else printf("%d\n", dist[dest]);
	}

	return 0;
}
```

### 拯救大兵瑞恩

题目：https://www.acwing.com/problem/content/description/1133/

本题比较复杂，首先网格和图在本做法中不是一回事，网格需要用`G[N][N]`映射到一维图。在Dijkstra的搜索中，在由一维图增加一维$state$生成的一个新的二维图上搜索。

```c++
#include <iostream>
#include <unordered_set>
#include <deque>
#include <cstring>

using namespace std;

const int N = 12, N_2 = N * N, M = 400, S = 1 << 10;

int n, m, P, K, tot;
int G[N][N]; // 网格到图的id的映射
int H[N_2];
struct ListNode // w = 0表示无障碍，w > 0表示有w类型的门
{
	int v, w, n;
} L[M]; int idx = 1;

void Add(int a, int b, int w)
{
	L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

// 存储门和墙，高16位表示一个点，低16位表示另一个点
unordered_set<int> obs; 

void Build()
{
	int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
		{
			int cur = G[i][j];
			for (int k = 0; k < 4; k++)
			{
				int x = i + dx[k], y = j + dy[k];
				if (x < 1 || x > n || y < 1 || y > m) continue;
				int nxt = G[x][y];
				if (obs.count((cur << 16) + nxt)) continue;
				Add(cur, nxt, 0);
			}
		}
}

int key[N_2];
int dist[N_2][S];
bool st[N_2][S];
int Dijkstra() 
{
	memset(dist, 0x3f, sizeof dist);
	dist[1][0] = 0;

	struct Node // 重新映射到二维图
	{
		int id, state;
		Node(int id, int state) : id(id), state(state) {}
	};
	deque<Node> dq;
	dq.push_front(Node(1, 0));

	while (!dq.empty())
	{
		auto cur = dq.front(); dq.pop_front();

		if (st[cur.id][cur.state]) continue;
		else st[cur.id][cur.state] = true;

		if (cur.id == tot) return dist[cur.id][cur.state];

		if (key[cur.id])
		{
			int ns = cur.state | key[cur.id];
			if (dist[cur.id][cur.state] < dist[cur.id][ns])
			{
				dist[cur.id][ns] = dist[cur.id][cur.state];
				dq.push_front(Node(cur.id, ns));
			}
		}

		for (int p = H[cur.id]; p; p = L[p].n)
		{
			int v = L[p].v, w = L[p].w;
			if (w && !((1 << (w - 1)) & cur.state)) continue;
			if (dist[cur.id][cur.state] + 1 < dist[v][cur.state])
			{
				dist[v][cur.state] = dist[cur.id][cur.state] + 1;
				dq.push_back(Node(v, cur.state));
			}
		}
	}

	return -1;
}

int main()
{
	scanf("%d%d%d", &n, &m, &P);

	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			G[i][j] = ++tot;

	scanf("%d", &K);
	for (int i = 1; i <= K; i++)
	{
		int x1, y1, x2, y2, w; scanf("%d%d%d%d%d", &x1, &y1, &x2, &y2, &w);
		int a = G[x1][y1], b = G[x2][y2];
		obs.insert((a << 16) + b), obs.insert((b << 16) + a);
		if (w) Add(a, b, w), Add(b, a, w);
	}

	Build(); // 建成一维图

	int s; scanf("%d", &s);
	while (s--)
	{
		int x, y, q; scanf("%d%d%d", &x, &y, &q);
		key[G[x][y]] |= 1 << (q - 1);
	}

	printf("%d\n", Dijkstra());

	return 0;
}
```

### 最短路计数

题目：https://www.acwing.com/problem/content/description/1136/

题解：https://www.acwing.com/solution/content/56390/

```c++
#include <cstring>
#include <iostream>

using namespace std;

const int N = 1e5 + 10, M = 4e5 + 10;
const int MOD = 100003, INF = 0x3f3f3f3f;

int n, m;
int H[N];
struct ListNode
{
    int v, n;
} L[M]; int idx = 1;

void Add(int a, int b)
{
    L[idx].v = b, L[idx].n = H[a], H[a] = idx++;
}

int dist[N], cnt[N];
int Q[N], hh, tt;
void Bfs()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0, cnt[1] = 1;
    hh = 0, tt -1;
    Q[++tt] = 1;

    while (hh <= tt)
    {
        int cur = Q[hh++];

        for (int p = H[cur]; p; p = L[p].n)
        {
            int v = L[p].v;
            if (int mn = dist[cur] + 1; mn < dist[v])
            {
                dist[v] = mn;
                cnt[v] = cnt[cur];
                Q[++tt] = v;
            }
            else if (mn == dist[v])
                cnt[v] = (cnt[v] + cnt[cur]) % MOD;
        }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++)
    {
        int a, b; scanf("%d%d", &a, &b);
        Add(a, b), Add(b, a);
    }

    Bfs();

    for (int i = 1; i <= n; i++)
        printf("%d\n", cnt[i]);

    return 0;
}
```

### 观光

题目：https://www.acwing.com/problem/content/description/385/

题解：https://www.acwing.com/solution/content/12246/

本题的核心是理解次段路径是如何更新的，最短路径只能被最短路径的前驱更新，但是次短路径要被最短路径和次短路径的前驱更新。

从队列中取出一个点，该点没有加入st数组中，那么该点一定是最短路径或者次短路径（记录在`Node.t`中）

```c++
#include <iostream>
#include <cstring>
#include <queue>

using namespace std;

const int N = 1010, M = 1e4 + 10;
const int INF = 0x3f3f3f3f;

int n, m;
int H[N];
struct ListNode
{
    int v, w, n;
} L[M]; int idx = 1;

void Add(int a, int b, int w)
{
    L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

int S, F;
bool st[N][2];
int dist[N][2], cnt[N][2];
struct Node
{
    int v, t, d;
    Node(int v, int t, int d) : v(v), t(t), d(d) {}
    bool operator< (const Node& ct) const
    {
        return d > ct.d;
    }
};
void Dijkstra()
{
    memset(st, false, sizeof st);
    memset(dist, 0x3f, sizeof dist);
    memset(cnt, 0, sizeof cnt);
    priority_queue<Node> heap;

    dist[S][0] = 0;
    cnt[S][0] = 1;
    heap.push(Node(S, 0, 0));

    while (!heap.empty())
    {
        auto cur = heap.top(); heap.pop();

        if (st[cur.v][cur.t]) continue;
        else st[cur.v][cur.t] = true;
        
        for (int p = H[cur.v]; p; p = L[p].n)
        {
            int v = L[p].v, w = L[p].w;

            int len = dist[cur.v][cur.t] + w;
            if (cur.t == 0)
            {
                if (len < dist[v][0])
                {
                    dist[v][1] = dist[v][0], cnt[v][1] = cnt[v][0];
                    heap.push(Node(v, 1, dist[v][1]));
                    dist[v][0] = len, cnt[v][0] = cnt[cur.v][0];
                    heap.push(Node(v, 0, len));
                }
                else if (len == dist[v][0])
                    cnt[v][0] += cnt[cur.v][0];
                else if (len < dist[v][1])
                {
                    dist[v][1] = len, cnt[v][1] = cnt[cur.v][0];
                    heap.push(Node(v, 1, len));
                }
                else if (len == dist[v][1])
                    cnt[v][1] += cnt[cur.v][0];
            }
            else // type = 1
            {
                if (len < dist[v][1])
                {
                    dist[v][1] = len;
                    cnt[v][1] = cnt[cur.v][1];
                    heap.push(Node(v, 1, len));
                }
                else if (len == dist[v][1])
                    cnt[v][1] += cnt[cur.v][1];
            }
        }
    }
}

int main()
{
    int T; scanf("%d", &T);

    while (T--)
    {
        scanf("%d%d", &n, &m);
        memset(H, 0, sizeof H);
        idx = 1;
        for (int i = 1; i <= m; i++)
        {
            int a, b, w; scanf("%d%d%d", &a, &b, &w);
            Add(a, b, w);
        }
        scanf("%d%d", &S, &F);
        
        Dijkstra();

        int res = cnt[F][0];
        if (dist[F][1] == dist[F][0] + 1)
            res += cnt[F][1];
        printf("%d\n", res);
    }

    return 0;
}
```

## Floyd算法

### 牛的旅行

题目：https://www.acwing.com/problem/content/1127/

先用floyd，然后用floyd的结论`D[n][n]`去求连通块内距离每个点最远的点，记录在maxd数组中。

之后依次尝试连接两个不连通的点i和j，计算它们构成的连通块并通过这两个点的最大距离，即`maxd[i] + maxd[j] + D[i][j]`。

最终的答案有两种情况，如果任意新构成的连通块的直径没有连通之前的最大直径大，那么答案为连通之前的最大直径；如果连通后的连通块的直径更大，那么答案应该为连通后的连通块的最小直径。

```c++
#include <iostream>
#include <cmath>
#include <algorithm>

using namespace std;

const int N = 160;
const double INF = 1e10;

struct Pt
{
    int x, y;
};

int n;
Pt cdn[N];
char G[N][N];
double D[N][N], maxd[N];

inline double GetDist(Pt& a, Pt& b)
{
    double dx = a.x - b.x, dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
}

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d%d", &cdn[i].x, &cdn[i].y);
    for (int i = 1; i <= n; i++) scanf("%s", G[i] + 1);

    for (int i = 1; i < n; i++)
        for (int j = i + 1; j <= n; j++)
        {
            if (G[i][j] == '1')
                D[i][j] = D[j][i] = GetDist(cdn[i], cdn[j]);
            else D[i][j] = D[j][i] = INF;
        }
    
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                D[i][j] = min(D[i][j], D[i][k] + D[k][j]);

    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            if (D[i][j] < INF)
                maxd[i] = max(maxd[i], D[i][j]);

    double res1 = *max_element(maxd + 1, maxd + 1 + n);
    double res2 = INF;
    for (int i = 1; i < n; i++)
        for (int j = i + 1; j <= n; j++)
            if (D[i][j] >= INF)
            {
                double d = GetDist(cdn[i], cdn[j]) + maxd[i] + maxd[j];
                res2 = min(res2, d);
            }
    double res = max(res1, res2);
    printf("%.6lf\n", res);

    return 0;
}
```

### 排序

题目：https://www.acwing.com/problem/content/description/345/

**传递闭包/在线Floyd：**

```c++
#include <iostream>
#include <cstring>

using namespace std;

const int N = 26;

int n, m;
bool D[N][N];
int in[N], cnt, tot;
int Q[N], hh, tt;
int rel, flag;

void connect(int a, int b)
{
    D[a][b] = true, in[b]++, cnt++;
    if (a == b) flag = 2;
}

void Floyd(int a, int b) // 在线Floyd
{
    for (int i = 0; i < n; i++)
    {
        if (!D[i][b] && D[i][a]) connect(i, b);
        if (!D[a][i] && D[b][i]) connect(a, i);
    }

    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            if (!D[i][j] && D[i][a] && D[b][j])
                connect(i, j);
}

bool check(int i)
{
    if (flag != 3)
    {
        rel = i;
        return true;
    }
    return false;
}

int main()
{
    while (scanf("%d%d", &n, &m), n || m)
    {
        memset(D, false, sizeof D);
        memset(in, 0, sizeof in);
        cnt = 0, tot = n * (n - 1) / 2;

        char str[4];
        rel = m, flag = 3; // 1-确定，2-有矛盾，3-未定

        for (int i = 1; i <= m; i++)
        {
            scanf("%s", str);
            if (flag != 3) continue;
            int a = str[0] - 'A', b = str[2] - 'A';
            if (D[a][b]) continue;
            connect(a, b);
            if (check(i)) continue;
            Floyd(a, b);
            if (check(i)) continue;
            if (cnt == tot)
            {
                rel = i;
                flag = 1;
            }
        }

        if (flag == 2) printf("Inconsistency found after %d relations.\n", rel);
        else if (flag == 3) puts("Sorted sequence cannot be determined.");
        else
        {
            printf("Sorted sequence determined after %d relations: ", rel);
            hh = 0, tt = -1;
            for (int j = 0; j < n; j++)
                if (in[j] == 0)
                {
                    Q[++tt] = j;
                    break;
                }
            while (hh <= tt)
            {
                int cur = Q[hh++];
                printf("%c", char(cur + 'A'));
                for (int k = 0; k < n; k++)
                    if (D[cur][k])
                        if (--in[k] == 0)
                            Q[++tt] = k;
            }
            puts(".");
        }
    }
    return 0;
}
```

### 观光之旅

题目：https://www.acwing.com/problem/content/description/346/

题解：https://www.acwing.com/solution/content/144021/

```c++
#include <cstring>
#include <iostream>

using namespace std;
using LL = long long;

const int N = 110, INF = 0x3f3f3f3f;

int n, m;
int W[N][N], D[N][N], P[N][N];
int path[N], cnt;

void GetPath(int i, int j)
{
    if (P[i][j] == 0) return;
    int k = P[i][j];
    GetPath(k, j);
    path[cnt++] = k;
    GetPath(i, k);
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(W, 0x3f, sizeof W);
    for (int i = 1; i <= n; i++) W[i][i] = 0;
    for (int i = 1; i <= m; i++)
    {
        int a, b, w; scanf("%d%d%d", &a, &b, &w);
        W[a][b] = W[b][a] = min(W[a][b], w);
    }

    memcpy(D, W, sizeof D);
    int res = INF;
    for (int k = 1; k <= n; k++)
    {
        for (int i = 1; i < k; i++)
            for (int j = i + 1; j < k; j++)
                if (LL len = (LL)D[i][j] + W[i][k] + W[k][j]; len < res)
                {
                    res = len;
                    cnt = 0;
                    path[cnt++] = i, path[cnt++] = k, path[cnt++] = j;
                    GetPath(i, j);
                }

        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                if (int len = D[i][k] + D[k][j]; len < D[i][j])
                {
                    D[i][j] = len;
                    P[i][j] = k;
                }
    }

    if (res == INF) puts("No solution.");
    else
    {
        for (int i = 0; i < cnt; i++) printf("%d ", path[i]);
        puts("");
    }

    return 0;
}
```

### 牛站

题目：https://www.acwing.com/problem/content/description/347/

题解：https://www.acwing.com/solution/content/36603/

本题的特色是理解res数组和G数组的初始化区别。G是不能把`G[i][i]`设置为0的，因为这样可能会在计算时导致少算边数；res数组将`res[i][i]`设置为0是因为必须保证第一次的`mul(res, res, G)`得到的res数组和G数组相同。

```c++
#include <cstring>
#include <iostream>

using namespace std;

const int N = 1e6 + 10, M = 210, INF = 0x3f3f3f3f;

int n, m, S, E, K;
int ids[N];
int G[M][M], res[M][M];

void mul(int C[M][M], int A[M][M], int B[M][M])
{
    static int tmp[M][M];
    memset(tmp, 0x3f, sizeof tmp);

    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                tmp[i][j] = min(tmp[i][j], A[i][k] + B[k][j]);

    memcpy(C, tmp, sizeof tmp);
}

void FastPow()
{
    while (K)
    {
        if (K & 1) mul(res, res, G);
        mul(G, G, G);
        K >>= 1;
    }
}

int main()
{
    scanf("%d%d%d%d", &K, &m, &S, &E);
    memset(G, 0x3f, sizeof G);
    for (int i = 1; i <= m; i++)
    {
        int a, b, w; scanf("%d%d%d", &w, &a, &b);
        if (ids[a] == 0) ids[a] = ++n;
        if (ids[b] == 0) ids[b] = ++n;
        a = ids[a], b = ids[b];

        G[a][b] = G[b][a] = min(G[a][b], w);
    }
    S = ids[S], E = ids[E];

    memset(res, 0x3f, sizeof res);
    for (int i = 1; i <= n; i++) res[i][i] = 0;
    FastPow();

    printf("%d\n", res[S][E]);

    return 0;
}
```

## 最小生成树

### 最短网络

题目：https://www.acwing.com/problem/content/description/1142/

```c++
#include <cstring>
#include <iostream>

using namespace std;

const int N = 110;

int n;
int G[N][N];
int dist[N];
bool st[N];

int Prim()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    int res = 0;
    for (int i = 1; i <= n; i++)
    {
        int cur = -1;
        for (int j = 1; j <= n; j++)
            if (!st[j] && (cur == -1 || dist[j] < dist[cur]))
                cur = j;

        st[cur] = true;
        res += dist[cur];

        for (int j = 1; j <= n; j++)
            if (!st[j] && G[cur][j] < dist[j])
                dist[j] = G[cur][j];
    }

    return res;
}

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            scanf("%d", &G[i][j]);

    printf("%d\n", Prim());

    return 0;
}
```

### 局域网

题目：https://www.acwing.com/problem/content/description/1143/

Kruskal算法可以用于求“最小生成森林”。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110, M = 210;

int n, m;
struct Edge
{
    int a, b, w;
    bool operator< (const Edge& ct) const
    {
        return w < ct.w;
    }
} E[M];

int P[N];

int Find(int x)
{
    if (x != P[x]) P[x] = Find(P[x]);
    return P[x];
}

int Kruskal()
{
    for (int i = 1; i <= n; i++) P[i] = i;
    sort(E + 1, E + 1 + m);

    int res = 0;
    for (int i = 1; i <= m; i++)
    {
        int a = E[i].a, b = E[i].b, w = E[i].w;
        a = Find(a), b = Find(b);
        if (a != b)
        {
            P[a] = b;
            res += w;
        }
    }

    return res;
}

int main()
{
    scanf("%d%d", &n, &m);
    int tot = 0;
    for (int i = 1; i <= m; i++)
    {
        scanf("%d%d%d", &E[i].a, &E[i].b, &E[i].w);
        tot += E[i].w;
    }

    int res = tot - Kruskal();

    printf("%d\n", res);

    return 0;
}
```

### 繁忙的都市

题目：https://www.acwing.com/problem/content/description/1144/

本题是改造Kruskal算法来求最大权最小生成树。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 310, M = 8010;

int n, m;
struct Edge
{
    int a, b, w;
    bool operator< (const Edge& ct) const
    {
        return w < ct.w;
    }
} E[M];

int P[N];

int Find(int x)
{
    if (x != P[x]) P[x] = Find(P[x]);
    return P[x];
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++) 
        scanf("%d%d%d", &E[i].a, &E[i].b, &E[i].w);

    for (int i = 1; i <= n; i++) P[i] = i;
    sort(E + 1, E + 1 + m);

    int cnt = 0, res = 0;
    for (int i = 1; i <= m; i++)
    {
        int a = E[i].a, b = E[i].b, w = E[i].w;
        a = Find(a), b = Find(b);
        if (a != b)
        {
            P[a] = b;
            res = w;
            if (++cnt == n - 1) break;
        }
    }

    printf("%d %d\n", cnt, res);

    return 0;
}
```

### 联络员

题目：https://www.acwing.com/problem/content/1145/

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 2010, M = 1e4 + 10;

int n, m;
struct Edge
{
    int a, b, w;

    bool operator< (const Edge& ct) const
    {
        return w < ct.w;
    }
} E[M]; int cnt;

int P[N];

int Find(int x)
{
    if (x != P[x]) P[x] = Find(P[x]);
    return P[x];
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    int res = 0, tot = 0;
    for (int i = 1; i <= n; i++) P[i] = i;
    for (int i = 1; i <= m; i++)
    {
        int a, b, w, p; cin >> p >> a >> b >> w;
        if (p == 1)
        {
            a = Find(a), b = Find(b);
            if (a != b)
            {
                P[a] = b;
                tot++;
            }
            res += w;
        }
        else E[cnt++] = { a, b, w };
    }

    sort(E, E + cnt);

    for (int i = 0; i < cnt; i++)
    {
        int a = E[i].a, b = E[i].b, w = E[i].w;
        a = Find(a), b = Find(b);
        if (a != b)
        {
            P[a] = b;
            res += w;
            if (++tot == n - 1) break; 
        }
    }

    cout << res << endl;

    return 0;
}
```

### 连接格点

题目：https://www.acwing.com/problem/content/description/1146/

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010, M = 1e6 + 10;

int n, m, tot;
int P[M];

int Find(int x)
{
    if (x != P[x]) P[x] = Find(P[x]);
    return P[x];
}

int GetId(int x, int y)
{
    return (x - 1) * m + y;
}

struct Edge
{
    int a, b, w;

    bool operator< (const Edge& ct) const
    {
        return w < ct.w;
    }
} E[2 * M]; int cnt;

void Build() // 先纵向再横向建图就不用排序了
{
    for (int j = 1; j <= m; j++)
    {
        int idx = j;
        for (int i = 2; i <= n; i++)
        {
            if (Find(idx) != Find(idx + m))
                E[cnt++] = {idx, idx + m, 1};
            idx += m;
        }
    }

    int idx = 1;
    for (int i = 1; i <= n; i++)
    {
        for (int j = 2; j <= m; j++)
        {
            if (Find(idx) != Find(idx + 1))
                E[cnt++] = {idx, idx + 1, 2};
            idx++;
        }
        idx++;
    }
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    tot = n * m;
    for (int i = 1; i <= tot; i++) P[i] = i;
    int x1, y1, x2, y2;
    int times = 0;
    while (cin >> x1 >> y1 >> x2 >> y2)
    {
        int a = GetId(x1, y1), b = GetId(x2, y2);
        a = Find(a), b = Find(b);
        if (a != b)
        {
            P[a] = b;
            times++;
        }
    }

    Build();

    // sort(E, E + cnt);

    int res = 0;
    for (int i = 0; i < cnt; i++)
    {
        int a = E[i].a, b = E[i].b, w = E[i].w;
        a = Find(a), b = Find(b);
        if (a != b)
        {
            P[a] = b;
            res += w;
            if (++times == tot - 1) break;
        }
    }
    
    cout << res << endl;

    return 0;
}
```

## 最小生成树的扩展应用

### 新的开始

题目：https://www.acwing.com/problem/content/description/1148/

本题的核心思想是，设置一个虚拟源点，该点到其他各个点的距离为建站的代价。

```c++
#include <cstring>
#include <iostream>

using namespace std;

const int N = 310, INF = 0x3f3f3f3f;

int n;
int G[N][N];

int dist[N];
bool st[N];
int Prim()
{
    memset(dist, 0x3f, sizeof dist);
    dist[0] = 0;    

    int res = 0;
    for (int i = 0 ; i <= n; i++)
    {
        int cur = -1;
        for (int j = 0; j <= n; j++)
            if (!st[j] && (cur == -1 || dist[j] < dist[cur]))
                cur = j;

        st[cur] = true;
        res += dist[cur];

        for (int j = 0; j <= n; j++)
            if (!st[j] && G[cur][j] < dist[j])
                dist[j] = G[cur][j];
    }

    return res;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        int v; cin >> v;
        G[0][i] = G[i][0] = v;
    }
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            cin >> G[i][j];

    cout << Prim() << endl;

    return 0;
}
```

### 北极通讯网络

题目：https://www.acwing.com/problem/content/description/1147/

很直观的思路，每次都选最小边，直到连通块数量小于等于K。

```c++
#include <cmath>
#include <iostream>
#include <iomanip>
#include <algorithm>

using namespace std;

const int N = 510, M = N * N / 2;

int n, m, K;
struct Point
{
    int x, y;
} pt[N];

struct Edge
{
    int a, b;
    double w;

    bool operator< (const Edge& ct) const
    {
        return w < ct.w;
    }
} E[M];

inline double GetDist(Point& a, Point& b)
{
    int dx = a.x - b.x, dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
}

int P[N];

int Find(int x)
{
    if (x != P[x]) P[x] = Find(P[x]);
    return P[x];
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> K;
    for (int i = 1; i <= n; i++) cin >> pt[i].x >> pt[i].y;

    for (int i = 1; i <= n; i++)
        for (int j = i + 1; j <= n; j++)
            E[++m] = {i, j, GetDist(pt[i], pt[j])};

    int cnt = n;
    double res = 0;
    sort(E + 1, E + 1 + m);
    for (int i = 1; i <= n; i++) P[i] = i;
    for (int i = 1; i <= m; i++)
    {
        if (cnt <= K) break; 

        int a = E[i].a, b = E[i].b;
        double w = E[i].w;
        a = Find(a), b = Find(b);
        if (a != b)
        {
            P[a] = b;
            cnt--;
            res = w;
        }
    }

    cout << setprecision(2) << fixed << res << endl;

    return 0;
}
```

### 走廊泼水节

题目：https://www.acwing.com/problem/content/description/348/

dijkstra每次的有效操作（即并查集的Union操作）相当于连接两个连通块，只需要在每次两个连通块被连通时，使新生成的连通块是完全子图即可。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 6010;

int n;
struct Edge
{
    int a, b, w;

    bool operator< (const Edge& ct) const
    {
        return w < ct.w;
    }
} E[N];
int P[N], cnt[N];

int Find(int x)
{
    if (x != P[x]) P[x] = Find(P[x]);
    return P[x];
}

int main()
{
    int T; cin >> T;

    while (T--)
    {
        cin >> n;
        for (int i = 0; i < n - 1; i++)
            cin >> E[i].a >> E[i].b >> E[i].w;

        sort(E, E + n - 1);
        for (int i = 1; i <= n; i++)
            P[i] = i, cnt[i] = 1;
    
        int res = 0;
        for (int i = 0; i < n - 1; i++)
        {
            int a = E[i].a, b = E[i].b, w = E[i].w;
            a = Find(a), b = Find(b);
            if (a != b)
            {
                res += (cnt[a] * cnt[b] - 1) * (w + 1);
                P[a] = b;
                cnt[b] += cnt[a];
            }
        }

        cout << res << endl;
    }

    return 0;
}
```

### 秘密的牛奶运输

题目：https://www.acwing.com/problem/content/description/1150/

题解：https://www.acwing.com/solution/content/93261/

```c++
#include <climits>
#include <iostream>
#include <algorithm>
#include <numeric>

using namespace std;
using LL = long long;

const int N = 510, M = 1e4 + 10;

int n, m;
struct Edge
{
    int a, b, w;
    bool f;

    bool operator< (const Edge& ct) const
    {
        return w < ct.w;
    }
} E[M];
int P[N];

int Find(int x)
{
    if (x != P[x]) P[x] = Find(P[x]);
    return P[x];
}

int H[N];
struct ListNode
{
    int v, w, n;
} L[N * 2]; int idx = 1;

void Add(int a, int b, int w)
{
    L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

int dist1[N][N], dist2[N][N];

void dfs(int u, int fa, int mx1, int mx2, int d1[], int d2[])
{
    d1[u] = mx1, d2[u] = mx2;

    for (int p = H[u]; p; p = L[p].n)
    {
        int v = L[p].v, w = L[p].w;
        if (v != fa)
        {
            int t1 = mx1, t2 = mx2;
            if (w > t1) t2 = t1, t1 = w;
            else if (w < t1 && w > t2) t2 = w;
            dfs(v, u, t1, t2, d1, d2);
        }
    }
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
        cin >> E[i].a >> E[i].b >> E[i].w;

    sort(E, E + m);
    for (int i = 1; i <= n; i++) P[i] = i;
    LL sum = 0;
    int cnt = 0;
    for (int i = 0; i < m; i++)
    {
        int a = E[i].a, b = E[i].b, w = E[i].w;
        int pa = Find(a), pb = Find(b);
        if (pa != pb)
        {
            Add(a, b, w), Add(b, a, w);
            P[pa] = pb;
            sum += w;
            E[i].f = true;
            if (++cnt == n - 1) break;
        }
    }
    
    for (int i = 1; i <= n; i++)
        dfs(i, -1, INT_MIN, INT_MIN, dist1[i], dist2[i]);

    LL res = LONG_LONG_MAX;
    for (int i = 0; i < m; i++)
        if (!E[i].f)
        {
            int a = E[i].a, b = E[i].b, w = E[i].w;
            if (w > dist1[a][b]) res = min(res, sum + w - dist1[a][b]);
            else res = min(res, sum + w - dist2[a][b]);
        }

    cout << res << endl;

    return 0;
}
```

## 负环

### 虫洞

题目：https://www.acwing.com/problem/content/description/906/

入队次数大于等于n说明有负环；路径长度大于等于n也说明有负环，并且判断效率更高。

```c++
#include <cstring>
#include <iostream>
#include <queue>

using namespace std;

const int N = 510, M = 5210;

int n, m1, m2;
int H[N];
struct ListNode
{
    int v, w, n;
} L[M]; int idx = 1;

void Add(int a, int b, int w)
{
    L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

bool st[N];
int dist[N], cnt[N];

bool Spfa()
{
    memset(st, false, sizeof st);
    memset(dist, 0, sizeof dist);
    memset(cnt, 0, sizeof cnt);

    queue<int> Q;
    for (int i = 1; i <= n; i++)
    {
        Q.push(i);
        st[i] = true;
    }

    while (!Q.empty())
    {
        int u = Q.front(); Q.pop();
        st[u] = true;

        for (int p = H[u]; p; p = L[p].n)
        {
            int v = L[p].v, w = L[p].w;
            st[v] = false;
            if (dist[u] + w < dist[v])
            {
                dist[v] = dist[u] + w;
                cnt[v] = cnt[u] + 1;
                if (cnt[v] >= n) return true;
                if (!st[v])
                {
                    Q.push(v);
                    st[v] = true;
                }
            }
        }
    }

    return false;
}

int main()
{
    int T; cin >> T;

    while (T--)
    {
        cin >> n >> m1 >> m2;
        memset(H, 0, sizeof H);
        idx = 1;
        for (int i = 1; i <= m1; i++)
        {
            int a, b, w; cin >> a >> b >> w;
            Add(a, b, w), Add(b, a, w);
        }
        for (int i = 1; i <= m2; i++)
        {
            int a, b, w; cin >> a >> b >> w;
            Add(a, b, -w);
        }

        if (Spfa()) puts("YES");
        else puts("NO");
    }

    return 0;
}
```

### 观光奶牛

题目：https://www.acwing.com/problem/content/description/363/

题解：https://www.acwing.com/solution/content/37185/

```c++
#include <cstring>
#include <iostream>
#include <queue>

using namespace std;

const int N = 1010, M = 5010;

int n, m;
int P[N];
int H[N];
struct ListNode
{
    int v, w, n;
} L[M]; int idx = 1;

void Add(int a, int b, int w)
{
    L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

double dist[N];
int cnt[N];
bool st[N];
bool check(double mid)
{
    memset(dist, 0, sizeof dist);
    memset(cnt, 0, sizeof cnt);
    queue<int> Q;
    for (int i = 1; i <= n; i++)
    {
        Q.push(i);
        st[i] = true;
    }

    while (!Q.empty())
    {
        int u = Q.front(); Q.pop();
        st[u] = false;

        for (int p = H[u]; p; p = L[p].n)
        {
            int v = L[p].v, w = L[p].w;
            if (double len = dist[u] + P[u] - mid * w; len > dist[v])
            {
                dist[v] = len;
                cnt[v] = cnt[u] + 1;
                if (cnt[v] >= n) return true;
                if (!st[v])
                {
                    Q.push(v);
                    st[v] = true;
                }
            }
        }
    }

    return false;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> P[i];
    for (int i = 1; i <= m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        Add(a, b, w);
    }

    double l = 0, r = 1000;
    while (r - l > 1e-4)
    {
        double mid = (l + r) / 2;
        if (check(mid)) l = mid;
        else r = mid;
    }

    printf("%.2lf\n", l);

    return 0;
}
```

### 单词环

题目：https://www.acwing.com/problem/content/description/1167/

题解：https://www.acwing.com/solution/content/17712/

可以把队列换成栈，能保证不超时并且一定正确。

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 26 * 26 + 10, M = 1e5 + 10;

int n, m;
int H[N];
struct ListNode
{
    int v, w, n;
} L[M]; int idx = 1;

void Add(int a, int b, int w)
{
    L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

bool st[N];
double dist[N];
int cnt[N];
int Q[N], hh, tt;
bool Check(double mid)
{
    memset(st, 0, sizeof st);
    memset(dist, 0, sizeof dist);
    memset(cnt, 0, sizeof cnt);
    hh = tt = 0;

    for (int i = 1; i <= n; i++)
    {
        Q[tt++] = i;
        st[i] = true;
    }

    int flag = 0;
    while (hh != tt)
    {
        int u = Q[hh++];
        if (hh == N) hh = 0;
        st[u] = false;

        for (int p = H[u]; p; p = L[p].n)
        {
            int v = L[p].v, w = L[p].w;

            if (double len = dist[u] + w - mid; len > dist[v])
            {
                dist[v] = len;
                cnt[v] = cnt[u] + 1;
                if (cnt[v] >= N) return true;
                if (++flag > 4 * n) return true;
                if (!st[v])
                {
                    Q[tt++] = v;
                    if (tt == N) tt = 0;
                    st[v] = true;
                }
            }
        }
    }

    return false;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    while (cin >> m, m)
    {
        memset(H, 0, sizeof H);
        idx = 1;
        n = 0;
        for (int i = 1; i <= m; i++)
        {
            string s; cin >> s;
            int len = s.size();
            if (len >= 2)
            {
                int a = (s[0] - 'a') * 26 + s[1] - 'a' + 1;
                int b = (s[len - 2] - 'a') * 26 + s[len - 1] - 'a' + 1;
                n = max({n, a, b});
                Add(a, b, len);
            }
        }

        if (!Check(0)) cout << "No solution" << '\n';
        else
        {
            double l = 0, r = 1000;
            while (r - l > 1e-4)
            {
                double mid = (l + r) / 2;
                if (Check(mid)) l = mid;
                else r = mid;
            }

            cout << r << '\n';
        }
    }

    return 0;
}
```

## 差分约束

### 糖果

题目：https://www.acwing.com/problem/content/description/1171/

题解：https://www.acwing.com/solution/content/37324/

```c++
#include <cstring>
#include <iostream>

using namespace std;
using LL = long long;

const int N = 1e5 + 10, M = 3e5 + 10; // 还需要考虑虚拟源点的边

int n, m;
int H[N];
struct ListNode
{
    int v, w, n;
} L[M]; int idx;

void Add(int a, int b, int w)
{
    L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

bool st[N];
LL dist[N];
int cnt[N];
int stk[N], tt = 0;
bool Spfa()
{
    memset(dist, -0x3f, sizeof dist);
    dist[0] = 0;
    stk[++tt] = 0;
    st[0] = true;

    while (tt)
    {
        int u = stk[tt--];
        st[u] = false;

        for (int p = H[u]; ~p; p = L[p].n)
        {
            int v = L[p].v, w = L[p].w;
            if (int len = dist[u] + w; len > dist[v])
            {
                dist[v] = len;
                cnt[v] = cnt[u] + 1;
                if (cnt[v] >= n + 1) return true;
                if (!st[v])
                {
                    stk[++tt] = v;
                    st[v] = true;
                }
            }
        }
    }

    return false;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    memset(H, -1, sizeof H);
    for (int i = 1; i <= m; i++)
    {
        int x, a, b; cin >> x >> a >> b;
        switch (x)
        {
        case 1:
            Add(a, b, 0), Add(b, a, 0);
            break;
        case 2:
            Add(a, b, 1);
            break;
        case 3:
            Add(b, a, 0);
            break;
        case 4:
            Add(b, a, 1);
            break;
        case 5:
            Add(a, b, 0);
            break;
        }
    }
    for (int i = 1; i <= n; i++) Add(0, i, 1);
    
    if (Spfa()) cout << -1 << '\n';
    else
    {
        LL res = 0;
        for (int i = 1; i <= n; i++) res += dist[i];
        cout << res << '\n';
    }

    return 0;
}
```

### 区间

题目：https://www.acwing.com/problem/content/description/364/

题解：https://www.acwing.com/solution/content/42920/

```c++
#include <cstring>
#include <iostream>

using namespace std;

const int N = 5e4 + 10, M = 3 * N;

int n, m;
int H[N];
struct ListNode
{
    int v, w, n;
} L[M]; int idx;

void Add(int a, int b, int w)
{
    L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

bool st[N];
int dist[N];
int Q[N], hh, tt;
void Spfa()
{
    memset(dist, -0x3f, sizeof dist);
    dist[0] = 0;
    hh = tt = 0;
    Q[tt++] = 0;
    st[0] = true;

    while (hh != tt)
    {
        int u = Q[hh++];
        if (hh == N) hh = 0;
        st[u] = false;

        for (int p = H[u]; ~p; p = L[p].n)
        {
            int v = L[p].v, w = L[p].w;
            if (int len = dist[u] + w; len > dist[v])
            {
                dist[v] = len;
                if (!st[v])
                {
                    Q[tt++] = v;
                    if (tt == N) tt = 0;
                    st[v] = true;
                }
            }
        }
    }
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    n = 50001;
    cin >> m;
    memset(H, -1, sizeof H);
    for (int i = 1; i <= n; i++)
        Add(i - 1, i, 0), Add(i, i - 1, -1);
    for (int i = 1; i <= m; i++)
    {
        int a, b, c; cin >> a >> b >> c;
        a++, b++;
        Add(a - 1, b, c);
    }

    Spfa();

    cout << dist[n] << '\n';

    return 0;
}
```

### 排队布局

题目：https://www.acwing.com/problem/content/description/1172/

题解：https://www.acwing.com/solution/content/80505/

```c++
#include <cstring>
#include <iostream>

using namespace std;
using LL = long long;

const int N = 1010, M = 2e4 + N;
const LL INF = 0x3f3f3f3f3f3f3f3f;

int n, m1, m2;
int H[N];
struct ListNode
{
    int v, w, n;
} L[M]; int idx = 1;

void Add(int a, int b, int w)
{
    L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

LL dist[N];
int cnt[N];
bool st[N];
int Q[N], hh, tt;
bool Spfa(int to)
{
    memset(dist, 0x3f, sizeof dist);
    memset(cnt, 0, sizeof cnt);
    memset(st, false, sizeof st);
    hh = tt = 0;
    for (int i = 1; i <= to; i++)
    {
        dist[i] = 0;
        Q[tt++] = i;
        st[i] = true;
    }

    while (hh != tt)
    {
        int u = Q[hh++];
        if (hh == N) hh = 0;
        st[u] = false;

        for (int p = H[u]; p; p = L[p].n)
        {
            int v = L[p].v, w = L[p].w;
            if (LL len = dist[u] + w; len < dist[v])
            {
                dist[v] = len;
                cnt[v] = cnt[u] + 1;
                if (cnt[v] >= n) return true;
                if (!st[v])
                {
                    Q[tt++] = v;
                    if (tt == N) tt = 0;
                    st[v] = true;
                }
            }
        }
    }

    return false;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m1 >> m2;
    for (int i = 1; i <= m1; i++)
    {
        int a, b, c; cin >> a >> b >> c;
        if (a > b) swap(a, b);
        Add(a, b, c);
    }
    for (int i = 1; i <= m2; i++)
    {
        int a, b, c; cin >> a >> b >> c;
        if (a > b) swap(a, b);
        Add(b, a, -c);
    }
    for (int i = 1; i < n; i++) Add(i + 1, i, 0);

    if (Spfa(n)) cout << -1 << '\n';
    else
    {
        Spfa(1);
        if (dist[n] == INF) cout << -2 << '\n';
        else cout << dist[n] << endl;
    }

    return 0;
}
```

### 雇佣收银员

题目：https://www.acwing.com/problem/content/description/395/

题解：https://www.acwing.com/solution/content/63552/

```c++
#include <cstring>
#include <iostream>

using namespace std;

const int N = 25, M = 100;

int sum;
int R[N], num[N];

int H[N];
struct ListNode
{
    int v, w, n;
} L[M]; int idx;

void Add(int a, int b, int w)
{
    L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

void Build(int c)
{
    memset(H, -1, sizeof H);
    idx = 0;

    for (int i = 1; i <= 24; i++)
    {
        Add(i - 1, i, 0);
        Add(i, i - 1, -num[i]);
    }
    for (int i = 1; i <= 7; i++) 
        Add(16 + i, i, -c + R[i]);
    for (int i = 8; i <= 24; i++)
        Add(i - 8, i, R[i]);
    Add(0, 24, c), Add(24, 0, -c);
}


int dist[N], cnt[N];
bool st[N];
int Q[N], hh, tt;

bool Spfa()
{
    memset(dist, -0x3f, sizeof dist);
    memset(cnt, 0, sizeof cnt);
    memset(st, false, sizeof st);
    hh = tt = 0;

    dist[0] = 0;
    Q[tt++] = 0;
    st[0] = true;

    while (hh != tt)
    {
        int u = Q[hh++];
        if (hh == N) hh = 0;
        st[u] = false;

        for (int p = H[u]; ~p; p = L[p].n)
        {
            int v = L[p].v, w = L[p].w;

            if (int len = dist[u] + w; len > dist[v])
            {
                dist[v] = len;
                cnt[v] = cnt[u] + 1;
                if (cnt[v] >= 25) return true;
                if (!st[v])
                {
                    Q[tt++] = v;
                    if (tt == N) tt = 0;
                    st[v] = true;
                }
            }
        }
    }

    return false;
}

void Solve()
{
    for (int i = 1; i <= 24; i++) cin >> R[i];
    cin >> sum;
    memset(num, 0, sizeof num);
    for (int i = 1; i <= sum; i++)
    {
        int x; cin >> x;
        num[x + 1]++;
    }

    // for (int c = 0; c <= sum; c++)
    // {
    //     Build(c);
    //     if (!Spfa())
    //     {
    //         cout << dist[24] << '\n';
    //         return;
    //     }
    // }
    // cout << "No Solution" << '\n';

    int l = 0, r = sum + 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        Build(mid);
        if (!Spfa()) r = mid;
        else l = mid + 1;
    }
    if (l <= sum) cout << l << '\n';
    else cout << "No Solution" << '\n';
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t; cin >> t;
    while (t--)
        Solve();

    return 0;
}
```

## 最近公共祖先

### 祖孙询问

题目：https://www.acwing.com/problem/content/description/1174/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 4e4 + 10, M = N * 2;

int n, m, root;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M]; int idx;

void Add(int a, int b)
{
    E[idx].v = b, E[idx].n = H[a], H[a] = idx++;
}

int ft[N][17];
int Q[N], hh, tt;
int depth[N];

void BFS()
{
    memset(depth, 0x3f, sizeof depth);

    hh = 0, tt = -1;
    Q[++tt] = root;
    depth[root] = 1;
    depth[0] = 0;

    while (hh <= tt)
    {
        int u = Q[hh++];

        for (int p = H[u]; ~p; p = E[p].n)
        {
            int v = E[p].v;

            if (int len = depth[u] + 1; len < depth[v])
            {
                depth[v] = len;

                ft[v][0] = u;
                for (int i = 1; i <= 16; i++)
                    ft[v][i] = ft[ft[v][i - 1]][i - 1];

                Q[++tt] = v;
            }
        }
    }
}

int LCA(int a, int b)
{
    if (depth[a] < depth[b]) swap(a, b);
    for (int i = 16; i >= 0; i--)
        if (depth[ft[a][i]] >= depth[b])
            a = ft[a][i];

    if (a == b) return b;

    for (int i = 16; i >= 0; i--)
        if (ft[a][i] != ft[b][i])
        {
            a = ft[a][i];
            b = ft[b][i];
        }
    
    return ft[a][0];
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n;
    memset(H, -1, sizeof H);
    for (int i = 1; i <= n; i++)
    {
        int a, b; cin >> a >> b;
        if (b == -1) root = a;
        else Add(a, b), Add(b, a);
    }

    BFS();

    cin >> m;
    while (m--)
    {
        int a, b; cin >> a >> b;
        int c = LCA(a, b);
        if      (c == a) puts("1");
        else if (c == b) puts("2");
        else puts("0");
    }

    return 0;
}
```

### 距离

题目：https://www.acwing.com/problem/content/description/1173/

题解：https://www.acwing.com/solution/content/42924/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int N = 1e4 + 10, M = N * 2;

int n, m;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M]; int idx = 1;

void Add(int a, int b, int w)
{
    E[idx].v = b, E[idx].w = w, E[idx].n = H[a], H[a] = idx++;
}

struct Node
{
    int v, idx;
};
vector<Node> query[N];
int depth[N];

void DFS(int u, int ft)
{
    for (int p = H[u]; p; p = E[p].n)
    {
        int v = E[p].v, w = E[p].w;
        if (v == ft) continue;
        depth[v] = depth[u] + w;
        DFS(v, u);
    }
}

int res[M];
int st[N];
int P[N];

int Find(int x)
{
    if (x != P[x]) P[x] = Find(P[x]);
    return P[x];
}

void Tarjan(int u)
{
    st[u] = 1;

    for (int p = H[u]; p; p = E[p].n)
    {
        int v = E[p].v;
        if (st[v] == 0)
        {
            Tarjan(v);
            P[v] = u;
        }

    }

    for (auto q : query[u])
        if (st[q.v] == 2)
        {
            int p = Find(q.v);
            res[q.idx] = depth[u] + depth[q.v] - 2 * depth[p];
        }

    st[u] = 2;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < n - 1; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        Add(a, b, w), Add(b, a, w);
    }
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        if (a != b)
        {
            query[a].push_back({b, i});
            query[b].push_back({a, i});
        }
    }

    DFS(1, 0);

    for (int i = 1; i <= n; i++) P[i] = i;
    Tarjan(1);

    for (int i = 0; i < m; i++) cout << res[i] << '\n';

    return 0;
}
```

### 次小生成树

题目：https://www.acwing.com/problem/content/description/358/

在计算ft的时候，同时维护一个W1和W2，记录对应路径的最长边和次长边，之后根据最近公共祖先来计算应该删去的最长边。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;
using LL = long long;

const int N = 1e5 + 10, M = 3e5 + 10;

int n, m;
struct Edge
{
    int a, b, w;
    bool isMin;

    Edge() : a(0), b(0), w(0), isMin(false) {}

    bool operator< (const Edge& ct) const
    {
        return w < ct.w;
    }
} edge[M];

int H[N];
struct EdgeNode
{
    int v, w, n;
} E[N * 2]; int idx = 1;

void Add(int a, int b, int w)
{
    E[idx].v = b, E[idx].w = w, E[idx].n = H[a], H[a] = idx++;
}

int P[N];

int Find(int x)
{
    if (x != P[x]) P[x] = Find(P[x]);
    return P[x];
}

LL Kruskal()
{
    for (int i = 1; i <= n; i++) P[i] = i;

    LL res = 0;
    int cnt = 0;
    for (int i = 0; i < m; i++)
    {
        int a = edge[i].a, b = edge[i].b, w = edge[i].w;
        int pa = Find(a), pb = Find(b);
        if (pa != pb)
        {
            edge[i].isMin = true;
            P[pa] = pb;
            res += w;
            if (++cnt == n - 1) return res;
        }
    }

    return res;
}

void Build()
{
    memset(H, -1, sizeof H);
    
    for (int i = 0; i < m; i++)
        if (edge[i].isMin)
        {
            int a = edge[i].a, b = edge[i].b, w = edge[i].w;
            Add(a, b, w), Add(b, a, w);
        }
}

int depth[N];
int ft[N][17];
int W1[N][17], W2[N][17];
int Q[N], hh, tt;

void BFS()
{
    memset(depth, 0x3f, sizeof depth);
    depth[0] = 0, depth[1] = 1;

    hh = 0, tt = -1;
    Q[++tt] = 1;

    while (hh <= tt)
    {
        int u = Q[hh++];

        for (int p = H[u]; ~p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (int len = depth[u] + 1; len < depth[v])
            {
                depth[v] = len;
                ft[v][0] = u;
                W1[v][0] = w, W2[v][0] = -1;
                for (int i = 1; i <= 16; i++)
                {
                    int mid = ft[v][i - 1];
                    ft[v][i] = ft[mid][i - 1];
                    W1[v][i] = max(W1[v][i - 1], W1[mid][i - 1]);
                    W2[v][i] = -1;
                    for (int tmp : {W1[v][i - 1], W1[mid][i - 1], W2[v][i - 1], W2[mid][i - 1]})
                    {
                        if (tmp != W1[v][i])
                            W2[v][i] = max(W2[v][i], tmp);
                    }
                }
                Q[++tt] = v;
            }
        }
    }
}

int LCA(int a, int b, int w)
{
    if (a == b) return -1; // 任何生成树上都不能有环

    static int W[N * 2];
    int cnt = 0;

    if (depth[a] < depth[b]) swap(a, b);

    for (int i = 16; i >= 0; i--)
        if (depth[ft[a][i]] >= depth[b])
        {
            W[cnt++] = W1[a][i];
            W[cnt++] = W2[a][i];
            a = ft[a][i];
        }
    
    if (a != b)
    {
        for (int i = 16; i >= 0; i--)
            if (ft[a][i] != ft[b][i])
            {
                W[cnt++] = W1[a][i], W[cnt++] = W2[a][i];
                W[cnt++] = W1[b][i], W[cnt++] = W2[b][i];
                a = ft[a][i];
                b = ft[b][i];
            }
        W[cnt++] = W1[a][0];
        W[cnt++] = W1[b][0];
    }
    
    int w1 = *max_element(W, W + cnt);
    if (w == w1)
    {
        int w2 = -1;
        for (int i = 0; i < cnt; i++)
            if (w1 != W[i])
                w2 = max(w2, W[i]);
        return w2;
    }
    else return w1;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        cin >> edge[i].a >> edge[i].b >> edge[i].w;
    }
    sort(edge, edge + m);
    LL sum = Kruskal();

    Build();
    BFS();
    
    LL res = 1e11;
    for (int i = 0; i < m; i++)
        if (!edge[i].isMin)
        {
            int a = edge[i].a, b = edge[i].b, w1 = edge[i].w;

            int w2 = LCA(a, b, w1);
            if (w2 != -1) res = min(res, sum - w2 + w1);
        }

    cout << res << '\n';

    return 0;
}
```

### 闇の連鎖

题目：https://www.acwing.com/problem/content/description/354/

题解：https://www.acwing.com/solution/content/24653/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10, M = 2e5 + 10;

int n, m;
struct Edge
{
    int a, b;
} edge[M];
int H[N];
struct EdgeNode
{
    int v, n;
} E[N * 2]; int idx;

void Add(int a, int b)
{
    E[idx].v = b, E[idx].n = H[a], H[a] = idx++;
}

int depth[N];
int ft[N][17];
int Q[N], hh, tt;

void BFS()
{
    memset(depth, 0x3f, sizeof depth);
    depth[0] = 0, depth[1] = 1;
    
    hh = 0, tt = -1;
    Q[++tt] = 1;

    while (hh <= tt)
    {
        int u = Q[hh++];

        for (int p = H[u]; ~p; p = E[p].n)
        {
            int v = E[p].v;

            if (int len = depth[u] + 1; len < depth[v])
            {
                depth[v] = len;

                ft[v][0] = u;
                for (int i = 1; i <= 16; i++)
                {
                    int mid = ft[v][i - 1];
                    ft[v][i] = ft[mid][i - 1];
                }

                Q[++tt] = v;
            }
        }
    }
}

int LCA(int a, int b)
{
    if (depth[a] < depth[b]) swap(a, b);

    for (int i = 16; i >= 0; i--)
        if (depth[ft[a][i]] >= depth[b])
            a = ft[a][i];

    if (a == b) return a;

    for (int i = 16; i >= 0; i--)
        if (ft[a][i] != ft[b][i])
        {
            a = ft[a][i];
            b = ft[b][i];
        }

    return ft[a][0];
}

int D[N]; // 树上差分
int res;

int DFS(int u, int f)
{
    int cur = 0;
    for (int p = H[u]; ~p; p = E[p].n)
        if (int v = E[p].v; v != f)
        {
            int pre = DFS(v, u);
            if      (pre == 0) res += m;
            else if (pre == 1) res += 1;
            cur += pre;
        }

    return cur + D[u];
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    memset(H, -1, sizeof H);
    for (int i = 0; i < n - 1; i++)
    {
        int a, b; cin >> a >> b; 
        Add(a, b), Add(b, a);
    }
    for (int i = 0; i < m; i++)
    {
        cin >> edge[i].a >> edge[i].b;
    }

    BFS();

    for (int i = 0; i < m; i++)
    {
        int a = edge[i].a, b = edge[i].b;
        int p = LCA(a, b);

        D[a] += 1, D[b] += 1, D[p] -= 2;
    }

    DFS(1, -1);

    cout << res << '\n';

    return 0;
}
```

## 有向图的强连通分量

### 受欢迎的牛

题目：https://www.acwing.com/problem/content/description/1176/

题解：https://www.acwing.com/solution/content/20678/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <functional>

using namespace std;

const int N = 1e4 + 10, M = 5e4 + 10;

int n, m;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M]; int idx;

void InitG()
{
    memset(H, -1, sizeof H);
}

void Add(int a, int b)
{
    E[idx].v = b, E[idx].n = H[a], H[a] = idx++;
}

int SSCCnt, SSCSize[N];
int SSC[N];
int low[N], dfn[N], timeStamp;
int stk[N], top;
bool inStk[N];

void Tarjan()
{
    function<void(int)> DFS = [&](int u)
    {
        dfn[u] = low[u] = ++timeStamp;
        stk[++top] = u, inStk[u] = true;

        for (int p = H[u]; p != -1; p = E[p].n)
        {
            int v = E[p].v;

            if (!dfn[v])
            {
                DFS(v);
                low[u] = min(low[u], low[v]);
            }
            else if (inStk[v])
            {
                low[u] = min(low[u], low[v]);
            }
        }

        if (low[u] == dfn[u])
        {
            int v;
            SSCCnt++;
            do
            {
                v = stk[top--], inStk[v] = false;
                SSCSize[SSCCnt]++;
                SSC[v] = SSCCnt;
            } while (v != u);
        }
    };

    for (int i = 1; i <= n; i++)
        if (!dfn[i])
            DFS(i);
}

int dout[N];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    InitG();
    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        Add(a, b);
    }

    Tarjan();

    for (int u = 1; u <= n; u++)
        for (int p = H[u], a = SSC[u]; ~p; p = E[p].n)
        {
            int v = E[p].v;
            int b = SSC[v];
            if (a != b)
            {
                dout[a]++;
            }
        }

    int res = 0;
    int zeroCnt = 0;
    for (int i = 1; i <= SSCCnt; i++)
        if (dout[i] == 0)
        {
            if (++zeroCnt > 1)
            {
                res = 0;
                break;
            }
            res += SSCSize[i];
        }

    cout << res << '\n';

    return 0;
}
```

### 学校网络

题目：https://www.acwing.com/problem/content/description/369/

题解：https://www.acwing.com/solution/content/4663/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <functional>

using namespace std;

const int N = 110;

int n;
int H[N];
struct EdgeNode
{
    int v, n;
} E[N * N]; int idx;

void InitG()
{
    idx = 1;
}

void Add(int a, int b)
{
    E[idx].v = b, E[idx].n = H[a], H[a] = idx++;
}

int SSC[N], SSCCnt;
int low[N], dfn[N], timeStamp;
int stk[N], top;
bool inStk[N];

void Tarjan()
{
    function<void(int)> DFS = [&](int u)
    {
        low[u] = dfn[u] = ++timeStamp;
        stk[++top] = u, inStk[u] = true;

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            if (!dfn[v])
            {
                DFS(v);
                low[u] = min(low[u], low[v]);
            }
            else if (inStk[v]) low[u] = min(low[u], low[v]);
        }

        if (low[u] == dfn[u])
        {
            ++SSCCnt;
            int v;
            do
            {
                v = stk[top--];
                inStk[v] = false;
                SSC[v] = SSCCnt;
            } while (v != u);
        }
    };

    for (int i = 1; i <= n; i++)
        if (!dfn[i])
            DFS(i);
}

int din[N], dout[N];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    InitG();

    cin >> n;
    for (int a = 1, b = 0; a <= n; a++)
    {
        while (cin >> b, b) Add(a, b);
    }

    Tarjan();

    for (int u = 1; u <= n; u++)
        for (int p = H[u], a = SSC[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            int b = SSC[v];
            if (a != b)
            {
                dout[a]++;
                din[b]++;
            }
        }

    int p = 0, q = 0;
    for (int i = 1; i <= SSCCnt; i++)
    {
        if (din[i] == 0) p++;
        if (dout[i] == 0) q++;
    }

    cout << p << '\n';
    cout << (SSCCnt > 1 ? max(p, q) : 0) << '\n';

    return 0;
}
```

### 最大半连通子图

题目：https://www.acwing.com/problem/content/description/1177/

题解：https://www.acwing.com/solution/content/24796/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <functional>
#include <unordered_set>

using namespace std;
using LL = long long;

const int N = 1e5 + 10, M = 2e6 + 10;

int n, m, MOD;
int H1[N], H2[N];
struct EdgeNode
{
    int v, n;
} E[M]; int idx;

void InitG()
{
    idx = 1;
}

void Add(int H[], int a, int b)
{
    E[idx].v = b, E[idx].n = H[a], H[a] = idx++;
}

int SSCCnt, SSC[N], SSCSize[N];
int low[N], dfn[N], timeStamp;
int stk[N], top;
bool inStk[N];

void Tarjan()
{
    function<void(int)> DFS = [&](int u)
    {
        low[u] = dfn[u] = ++timeStamp;
        stk[++top] = u, inStk[u] = true;

        for (int p = H1[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            if (dfn[v] == 0)
            {
                DFS(v);
                low[u] = min(low[u], low[v]);
            }
            else if (inStk[v])
                low[u] = min(low[u], low[v]);
        }

        if (low[u] == dfn[u])
        {
            int v;
            ++SSCCnt;
            do
            {
                v = stk[top--];
                inStk[v] = false;
                SSC[v] = SSCCnt;
                SSCSize[SSCCnt]++;
            } while (v != u);
        }
    };

    for (int i = 1; i <= n; i++)
        if (!dfn[i])
            DFS(i);
}

int f[N], g[N];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    InitG();

    cin >> n >> m >> MOD;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        Add(H1, a, b);
    }

    Tarjan();

    unordered_set<LL> set;
    for (int u = 1; u <= n; u++)
        for (int p = H1[u], a = SSC[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            int b = SSC[v];
            if (a != b)
            {
                LL code = (LL(a) << 20) + b;
                if (!set.count(code))
                {
                    Add(H2, a, b);
                    set.insert(code);
                }
            }
        }

    for (int u = SSCCnt; u >= 1; u--)
    {
        if (f[u] == 0)
        {
            f[u] = SSCSize[u];
            g[u] = 1;
        }

        for (int p = H2[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            if (int tot = f[u] + SSCSize[v]; tot > f[v])
            {
                f[v] = tot;
                g[v] = g[u];
            }
            else if (tot == f[v])
                g[v] = (g[v] + g[u]) % MOD;
        }
    }
    
    int mx = 0, cnt = 0;
    for (int i = 1; i <= SSCCnt; i++)
    {
        if (f[i] > mx)
        {
            mx = f[i];
            cnt = g[i];
        }
        else if (f[i] == mx)
            cnt = (cnt + g[i]) % MOD;
    }

    cout << mx << '\n' << cnt << '\n';

    return 0;
}
```

### 银河

题目：https://www.acwing.com/problem/content/description/370/

题解：https://www.acwing.com/solution/content/24811/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <functional>
#include <queue>

using namespace std;
using LL = long long;

const int N = 1e5 + 10, M = 6e5 + 10;

int n, m;
int H1[N], H2[N];
struct EdgeNode
{
    int v, w, n;
} E[M]; int idx;

void InitG()
{
    memset(H1, -1, sizeof H1);
    memset(H2, -1, sizeof H2);
}

void Add(int H[], int a, int b, int w)
{
    E[idx] = {b, w, H[a]}, H[a] = idx++;
}

int SSCCnt, SSC[N], SSCSize[N];
int low[N], dfn[N], timeStamp;
int stk[N], top;
bool inStk[N];

void Tarjan()
{
    function<void(int)> DFS = [&](int u)
    {
        low[u] = dfn[u] = ++timeStamp;
        stk[++top] = u, inStk[u] = true;

        for (int p = H1[u]; ~p; p = E[p].n)
        {
            int v = E[p].v;
            if (dfn[v] == 0)
            {
                DFS(v);
                low[u] = min(low[u], low[v]);
            }
            else if (inStk[v])
                low[u] = min(low[u], low[v]);
        }
        
        if (low[u] == dfn[u])
        {
            ++SSCCnt;
            int v;
            do
            {
                v = stk[top--];
                inStk[v] = false;
                SSC[v] = SSCCnt;
                SSCSize[SSCCnt]++;
            } while (v != u);
        }
    };

    DFS(0);
}

int dist[N];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    InitG();
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        Add(H1, 0, i, 1);
    for (int i = 0; i < m; i++)
    {
        int t, a, b; cin >> t >> a >> b;
        switch (t)
        {
        case 1: 
            Add(H1, a, b, 0), Add(H1, b, a, 0);
            break;
        case 2:
            Add(H1, a, b, 1);
            break;
        case 3:
            Add(H1, b, a, 0);
            break;
        case 4:
            Add(H1, b, a, 1);
            break;
        case 5:
            Add(H1, a, b, 0);
            break;
        }
    }

    Tarjan();

    for (int u = 0; u <= n; u++)
    {
        int a = SSC[u];
        for (int p = H1[u]; ~p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            int b = SSC[v];
            if (a != b)
                Add(H2, a, b, w);
            else if (w == 1)
            {
                cout << -1 << '\n';
                return 0;
            }
        }
    }

    for (int u = SSCCnt; u >= 1; u--)
        for (int p = H2[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            dist[v] = max(dist[v], dist[u] + w);
        }

    LL res = 0;
    for (int i = 1; i <= SSCCnt; i++)
        res += (LL) dist[i] * SSCSize[i];
    cout << res << '\n';    

    return 0;
}
```

## 无向图的双连通分量

### 冗余路径

题目：https://www.acwing.com/problem/content/description/397/

题解：算法竞赛（下册）249/P619，必须要注意的是，如果要处理重边的情况，那么DFS中传输的参数必须是父节点到子节点的边，并且idx必须从0开始计数。无重边的情况可以考虑使用父节点编号。

**不标记桥，因为两个双连通分量之间是桥：**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <functional>

using namespace std;

const int N = 5010, M = 2e4 + 10;

int n, m;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M]; int idx;

void InitG()
{
    memset(H, -1, sizeof H);
}

void Add(int a, int b)
{
    E[idx] = {b, H[a]}, H[a] = idx++;
}

int DCCCnt, DCC[N];
int low[N], dfn[N], timeStamp;
int stk[N], top;

void Tarjan()
{
    function<void(int, int)> DFS = [&](int u, int e)
    {
        low[u] = dfn[u] = ++timeStamp;
        stk[++top] = u;

        for (int p = H[u]; ~p; p = E[p].n)
        {
            if (p == (e ^ 1)) continue;
            int v = E[p].v;
            if (!dfn[v]) DFS(v, p);
            low[u] = min(low[u], low[v]);
        }

        if (low[u] == dfn[u])
        {
            int v;
            ++DCCCnt;
            do
            {
                v = stk[top--];
                DCC[v] = DCCCnt;
            } while (v != u);
        }
    };

    DFS(1, -1);
}

int D[N];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    InitG();

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        Add(a, b), Add(b, a);
    }

    Tarjan();

    for (int u = 1; u <= n; u++)
    {
        int a = DCC[u];
        for (int p = H[u]; ~p; p = E[p].n)
        {
            int v = E[p].v;
            int b = DCC[v];
            if (a != b) D[a]++;
        }
    }

    int cnt = 0;
    for (int i = 1; i <= DCCCnt; i++)
        if (D[i] == 1)
            cnt++;
    
    cout << (cnt + 1) / 2 << '\n';

    return 0;
}
```

**标记桥：**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <functional>

using namespace std;

const int N = 5010, M = 2e4 + 10;

int n, m;
int H[N];
struct EdgeNode
{
    int v, n;
    bool isBridge;
} E[M]; int idx;

void InitG()
{
    memset(H, -1, sizeof H);
}

void Add(int a, int b)
{
    E[idx] = {b, H[a], false}, H[a] = idx++;
}

int DCCCnt, DCC[N];
int low[N], dfn[N], timeStamp;
int stk[N], top;

void Tarjan()
{
    function<void(int, int)> DFS = [&](int u, int e)
    {
        low[u] = dfn[u] = ++timeStamp;
        stk[++top] = u;

        for (int p = H[u]; ~p; p = E[p].n)
        {
            if (p == (e ^ 1)) continue;
            int v = E[p].v;
            if (!dfn[v]) DFS(v, p);
            low[u] = min(low[u], low[v]);
            if (low[v] > dfn[u]) 
                E[p ^ 1].isBridge = E[p].isBridge = true;
        }

        if (low[u] == dfn[u])
        {
            int v;
            ++DCCCnt;
            do
            {
                v = stk[top--];
                DCC[v] = DCCCnt;
            } while (v != u);
        }
    };

    DFS(1, -1);
}

int D[N];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    InitG();

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        Add(a, b), Add(b, a);
    }

    Tarjan();

    for (int p = 0; p < idx; p++)
        if (E[p].isBridge)
        {
            int v = E[p].v;
            D[DCC[v]]++;
        }

    int cnt = 0;
    for (int i = 1; i <= DCCCnt; i++)
        if (D[i] == 1)
            cnt++;
    
    cout << (cnt + 1) / 2 << '\n';

    return 0;
}
```

### 电力

题目：https://www.acwing.com/problem/content/1185/

题解：https://www.acwing.com/solution/content/20702/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <functional>

using namespace std;

const int N = 1e4 + 10, M = 3e4 + 10;

int n, m;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M]; int idx;

void InitG()
{
    idx = 0;
    memset(H, -1, sizeof H);
}

void Add(int a, int b)
{
    E[idx] = {b, H[a]}, H[a] = idx++;
}

int mx, cnt;
int dfn[N], low[N], timeStamp;

void Tarjan()
{
    memset(dfn, 0, sizeof dfn);
    memset(low, 0, sizeof low);
    timeStamp = mx = cnt = 0;
    int root = 0;

    function<void(int)> DFS = [&](int u)
    {
        dfn[u] = low[u] = ++timeStamp;

        int com = 0;
        for (int p = H[u]; ~p; p = E[p].n)
        {
            int v = E[p].v;
            if (!dfn[v])
            {
                DFS(v);
                low[u] = min(low[u], low[v]);
                if (low[v] >= dfn[u]) com++;
            }
            else low[u] = min(low[u], dfn[v]);
        }

        if (u != root) com++;

        mx = max(mx, com);
    };

    for (root = 0; root < n; root++)
        if (!dfn[root])
        {
            cnt++;
            DFS(root);
        }
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    while (cin >> n >> m, n || m)
    {
        InitG();
        
        for (int i = 0; i < m; i++)
        {
            int a, b; cin >> a >> b;
            Add(a, b), Add(b, a);
        }

        Tarjan();

        cout << mx + cnt - 1 << '\n';
    }

    return 0;
}
```

### 矿场搭建

题目：https://www.acwing.com/problem/content/description/398/

题解：https://www.acwing.com/solution/content/152028/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
#include <functional>

using namespace std;
using ULL = unsigned long long;

const int N = 1010, M = 1010;

int T;
int n, m;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M]; int idx;

void InitG()
{
    idx = 1;
    memset(H, 0, sizeof H);
}

void Add(int a, int b)
{
    E[idx] = {b, H[a]}, H[a] = idx++;
}

int singleCnt;
int dfn[N], low[N], timeStamp;
int stk[N], top;
bool isCV[N];
int VDCCCnt;
vector<int> VDCC[N];

void Tarjan()
{
    singleCnt = 0;
    timeStamp = 0;
    memset(dfn, 0, sizeof dfn);
    memset(low, 0, sizeof low);
    memset(isCV, 0, sizeof isCV);

    top = 0;

    for (int i = 1; i <= VDCCCnt; i++) 
        VDCC[i].clear();
    VDCCCnt = 0;
    
    int root = 0;

    function<void(int)> DFS = [&](int u)
    {
        if (u == root && H[u] == 0)
        {
            singleCnt++;
            return;
        }

        dfn[u] = low[u] = ++timeStamp;
        stk[++top] = u;

        int cnt = 0;
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            if (!dfn[v])
            {
                DFS(v);
                low[u] = min(low[u], low[v]);
                if (low[v] >= dfn[u])
                {
                    cnt++;
                    if (u != root || cnt > 1) isCV[u] = true;
                    ++VDCCCnt;
                    int w;
                    do
                    {
                        w = stk[top--];
                        VDCC[VDCCCnt].push_back(w);
                    } while (w != v);
                    VDCC[VDCCCnt].push_back(u);
                }
            }
            else low[u] = min(low[u], dfn[v]);
        }
    };

    for (root = 1; root <= n; root++)
        if (!dfn[root])
            DFS(root);
}

void Solve()
{
    InitG();
    n = 0;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        Add(a, b), Add(b, a);
        n = max({n, a, b});
    }

    Tarjan();

    int cnt = singleCnt;
    ULL tot = 1;
    for (int i = 1; i <= VDCCCnt; i++)
    {
        int CVCnt = 0;
        for (int e : VDCC[i])
            if (isCV[e])
                CVCnt++;

        switch (CVCnt)
        {
        case 0:
            cnt += 2;
            tot *= VDCC[i].size() * (VDCC[i].size() - 1) / 2;
            break;
        case 1:
            cnt += 1;
            tot *= VDCC[i].size() - 1;
            break;
        }
    }

    printf("Case %d: %d %llu\n", T, cnt, tot);
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    while (cin >> m, m)
    {
        T++;
        Solve();
    }

    return 0;
}
```

## 二分图

### 关押罪犯

题目：https://www.acwing.com/problem/content/description/259/

题解：https://www.acwing.com/solution/content/3042/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 2e4 + 10, M = 2e5 + 10;

int n, m;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M]; int idx;

void InitG()
{
    idx = 1;
}

void Add(int a, int b, int w)
{
    E[idx] = {b, w, H[a]}, H[a] = idx++;
}

int color[N];
int Q[N], hh, tt;

bool BFS(int start, int mid)
{
    hh = 0, tt = -1;
    Q[++tt] = start;
    color[start] = 1;

    while (hh <= tt)
    {
        int u = Q[hh++];
        int c = color[u];

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (w > mid)
            {
                if (color[v])
                {
                    if (color[v] == c) return false;
                }
                else
                {
                    color[v] = -c;
                    Q[++tt] = v;
                }
            }
        }
    }

    return true;
}

bool check(int mid)
{
    memset(color, 0, sizeof color);

    for (int i = 1; i <= n; i++)
        if (!color[i])
            if (!BFS(i, mid))
                return false;
    return true;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    InitG();

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        Add(a, b, w), Add(b, a, w);
    }

    int l = 0, r = 1e9;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }

    cout << l << '\n';

    return 0;
}
```

### 棋盘覆盖

题目：https://www.acwing.com/problem/content/description/374/

题解：https://www.acwing.com/solution/content/25013/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

int n, m;
bool G[N][N], st[N][N];
struct Point
{
    int x, y;
} match[N][N];

int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

bool Find(Point u)
{
    for (int i = 0; i < 4; i++)
    {
        int x = u.x + dx[i], y = u.y + dy[i];
        if (x < 1 || x > n || y < 1 || y > n) continue;
        if (st[x][y] || G[x][y]) continue;
        
        st[x][y] = true;
        if (match[x][y].x == 0 || Find(match[x][y]))
        {
            match[x][y] = u;
            return true;
        }
    }

    return false;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        G[a][b] = true;
    }

    int res = 0;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            if ((i + j) % 2 && !G[i][j])
            {
                memset(st, 0, sizeof st);
                res += Find({i, j});
            }

    cout << res << '\n';

    return 0;
}
```

### 机器任务

题目：https://www.acwing.com/problem/content/378/

题解：https://www.acwing.com/solution/content/25058/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110, M = 1010;

int n1, n2, m;
bool G[N][N];

bool st[N];
int match[N];

bool Find(int u)
{
    for (int v = 1; v < n2; v++)
        if (G[u][v] && !st[v])
        {
            st[v] = true;
            if (match[v] == 0 || Find(match[v]))
            {
                match[v] = u;
                return true;
            }
        }

    return false;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    while (cin >> n1, n1)
    {
        memset(G, 0, sizeof G);
        memset(match, 0, sizeof match);

        cin >> n2 >> m;
        for (int i = 0; i < m; i++)
        {
            int t, a, b; cin >> t >> a >> b;
            if (a == 0 || b == 0) continue;
            G[a][b] = true;
        }

        int res = 0;
        for (int i = 1; i < n1; i++)
        {
            memset(st, 0, sizeof st);
            res += Find(i);
        }

        cout << res << '\n';
    }

    return 0;
}
```

### 骑士放置

题目：https://www.acwing.com/problem/content/description/380/

最大独立集=删除最少点和连接它们的边，使得剩下的点互不相连

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

int n, m, K;
bool G[N][N];

bool st[N][N];
struct Point
{
    int x, y;
} match[N][N];

int dx[8] = {-2, -1, 1, 2, 2, 1, -1, -2};
int dy[8] = {1, 2, 2, 1, -1, -2, -2, -1};

bool Find(Point u)
{
    for (int i = 0; i < 8; i++)
    {
        int x = u.x + dx[i], y = u.y + dy[i];
        if (x < 1 || x > n || y < 1 || y > m) continue;
        if (st[x][y] || G[x][y]) continue;

        st[x][y] = true;
        auto& v = match[x][y];
        if (v.x == 0 || Find(v))
        {
            v = u;
            return true;
        }
    }

    return false;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m >> K;
    for (int i = 0; i < K; i++)
    {
        int x, y; cin >> x >> y;
        G[x][y] = true;
    }

    int cnt = 0;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            if ((i + j) % 2 && !G[i][j])
            {
                memset(st, 0, sizeof st);
                cnt += Find({i, j});
            }

    cout << n * m - K - cnt << '\n';

    return 0;
}
```

### 捉迷藏

题目：https://www.acwing.com/problem/content/381/

题解：https://www.acwing.com/solution/content/15162/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 210;

int n, m;
bool G[N][N];

bool st[N];
int match[N];

bool Find(int u)
{
    for (int v = 1; v <= n; v++)
        if (G[u][v] && !st[v])
        {
            st[v] = true;

            if (match[v] == 0 || Find(match[v]))
            {
                match[v] = u;
                return true;
            }
        }

    return false;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int x, y; cin >> x >> y;
        G[x][y] = true;
    }

    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                G[i][j] |= G[i][k] & G[k][j];

    int cnt = 0;
    for (int i = 1; i <= n; i++)
    {
        memset(st, 0, sizeof st);
        cnt += Find(i);
    }
    
    cout << n - cnt << '\n';

    return 0;
}
```

## 欧拉回路和欧拉路径

### 铲雪车

题目：https://www.acwing.com/problem/content/description/1125/

```c++
#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
#include <algorithm>

using namespace std;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    double x, y; cin >> x >> y;
    double d = 0;
    double x1, y1, x2, y2;
    while (cin >> x1 >> y1 >> x2 >> y2)
    {
        double dx = x2 - x1, dy = y2 - y1;
        d += sqrt(dx * dx + dy * dy);
    }

    int minutes = round(d * 2 / 1000 / 20 * 60);
    printf("%d:%02d", minutes / 60, minutes % 60);

    return 0;
}
```

### 欧拉回路

题目：https://www.acwing.com/problem/content/description/1186/

题解：https://www.acwing.com/solution/content/53434/

**st剔除重复无向边：**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10, M = 4e5 + 10;

int T;
int n, m;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M]; int idx;

void InitG()
{
    memset(H, -1, sizeof H);
}

void Add(int a, int b)
{
    E[idx] = {b, H[a]}, H[a] = idx++;
}

int din[N], dout[N];

bool st[M];
int res[M / 2], cnt;

void DFS(int u)
{
    while (~H[u])
    {
        int p = H[u];
        if (st[p])
        {
            H[u] = E[p].n;
            continue;
        }

        // st[p] = true;
        if (T == 1) st[p ^ 1] = true;

        H[u] = E[p].n;

        int v = E[p].v;
        DFS(v);
        if (T == 1)
        {
            if (p % 2) p = -(p / 2 + 1);
            else p = p / 2 + 1;
        }
        else p++;
        res[++cnt] = p;
    }
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    InitG();

    cin >> T >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        Add(a, b);
        if (T == 1) Add(b, a);
        din[b]++, dout[a]++;
    }

    for (int u = 1; u <= n; u++)
        if (~H[u])
        {
            DFS(u);
            break;
        }

    if (cnt < m)
    {
        puts("NO");
        return 0;
    }
    if (T == 1)
    {
        for (int i = 1; i <= n; i++)
            if ((din[i] + dout[i]) % 2)
            {
                puts("NO");
                return 0;
            }
    }
    else
    {
        for (int i = 1; i <= n; i++)
            if (din[i] != dout[i])
            {
                puts("NO");
                return 0;
            }
    }

    puts("YES");
    for (int i = cnt; i >= 1; i--)
        printf("%d ", res[i]);
    puts("");

    return 0;
}
```

**双链表删除无向图的重复边：**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10, M = 4e5 + 10;

int T;
int n, m;
int H[N];
struct EdgeNode
{
    int u, v, p, n;
} E[M]; int idx;

void InitG()
{
    memset(H, -1, sizeof H);
}

void Add(int a, int b)
{
    E[idx] = {a, b, -1, H[a]};
    if (~H[a]) E[H[a]].p = idx;
    H[a] = idx++;
}

int din[N], dout[N];
int res[M / 2], cnt;

void DFS(int u)
{
    while (~H[u])
    {
        int p = H[u];

        H[u] = E[p].n;
        if (T == 1)
        {
            if (~H[u]) E[H[u]].p = -1;
            int h = E[p ^ 1].u, pre = E[p ^ 1].p, nxt = E[p ^ 1].n;
            if (~pre)
            {
                E[pre].n = nxt;
                if (~nxt) E[nxt].p = pre;
            }
            else H[h] = nxt;
        }

        int v = E[p].v;
        DFS(v);
        if (T == 1)
        {
            if (p % 2) p = -(p / 2 + 1);
            else p = p / 2 + 1;
        }
        else p++;
        res[++cnt] = p;
    }
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    InitG();

    cin >> T >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        Add(a, b);
        if (T == 1) Add(b, a);
        din[b]++, dout[a]++;
    }

    for (int u = 1; u <= n; u++)
        if (~H[u])
        {
            DFS(u);
            break;
        }

    if (cnt < m)
    {
        puts("NO");
        return 0;
    }
    if (T == 1)
    {
        for (int i = 1; i <= n; i++)
            if ((din[i] + dout[i]) % 2)
            {
                puts("NO");
                return 0;
            }
    }
    else
    {
        for (int i = 1; i <= n; i++)
            if (din[i] != dout[i])
            {
                puts("NO");
                return 0;
            }
    }

    puts("YES");
    for (int i = cnt; i >= 1; i--)
        printf("%d ", res[i]);
    puts("");

    return 0;
}
```

### 骑马修栅栏

题目：https://www.acwing.com/problem/content/description/1126/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 510, M = 1050;

int n = 500, m;
int G[N][N], D[N];

int res[M], cnt;

void DFS(int u)
{
    for (int v = 1; v <= n; v++)
        if (G[u][v])
        {
            G[u][v]--, G[v][u]--;
            DFS(v);
        }

    res[++cnt] = u;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        G[a][b]++, G[b][a]++;
        D[a]++, D[b]++;
    }

    // 两个循环应对欧拉路径的两种情况
    int start = 1;
    for (int i = 1; i <= n; i++)
        if (D[i] != 0)
        {
            start = i;
            break;
        }
    for (int i = start; i <= n; i++)
        if (D[i] % 2)
        {
            start = i;
            break;
        }

    DFS(start);

    for (int i = cnt; i >= 1; i--) cout << res[i] << '\n';

    return 0;
}
```

### 单词游戏

题目：https://www.acwing.com/problem/content/description/1187/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 30, M = 1e5 + 10;

int n = 26, m;
int din[N], dout[N];

int P[N];

int Find(int x)
{
    if (x != P[x]) P[x] = Find(P[x]);
    return P[x];
}

bool st[N];

void Solve()
{
    memset(din, 0, sizeof din);
    memset(dout, 0, sizeof dout);
    for (int i = 0; i < n; i++) P[i] = i;
    memset(st, 0, sizeof st);

    cin >> m;
    for (int i = 0; i < m; i++)
    {
        string str; cin >> str;
        int a = str.front() - 'a', b = str.back() - 'a';

        dout[a]++, din[b]++;
        st[a] = st[b] = true;
        P[Find(a)] = Find(b);
    }

    int root = -1;
    for (int i = 0; i < n; i++)
        if (st[i])
        {
            root = Find(i);
            break;
        }
    for (int i = 0; i < n; i++)
        if (st[i] && root != Find(i))
        {
            cout << "The door cannot be opened." << '\n';
            return;
        }

    int start = 0, end = 0;
    for (int i = 0; i < n; i++)
        if (din[i] != dout[i])
        {
            if      (din[i] == dout[i] + 1) end++;
            else if (din[i] + 1 == dout[i]) start++;
            else
            {
                cout << "The door cannot be opened." << '\n';
                return;
            }
        }
    if ((start == 1 && end == 1) || (start == 0 && end == 0))
        cout << "Ordering is possible." << '\n';
    else cout << "The door cannot be opened." << '\n';
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    
    int t; cin >> t;
    while (t--) Solve();

    return 0;
}
```

## 拓扑排序

### 家谱树

题目：https://www.acwing.com/problem/content/description/1193/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

int n;
bool G[N][N];
int D[N];

int Q[N], hh, tt;

bool TopSort()
{
    hh = 0, tt = -1;
    for (int i = 1; i <= n; i++)
        if (D[i] == 0)
            Q[++tt] = i;

    while (hh <= tt)
    {
        int u = Q[hh++];
        for (int v = 1; v <= n; v++)
            if (G[u][v])
            {
                D[v]--;
                if (D[v] == 0) Q[++tt] = v;
            }
    }

    return tt + 1 == n;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        int son;
        while (cin >> son, son)
        {
            G[i][son] = true;
            D[son]++;
        }
    }

    TopSort();

    for (int i = 0; i < n; i++) cout << Q[i] << ' ';
    cout << '\n';

    return 0;
}
```

### 奖金

题目：https://www.acwing.com/problem/content/description/1194/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e4 + 10, M = 2e4 + 10;

int n, m;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M]; int idx = 1;

void Add(int a, int b)
{
    E[idx] = {b, H[a]}, H[a] = idx++;
}

int D[N];

int Q[N], hh, tt;

bool TopSort()
{
    hh = 0, tt = -1;
    for (int i = 1; i <= n; i++)
        if (D[i] == 0)
            Q[++tt] = i;

    while (hh <= tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            if (--D[v] == 0)
                Q[++tt] = v;
        }
    }
    
    return tt + 1 == n;
}

int dist[N];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        Add(b, a);
        D[a]++;
    }

    if (TopSort())
    {
        for (int i = 1; i <= n; i++) dist[i] = 100;
        for (int i = 0; i < n; i++)
        {
            int u = Q[i];
            for (int p = H[u]; p; p = E[p].n)
            {
                int v = E[p].v;
                dist[v] = max(dist[v], dist[u] + 1);
            }
        }

        int res = 0;
        for (int i = 1; i <= n; i++) res += dist[i];
        cout << res << '\n';
    }
    else cout << "Poor Xed" << '\n';

    return 0;
}
```

### 可达性统计

题目：https://www.acwing.com/problem/content/description/166/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <bitset>

using namespace std;

const int N = 3e4 + 10, M = 3e4 + 10;

int n, m;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M]; int idx = 1;

void Add(int a, int b)
{
    E[idx] = {b, H[a]}, H[a] = idx++;
}

int D[N];
int Q[N], hh, tt;

bitset<N> f[N];

void TopSort()
{
    hh = 0, tt = -1;
    for (int i = 1; i <= n; i++)
        if (D[i] == 0)
            Q[++tt] = i;

    while (hh <= tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            if (--D[v] == 0)
                Q[++tt] = v;
        }
    }
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        Add(a, b);
        D[b]++;
    }

    TopSort();

    for (int i = tt; i >= 0; i--)
    {
        int u = Q[i];
        f[u][u] = 1;
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            f[u] = f[u] | f[v];
        }
    }

    for (int i = 1; i <= n; i++) cout << f[i].count() << '\n';

    return 0;
}
```

### 车站分级

题目：https://www.acwing.com/problem/content/description/458/

题解：https://www.acwing.com/solution/content/17458/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 2010, M = 1e6 + 10;

int n, m;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M]; int idx = 1;

void Add(int a, int b, int w)
{
    E[idx] = {b, w, H[a]}, H[a] = idx++;
}

bool st[N];
int D[N];
int Q[N], hh, tt;

void TopSort()
{
    hh = 0, tt = -1;

    for (int i = 1; i <= n + m; i++)
        if (D[i] == 0)
            Q[++tt] = i;

    while (hh <= tt)
    {
        int u = Q[hh++];

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            if (--D[v] == 0)
                Q[++tt] = v;
        }
    }
}

int dist[N];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= m; i++)
    {
        memset(st, 0, sizeof st);
        int cnt; cin >> cnt;
        int start; cin >> start;
        for (int j = 2; j < cnt; j++)
        {
            int x; cin >> x;
            st[x] = true;
        }
        int end; cin >> end;
        st[start] = st[end] = true;

        int vir = n + i;
        for (int j = start; j <= end; j++)
        {
            if (st[j])
            {
                Add(vir, j, 1);
                D[j]++;
            }
            else
            {
                Add(j, vir, 0);
                D[vir]++;
            }
        }
    }

    TopSort();

    for (int i = 1; i <= n; i++) dist[i] = 1;

    for (int i = 0; i <= tt; i++)
    {
        int u = Q[i];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            dist[v] = max(dist[v], dist[u] + w);
        }
    }

    int res = 0;
    for (int i = 1; i <= n; i++) res = max(res, dist[i]);
    cout << res << '\n';

    return 0;
}
```

