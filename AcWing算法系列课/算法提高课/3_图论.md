# 图论

## 单源最短路的建图方式

### 热浪

题目：https://www.acwing.com/problem/content/description/1131/

**堆优化dijkstra：**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using LL = long long;
using std::cin, std::cout;

const int N = 2510, M = 6210;

int n, m;
int start, end;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M * 2];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

bool st[N];
int dist[N];

void dijkstra()
{
    struct Node
    {
        int d, v;

        bool operator< (const Node &ct) const
        {
            return d >= ct.d;
        }
    };
    std::priority_queue<Node> Q;

    memset(dist, 0x3f, sizeof dist);
    dist[start] = 0;
    Q.push({0, start});

    while (!Q.empty())
    {
        auto [d, u] = Q.top(); Q.pop();

        if (st[u]) continue;
        st[u] = true;

        if (u == end) return;

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (d + w < dist[v])
            {
                dist[v] = d + w;
                Q.push({dist[v], v});
            }
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m >> start >> end;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w), add(b, a, w);
    }

    dijkstra();

    cout << dist[end] << '\n';

    return 0;
}
```

**spfa：**

```c++
#include <cstring>
#include <iostream>
#include <queue>

using namespace std;

const int N = 2510, M = 6210, INF = 0x3f3f3f3f;

int n, m, start, dest;
int H[N];
struct ListNode
{
    int v, w, n;
} L[M * 2]; int idx = 1;

void add(int a, int b, int w)
{
    L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

int dist[N];
bool st[N];
void spfa()
{
    memset(dist, 0x3f, sizeof dist);
    queue<int> Q;
    dist[start] = 0;
    st[start] = true;
    Q.push(start);
    
    while (!Q.empty())
    {
        int cur = Q.front(); Q.pop();
        st[cur] = false;

        for (int p = H[cur]; p; p = L[p].n)
        {
            int v = L[p].v, w = L[p].w;
            if (dist[cur] + w < dist[v])
            {
                dist[v] = dist[cur] + w;
                if (!st[v])
                {
                    st[v] = true;
                    Q.push(v);
                }
            }
        }
    }
}

int main()
{
    scanf("%d%d%d%d", &n, &m, &start, &dest);
    for (int i = 1; i <= m; i++)
    {
        int a, b, w; scanf("%d%d%d", &a, &b, &w);
        add(a, b, w), add(b, a, w);
    }

    spfa();

    printf("%d\n", dist[dest]);

    return 0;
}
```

### 信使

题目：https://www.acwing.com/problem/content/description/1130/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using LL = long long;
using std::cin, std::cout;

const int N = 110, M = 210, INF = 0x3f3f3f3f;

int n, m;
int G[N][N];

bool st[N];
int dist[N];
int res;

bool dijkstra()
{
    struct Node
    {
        int d, v;

        bool operator< (const Node &ct) const
        {
            return d >= ct.d;
        }
    };
    std::priority_queue<Node> Q;
    Q.push({0, 1});
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    int cnt = 0;
    while (!Q.empty())
    {
        auto [d, u] = Q.top(); Q.pop();

        if (st[u]) continue;
        st[u] = true;

        cnt++;
        res = std::max(res, dist[u]);

        for (int v = 1; v <= n; v++)
            if (d + G[u][v] < dist[v])
            {
                dist[v] = d + G[u][v];
                Q.push({dist[v], v});
            }
    }

    return cnt == n;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    memset(G, 0x3f, sizeof G);
    for (int i = 0; i < N; i++) G[i][i] = 0;

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        G[a][b] = G[b][a] = std::min(G[a][b], w);
    }

    if (dijkstra()) cout << res << '\n';
    else cout << -1 << '\n';
    
    return 0;
}
```

### 香甜的黄油

题目：https://www.acwing.com/problem/content/description/1129/

本题用floyd算法无法通过。

**spfa：**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using LL = long long;
using std::cin, std::cout;

const int N = 1000, M = 3000, INF = 0x3f3f3f3f;

int n, m, numCow;
int cow[N];
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

int dist[N];
bool st[N];

void spfa(int start)
{
    memset(dist, 0x3f, sizeof dist);
    memset(st, 0, sizeof st);
    std::queue<int> Q;
    Q.push(start);
    st[start] = true;
    dist[start] = 0;

    while (!Q.empty())
    {
        int u = Q.front(); Q.pop();
        st[u] = false;

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[u] + w < dist[v])
            {
                dist[v] = dist[u] + w;
                if (!st[v])
                {
                    Q.push(v);
                    st[v] = true;
                }
            }
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> numCow >> n >> m;
    for (int i = 1; i <= numCow; i++) cin >> cow[i];
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w), add(b, a, w);
    }

    int res = INF;
    for (int i = 1; i <= n; i++)
    {
        spfa(i);
        int sum = 0;
        for (int i = 1; i <= numCow; i++)
        {
            if (dist[cow[i]] == INF)
            {
                sum = INF;
                break;
            }
            sum += dist[cow[i]];
        }
        res = std::min(res, sum);
    }

    cout << res << '\n';

    return 0;
}
```

**堆优化dijkstra：**

就本题来说，dijkstra比spfa慢多了。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using LL = long long;
using std::cin, std::cout;

const int N = 1000, M = 3000, INF = 0x3f3f3f3f;

int n, m;
int cow[N], numCow;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

int dist[N];
bool st[N];

void dijkstra(int start)
{
    struct Node
    {
        int d, v;

        bool operator< (const Node &ct) const
        {
            return d >= ct.d;
        }
    };
    std::priority_queue<Node> Q;
    Q.push({0, start});
    memset(dist, 0x3f, sizeof dist);
    dist[start] = 0;
    memset(st, 0, sizeof st);

    while (!Q.empty())
    {
        auto [d, u] = Q.top(); Q.pop();

        if (st[u]) continue;
        st[u] = true;

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (d + w < dist[v])
            {
                dist[v] = d + w;
                Q.push({dist[v], v});
            }
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> numCow >> n >> m;
    for (int i = 1; i <= numCow; i++) cin >> cow[i];
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w), add(b, a, w);
    }

    int res = INF;
    for (int i = 1; i <= n; i++)
    {
        dijkstra(i);
        int sum = 0;
        for (int j = 1; j <= numCow; j++)
        {
            if (dist[cow[j]] == INF)
            {
                sum = INF;
                break;
            }
            sum += dist[cow[j]];
        }
        res = std::min(res, sum);
    }

    cout << res << '\n';

    return 0;
}
```

### 最小花费

题目：https://www.acwing.com/problem/content/description/1128/

题解：https://www.acwing.com/solution/content/94237/

**dijkstra：**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 2005;

int n, m;
int start, end;
double G[N][N];

double dist[N];
bool st[N];

void dijkstra()
{
    dist[start] = 1;

    for (int i = 0; i < n; i++)
    {
        int u = -1;
        for (int j = 1; j <= n; j++)
            if (!st[j] && (u == -1 || dist[j] > dist[u]))
                u = j;

        st[u] = true;
        if (u == end) return;

        for (int v = 1; v <= n; v++)
            dist[v] = std::max(dist[v], dist[u] * G[u][v]);
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    for (int i = 0; i < N; i++) G[i][i] = 1;

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        G[a][b] = G[b][a] = std::max(G[a][b], double(100 - w) / 100);
    }
    cin >> start >> end;

    dijkstra();

    printf("%.8lf\n", 100 / dist[end]);

    return 0;
}
```

**spfa：**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 2010;

int n, m;
int start, end;
double G[N][N];

double dist[N];
bool st[N];
int Q[N], hh, tt;

void spfa()
{
    dist[start] = 1;
    Q[tt++] = start;
    st[start] = true;

    while (hh != tt)
    {
        int u = Q[hh++]; hh %= N;
        st[u] = false;

        for (int v = 1; v <= n; v++)
            if (dist[u] * G[u][v] > dist[v])
            {
                dist[v] = dist[u] * G[u][v];
                if (!st[v])
                {
                    Q[tt++] = v; tt %= N;
                    st[v] = true;
                }
            }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    for (int i = 0; i < N; i++) G[i][i] = 1;

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        G[a][b] = G[b][a] = std::max(G[a][b], double(100 - w) / 100);
    }
    cin >> start >> end;

    spfa();

    printf("%.8lf\n", 100 / dist[end]);

    return 0;
}
```



### 最优乘车

题目：https://www.acwing.com/problem/content/description/922/

本题难在建图。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <sstream>

using LL = long long;
using std::cin, std::cout;

const int N = 510, M = 110;

int n, m;
bool G[N][N];
int stop[M];

int Q[N], hh, tt;
bool st[N];
int dist[N];

bool bfs()
{
    Q[tt++] = 1;
    st[1] = true;
    dist[1] = -1;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int v = 1; v <= n; v++)
            if (G[u][v] && !st[v])
            {
                dist[v] = dist[u] + 1;
                st[v] = true;
                if (v == n) return true;
                Q[tt++] = v;
            }
    }

    return false;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> m >> n; 
    std::string line;
    std::getline(cin, line); // 读回车
    for (int i = 0; i < m; i++)
    {
        std::getline(cin, line);
        std::stringstream ss(line);
        int p = 0, cnt = 0;
        while (ss >> p) stop[++cnt] = p;
        for (int j = 1; j <= cnt; j++)
            for (int k = j + 1; k <= cnt; k++)
                G[stop[j]][stop[k]] = true;
    }

    if (bfs()) cout << dist[n] << '\n';
    else cout << "NO" << '\n';

    return 0;
}
```

### 昂贵的聘礼

题目：https://www.acwing.com/problem/content/description/905/

思路是反向建图，0号点是虚拟原点，从0号点到其他点的边权是直接购买该物品需要的钱。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 110, INF = 0x3f3f3f3f;

int n, m;
int G[N][N];
int L[N];

int dist[N];
bool st[N];

bool dijkstra(int dn, int up)
{
    memset(dist, 0x3f, sizeof dist);
    memset(st, 0, sizeof st);
    dist[0] = 0;

    for (int i = 0; i <= n; i++)
    {
        int u = -1;
        for (int j = 0; j <= n; j++)
            if (!st[j] && (u == -1 || dist[j] < dist[u]))
                u = j;

        st[u] = true;
        if (u == 1) return true;

        for (int v = 1; v <= n; v++)
            if (L[v] >= dn && L[v] <= up)
                dist[v] = std::min(dist[v], dist[u] + G[u][v]);
    }

    return false;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    memset(G, 0x3f, sizeof G);
    for (int i = 0; i < N; i++) G[i][i] = 0;

    cin >> m >> n;
    for (int i = 1; i <= n; i++)
    {
        int p, l, x; cin >> p >> l >> x;
        G[0][i] = std::min(G[0][i], p);
        L[i] = l;
        while (x--)
        {
            int t, v; cin >> t >> v;
            G[t][i] = std::min(G[t][i], v);
        }
    }

    int res = INF;
    for (int i = L[1] - m; i <= L[1]; i++)
        if (dijkstra(i, i + m))
            res = std::min(res, dist[1]);

    cout << res << '\n';
    return 0;
}
```

## 单源最短路的综合应用

### 新年好

题目：https://www.acwing.com/problem/content/description/1137/

先将1和输入给的五个点分别做源点使用dijkstra，之后通过dfs搜索访问顺序。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using LL = long long;
using std::cin, std::cout;

const int N = 5e4 + 5, M = 1e5 + 5, INF = 0x3f3f3f3f;

int n, m;
int stop[6];
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M * 2];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

int dist[6][N];
bool st[N];

void dijkstra(int start, int dist[N])
{
    memset(st, 0, sizeof st);
    for (int i = 1; i <= n; i++) dist[i] = INF;
    dist[start] = 0;

    struct Node
    {
        int d, v;

        bool operator< (const Node &ct) const
        {
            return d >= ct.d;
        }
    };
    std::priority_queue<Node> Q;
    Q.push({0, start});

    while (!Q.empty())
    {
        auto [d, u] = Q.top(); Q.pop();

        if (st[u]) continue;
        st[u] = true;

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[u] + w < dist[v])
            {
                dist[v] = dist[u] + w;
                Q.push({dist[v], v});
            }
        }
    }
}

int res;

void dfs(int i, int last, int time)
{
    if (time >= res) return;

    if (i > 5)
    {
        res = time;
        return;
    }

    for (int j = 1; j <= 5; j++)
        if (!st[j])
        {
            st[j] = true;
            dfs(i + 1, j, time + dist[last][stop[j]]);
            st[j] = false;
        }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    stop[0] = 1;
    for (int i = 1; i <= 5; i++) cin >> stop[i];
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w), add(b, a, w);
    }

    for (int i = 0; i <= 5; i++) dijkstra(stop[i], dist[i]);

    res = INF;
    for (int i = 1; i <= 5; i++) st[i] = false;
    dfs(1, 0, 0);

    cout << res << '\n';

    return 0;
}
```

### 通信线路

题目：https://www.acwing.com/problem/content/description/342/

题解：https://www.acwing.com/solution/content/13645/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using LL = long long;
using std::cin, std::cout;

const int N = 1010, M = 1e4 + 5, INF = 0x3f3f3f3f;

int n, m, K;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M * 2];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

int dist[N];
bool st[N];

bool dijkstra(int x)
{
    std::deque<int> Q;
    Q.push_back(1);
    memset(st, 0, sizeof st);
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    while (!Q.empty())
    {
        int u = Q.front(); Q.pop_front();

        if (st[u]) continue;
        st[u] = true;

        if (u == n) break;

        for (int p = H[u]; p; p = E[p].n)    
        {
            int v = E[p].v, w = E[p].w > x;
            if (dist[u] + w < dist[v])
            {
                dist[v] = dist[u] + w;
                if (w) Q.push_back(v);
                else Q.push_front(v);
            }
        }
    }

    return dist[n] <= K;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m >> K;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w), add(b, a, w);
    }

    dijkstra(0);
    if (dist[n] == INF)
    {
        cout << -1 << '\n';
        return 0;
    }

    int l = 0, r = 1e6;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (dijkstra(mid)) r = mid;
        else l = mid + 1;
    }
    cout << l << '\n';

    return 0;
}
```

### 道路与航线

题目：https://www.acwing.com/problem/content/description/344/

题解：https://www.acwing.com/solution/content/33202/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>

using LL = long long;
using std::cin, std::cout;

const int N = 25e3 + 5, M = 5e4 + 5, INF = 0x3f3f3f3f;

int n, m1, m2;
int start;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M * 3];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

int blkCnt;
int blkId[N];
std::vector<int> blk[N];

void dfs(int u)
{
    blkId[u] = blkCnt;
    blk[blkCnt].push_back(u);

    for (int p = H[u]; p; p = E[p].n)
    {
        int v = E[p].v;
        if (blkId[v] == 0) dfs(v);
    }
}


int dist[N];
bool st[N];
int blkQ[N], hh, tt;
int blkIn[N];

void dijkstra(int id)
{
    struct Node
    {
        int d, v;

        bool operator< (const Node &ct) const
        {
            return d >= ct.d;
        }
    };
    std::priority_queue<Node> Q;

    for (int u : blk[id]) Q.push({dist[u], u});

    while (!Q.empty())
    {
        auto [d, u] = Q.top(); Q.pop();

        if (st[u]) continue;
        st[u] = true;

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (blkId[u] != blkId[v] && --blkIn[blkId[v]] == 0) 
                blkQ[tt++] = blkId[v];
            if (dist[u] + w < dist[v])
            {
                dist[v] = dist[u] + w;
                if (blkId[u] == blkId[v]) Q.push({dist[v], v});
            }
        }
    }

}

void topSort()
{
    memset(dist, 0x3f, sizeof dist);
    dist[start] = 0;

    for (int i = 1; i <= blkCnt; i++)
        if (blkIn[i] == 0)
            blkQ[tt++] = i;

    while (hh != tt)
    {
        int id = blkQ[hh++];
        dijkstra(id);
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m1 >> m2 >> start;
    for (int i = 0; i < m1; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w), add(b, a, w);
    }

    for (int i = 1; i <= n; i++)
        if (blkId[i] == 0)
        {
            blkCnt++;
            dfs(i);
        }

    for (int i = 0; i < m2; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w);
        blkIn[blkId[b]]++;
    }

    topSort();

    for (int i = 1; i <= n; i++)
    {
        if (dist[i] < INF / 2) cout << dist[i] << '\n';
        else cout << "NO PATH" << '\n';
    }

    return 0;
}
```

### 最优贸易

题目：https://www.acwing.com/problem/content/description/343/

题解：https://www.acwing.com/solution/content/3709/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e5 + 5, M = 5e5 + 5;

int n, m;
int price[N];
int H[N], HR[N];
struct EdgeNode
{
    int v, n;
} E[M * 4];
int idx;

void add(int H[], int a, int b)
{
    E[++idx] = {b, H[a]}, H[a] = idx;
}

int Q[N];
bool st[N];
int mn[N];

void spfaMin()
{
    memset(mn, 0x3f, sizeof mn);

    int hh = 0, tt = 0;
    Q[tt++] = 1;
    st[1] = true;
    mn[1] = price[1];

    while (hh != tt)
    {
        int u = Q[hh++]; hh %= N;
        st[u] = false;

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            if (std::min(mn[u], price[v]) < mn[v])
            {
                mn[v] = std::min(mn[u], price[v]);
                if (!st[v])
                {
                    Q[tt++] = v; tt %= N;
                    st[v] = true;
                }
            }
        }
    }
}

int mx[N];

void spfaMax()
{
    int hh = 0, tt = 0;
    Q[tt++] = n;
    st[n] = true;
    mx[n] = price[n];

    while (hh != tt)
    {
        int u = Q[hh++]; hh %= N;
        st[u] = false;

        for (int p = HR[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            if (std::max(mx[u], price[v]) > mx[v])  
            {
                mx[v] = std::max(mx[u], price[v]);
                if (!st[v])
                {
                    Q[tt++] = v; tt %= N;
                    st[v] = true;
                }
            }
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> price[i];
    for (int i = 0; i < m; i++)
    {
        int a, b, c; cin >> a >> b >> c;
        add(H, a, b), add(HR, b, a);
        if (c == 2) add(H, b, a), add(HR, a, b);
    }

    spfaMin();
    spfaMax();

    int res = 0;
    for (int i = 1; i <= n; i++)
        if (mx[i] - mn[i] > res)
            res = mx[i] - mn[i];

    cout << res << '\n';

    return 0;
}
```

## 单源最短路的扩展应用

### 选择最佳线路

题目：https://www.acwing.com/problem/content/description/1139/

虚拟源点法。本题可以用spfa或dijkstra。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using LL = long long;
using std::cin, std::cout;

const int N = 1010, M = 2e4 + 5;

int n, m, end;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

bool st[N];
int dist[N];

void solve()
{
    memset(H, 0, sizeof H);
    idx = 0;

    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w);
    }

    memset(dist, 0x3f, sizeof dist);
    memset(st, 0, sizeof st);

    struct Node
    {
        int d, v;

        bool operator< (const Node &ct) const
        {
            return d >= ct.d;
        }
    };
    std::priority_queue<Node> Q;
    int cnt; cin >> cnt;
    while (cnt--)
    {
        int start; cin >> start;
        Q.push({0, start});
        dist[start] = 0;        
    }

    while (!Q.empty())
    {
        auto [d, u] = Q.top(); Q.pop();

        if (st[u]) continue;
        st[u] = true;

        if (u == end) break;

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[u] + w < dist[v])
            {
                dist[v] = dist[u] + w;
                Q.push({dist[v], v});
            }
        }
    }

    if (st[end]) cout << dist[end] << '\n';
    else cout << -1 << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    while (cin >> n >> m >> end)
        solve();

    return 0;
}
```

### 拯救大兵瑞恩

题目：https://www.acwing.com/problem/content/description/1133/

题解：https://www.acwing.com/solution/content/176795/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <unordered_set>
#include <queue>

using LL = long long;
using std::cin, std::cout;

const int N = 11, M = N * N, S = 1 << 10;

int n, m, p;
int H[M];
struct EdgeNode
{
    int v, w, n;
} E[M * 4];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

int G[N][N], cnt;
std::unordered_set<int> ht;

int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

void build()
{
    for (int px = 1; px <= n; px++)
        for (int py = 1; py <= m; py++)
        {
            int a = G[px][py];
            for (int i = 0; i < 4; i++)
            {
                int x = px + dx[i], y = py + dy[i];
                if (x >= 1 && x <= n && y >= 1 && y <= m)
                {
                    int b = G[x][y];
                    if (!ht.count((a << 16) + b)) add(a, b, 0);
                }
            }
        }
}

int key[M];
int dist[M][S];
bool st[M][S];

int bfs()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1][0] = 0;

    std::deque<std::pair<int, int>> Q;
    Q.push_back({1, 0});

    while (!Q.empty())
    {
        auto [ux, uy] = Q.front(); Q.pop_front();

        if (st[ux][uy]) continue;
        st[ux][uy] = true;

        if (ux == n * m) return dist[ux][uy];

        if (key[ux])
        {
            int vy = uy | key[ux];
            if (dist[ux][uy] < dist[ux][vy])
            {
                dist[ux][vy] = dist[ux][uy];
                Q.push_front({ux, vy});
            }
        }

        for (int p = H[ux]; p; p = E[p].n)
        {
            int vx = E[p].v, w = E[p].w;
            if ((w == 0 || uy >> (w - 1) & 1) &&
                dist[ux][uy] + 1 < dist[vx][uy])
            {
                dist[vx][uy] = dist[ux][uy] + 1;
                Q.push_back({vx, uy});
            }
        }
    }

    return -1;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m >> p;

    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            G[i][j] = ++cnt;

    int t; cin >> t;
    while (t--)
    {
        int x1, y1, x2, y2, g; cin >> x1 >> y1 >> x2 >> y2 >> g;
        int a = G[x1][y1], b = G[x2][y2];
        ht.insert((a << 16) + b), ht.insert((b << 16) + a);
        if (g) add(a, b, g), add(b, a, g);
    }

    build();

    cin >> t;
    while (t--)
    {
        int x, y, q; cin >> x >> y >> q;
        key[G[x][y]] |= 1 << (q - 1);
    }

    cout << bfs() << '\n';

    return 0;
}
```

### 最短路计数

题目：https://www.acwing.com/problem/content/description/1136/

在`bfs`的队列中，被取出的节点u的后驱节点v有几种类型，

1. 第一次访问的节点，即我们找到了第一条最短路；
2. 已经被访问过的节点，并且从u到v是某条最短路上的节点；
3. 已经被访问过的节点，但从u到v并不是任何一条最短路上的节点。

本题基于动态规划的思想，利用`bfs`队列的规律，我们可以知道，当队头节点u被取出时，任何一条最短路上的节点u的前驱节点已经被取出，因此到u节点的最短路条数可以被正确的计算得出，记作$f(u)$。根据节点u的后驱节点v的类型，可以去递推$f(v)$，

1. 第一种类型，$f(v) = f(u)$，
2. 第二种类型，$f(v) = f(v) + f(u)$，
3. 第三种类型，不做处理。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e5 + 5, M = 2e5 + 5, MOD = 100003;

int n, m;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M * 2];
int idx;

void add(int a, int b)
{
    E[++idx] = {b, H[a]}, H[a] = idx;
}

int dist[N];
bool st[N];
int Q[N], hh, tt;
int f[N];

void bfs()
{
    dist[1] = 0;
    st[1] = true;
    Q[tt++] = 1;
    f[1] = 1;

    while (hh != tt)
    {
        int u = Q[hh++];

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            if (!st[v])
            {
                dist[v] = dist[u] + 1;
                st[v] = true;
                Q[tt++] = v;
                f[v] = f[u];
            }
            else if (dist[u] + 1 == dist[v]) f[v] = (f[v] + f[u]) % MOD;
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        add(a, b), add(b, a);
    }

    bfs();

    for (int i = 1; i <= n; i++) cout << f[i] << '\n';

    return 0;
}
```

### 观光

题目：https://www.acwing.com/problem/content/description/385/

题解：https://www.acwing.com/solution/content/12246/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using LL = long long;
using std::cin, std::cout;

const int N = 1010, M = 1e4 + 5;

int n, m;
int S, F;

int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

int dist[N][2];
bool st[N][2];
int f[N][2];

void dijkstra()
{
    struct Node
    {
        int v, t, d;

        bool operator< (const Node &ct) const
        {
            return d >= ct.d;
        }
    };

    std::priority_queue<Node> Q;
    Q.push({S, 0, 0});
    memset(dist, 0x3f, sizeof dist);
    dist[S][0] = 0;
    memset(st, 0, sizeof st);
    memset(f, 0, sizeof f);
    f[S][0] = 1;
    
    while (!Q.empty())
    {
        auto [u, t, d] = Q.top(); Q.pop();

        if (st[u][t]) continue;
        st[u][t] = true;

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;

            if (dist[u][t] + w < dist[v][0])
            {
                dist[v][1] = dist[v][0];
                dist[v][0] = dist[u][t] + w;
                f[v][1] = f[v][0];
                f[v][0] = f[u][t];
                Q.push({v, 1, dist[v][1]});
                Q.push({v, 0, dist[v][0]});
            }
            else if (dist[u][t] + w == dist[v][0])
            {
                f[v][0] += f[u][t];
            }
            else if (dist[u][t] + w < dist[v][1])
            {
                dist[v][1] = dist[u][t] + w;
                f[v][1] = f[u][t];
                Q.push({v, 1, dist[v][1]});
            }
            else if (dist[u][t] + w == dist[v][1])
            {
                f[v][1] += f[u][t];
            }
        }
    }
}

void solve()
{
    idx = 0;
    memset(H, 0, sizeof H);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w);
    }
    cin >> S >> F;

    dijkstra();

    int res = f[F][0];
    if (dist[F][1] == dist[F][0] + 1) res += f[F][1];
    cout << res << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int t; cin >> t;
    while (t--) solve();

    return 0;
}
```

## Floyd算法

### 牛的旅行

题目：https://www.acwing.com/problem/content/1127/

先用floyd，然后用floyd的结论`dist[n][n]`去求连通块内距离每个点最远的点，记录在maxd数组中。

之后依次尝试连接两个不连通的点i和j，计算它们构成的连通块并通过这两个点的最大距离，即`maxd[i] + maxd[j] + D[i][j]`。

最终的答案有两种情况，如果任意新构成的连通块的直径没有连通之前的最大直径大，那么答案为连通之前的最大直径；如果连通后的连通块的直径更大，那么答案应该为连通后的连通块的最小直径。

```c++
#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 160;
const double INF = 1e10;

int n;
std::pair<int, int> point[N];
char G[N][N];
double dist[N][N];

double getDist(std::pair<int, int> &a, std::pair<int, int> &b)
{
    auto [x1, y1] = a; auto [x2, y2] = b;
    double dx = x1 - x2, dy = y1 - y2;
    return sqrt(dx * dx + dy * dy);
}

void floyd()
{
    for (int k = 0; k < n; k++)
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                dist[i][j] = std::min(dist[i][j], dist[i][k] + dist[k][j]);
}

double maxd[N];

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    for (int i = 0; i < n; i++)
    {
        int x, y; cin >> x >> y;
        point[i] = {x, y};
    }
    for (int i = 0; i < n; i++) cin >> G[i];

    for (int i = 0; i < n; i++)
        for (int j = 0; j < i; j++)
        {
            if (G[i][j] == '1')
                dist[i][j] = dist[j][i] = getDist(point[i], point[j]);
            else dist[i][j] = dist[j][i] = INF;
        }

    floyd();

    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            if (dist[i][j] < INF)
                maxd[i] = std::max(maxd[i], dist[i][j]);

    double res1 = *std::max_element(maxd, maxd + n);
    double res2 = INF;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < i; j++)
            if (dist[i][j] == INF)
            {
                double d = getDist(point[i], point[j]);
                res2 = std::min(res2, maxd[i] + d + maxd[j]);
            }

    printf("%.6lf\n", std::max(res1, res2));

    return 0;
}
```

### 排序

题目：https://www.acwing.com/problem/content/description/345/

**传递闭包/在线Floyd：**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 30, M = N * N;

int n, m;
bool G[N][N];
int inD[N];
int cnt, tot;

void connect(int a, int b)
{
    G[a][b] = true;
    cnt++, inD[b]++;
}

void floyd(int a, int b)
{
    connect(a, b);

    for (int i = 0; i < n; i++)
    {
        if (G[i][a] && !G[i][b]) connect(i, b);
        if (G[b][i] && !G[a][i]) connect(a, i);
    }

    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            if (!G[i][j] && G[i][a] && G[b][j])
                connect(i, j);
}

int Q[N];

void topSort()
{
    int hh = 0, tt = 0;
    for (int i = 0; i < n; i++)
        if (inD[i] == 0)
            Q[tt++] = i;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int v = 0; v < n; v++)
            if (G[u][v])
            {
                inD[v]--;
                if (inD[v] == 0) Q[tt++] = v;
            }
    }
}

void solve()
{
    cnt = 0, tot = n * (n - 1) / 2;
    memset(G, 0, sizeof G);
    memset(inD, 0, sizeof inD);

    int t = 1;
    for (; t <= m; t++)
    {
        char S[4]; cin >> S;
        int a = S[0] - 'A', b = S[2] - 'A';
        if (a != b && !G[b][a]) // 必须保证a和b不同才能连接，否则矛盾
        {
            if (!G[a][b])
            {
                floyd(a, b); // 在线floyd算法
                if (cnt == tot)
                {
                    topSort();
                    cout << "Sorted sequence determined after "
                         << t << " relations: ";
                    for (int i = 0; i < n; i++) cout << char('A' + Q[i]);
                    cout << ".\n";

                    for (t++; t <= m; t++) cin >> S;
                    return;
                }
            }
        }
        else // 矛盾
        {
            cout << "Inconsistency found after " << t << " relations."
                 << '\n';

            for (t++; t <= m; t++) cin >> S; 
            return;
        }
    }

    cout << "Sorted sequence cannot be determined." << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    while (cin >> n >> m, n || m)
        solve();

    return 0;
}
```

### 观光之旅

题目：https://www.acwing.com/problem/content/description/346/

题解：https://www.acwing.com/solution/content/144021/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 110, INF = 0x3f3f3f3f;

int n, m;
int G[N][N];

int dist[N][N], last[N][N];
int minV, path[N], cnt;

void getPath(int i, int j)
{
    int k = last[i][j];
    if (k == 0) return;

    getPath(k, j);
    path[cnt++] = k;
    getPath(i, k);
}

void floyd()
{
    memcpy(dist, G, sizeof G);
    minV = INF;

    for (int k = 1; k <= n; k++)
    {
        for (int i = 1; i < k; i++)
            for (int j = i + 1; j < k; j++)
            {
                LL len = LL(dist[i][j]) + G[i][k] + G[k][j]; // 三个INF相加会爆int
                if (len < minV)
                {
                    minV = len;
                    cnt = 0;
                    path[cnt++] = i;
                    path[cnt++] = k;
                    path[cnt++] = j;
                    getPath(i, j);
                }
            }

        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
            {
                if (dist[i][k] + dist[k][j] < dist[i][j])
                {
                    dist[i][j] = dist[i][k] + dist[k][j];
                    last[i][j] = k;
                }
            }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    memset(G, 0x3f, sizeof G);
    for (int i = 0; i < N; i++) G[i][i] = 0;

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        G[a][b] = G[b][a] = std::min(G[a][b], w);
    }

    floyd();

    if (minV < INF)
    {
        for (int i = 0; i < cnt; i++) cout << path[i] << ' ';
        cout << '\n';
    }
    else cout << "No solution." << '\n';

    return 0;
}
```

### 牛站

题目：https://www.acwing.com/problem/content/description/347/

题解：https://www.acwing.com/solution/content/36603/

本题的特色是理解res数组和G数组的初始化区别。G是不能把`G[i][i]`设置为0的，因为这样可能会在计算时导致少算边数；res数组将`res[i][i]`设置为0是因为必须保证第一次的`mul(res, res, G)`得到的res数组和G数组相同。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 210, M = 1010;

int K, m;
int n, disc[M];
int G[N][N];
int start, end;

int res[N][N];

void dp(int C[][N], int A[][N], int B[][N])
{
    static int tmp[N][N];
    memset(tmp, 0x3f, sizeof tmp);

    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                tmp[i][j] = std::min(tmp[i][j], A[i][k] + B[k][j]);

    memcpy(C, tmp, sizeof tmp);
}

void fp()
{
    memset(res, 0x3f, sizeof res);
    for (int i = 1; i <= n; i++) res[i][i] = 0;

    while (K)
    {
        if (K & 1) dp(res, res, G);
        dp(G, G, G);
        K >>= 1;
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    memset(G, 0x3f, sizeof G);

    cin >> K >> m >> start >> end;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> w >> a >> b;
        if (disc[a] == 0) disc[a] = ++n;
        if (disc[b] == 0) disc[b] = ++n;
        a = disc[a], b = disc[b];
        G[a][b] = G[b][a] = std::min(G[a][b], w);
    }
    start = disc[start], end = disc[end];

    fp();

    cout << res[start][end] << '\n';

    return 0;
}
```

## 最小生成树

### 最短网络

题目：https://www.acwing.com/problem/content/description/1142/

```c++
#include <cstring>
#include <iostream>

using namespace std;

const int N = 110;

int n;
int G[N][N];
int dist[N];
bool st[N];

int Prim()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    int res = 0;
    for (int i = 1; i <= n; i++)
    {
        int cur = -1;
        for (int j = 1; j <= n; j++)
            if (!st[j] && (cur == -1 || dist[j] < dist[cur]))
                cur = j;

        st[cur] = true;
        res += dist[cur];

        for (int j = 1; j <= n; j++)
            if (!st[j] && G[cur][j] < dist[j])
                dist[j] = G[cur][j];
    }

    return res;
}

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            scanf("%d", &G[i][j]);

    printf("%d\n", Prim());

    return 0;
}
```

### 局域网

题目：https://www.acwing.com/problem/content/description/1143/

Kruskal算法可以用于求“最小生成森林”。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110, M = 210;

int n, m;
struct Edge
{
    int a, b, w;
    bool operator< (const Edge& ct) const
    {
        return w < ct.w;
    }
} E[M];

int P[N];

int Find(int x)
{
    if (x != P[x]) P[x] = Find(P[x]);
    return P[x];
}

int Kruskal()
{
    for (int i = 1; i <= n; i++) P[i] = i;
    sort(E + 1, E + 1 + m);

    int res = 0;
    for (int i = 1; i <= m; i++)
    {
        int a = E[i].a, b = E[i].b, w = E[i].w;
        a = Find(a), b = Find(b);
        if (a != b)
        {
            P[a] = b;
            res += w;
        }
    }

    return res;
}

int main()
{
    scanf("%d%d", &n, &m);
    int tot = 0;
    for (int i = 1; i <= m; i++)
    {
        scanf("%d%d%d", &E[i].a, &E[i].b, &E[i].w);
        tot += E[i].w;
    }

    int res = tot - Kruskal();

    printf("%d\n", res);

    return 0;
}
```

### 繁忙的都市

题目：https://www.acwing.com/problem/content/description/1144/

本题是改造Kruskal算法来求最大权最小生成树。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 310, M = 8010;

int n, m;
struct Edge
{
    int a, b, w;
    bool operator< (const Edge& ct) const
    {
        return w < ct.w;
    }
} E[M];

int P[N];

int Find(int x)
{
    if (x != P[x]) P[x] = Find(P[x]);
    return P[x];
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++) 
        scanf("%d%d%d", &E[i].a, &E[i].b, &E[i].w);

    for (int i = 1; i <= n; i++) P[i] = i;
    sort(E + 1, E + 1 + m);

    int cnt = 0, res = 0;
    for (int i = 1; i <= m; i++)
    {
        int a = E[i].a, b = E[i].b, w = E[i].w;
        a = Find(a), b = Find(b);
        if (a != b)
        {
            P[a] = b;
            res = w;
            if (++cnt == n - 1) break;
        }
    }

    printf("%d %d\n", cnt, res);

    return 0;
}
```

### 联络员

题目：https://www.acwing.com/problem/content/1145/

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 2010, M = 1e4 + 10;

int n, m;
struct Edge
{
    int a, b, w;

    bool operator< (const Edge& ct) const
    {
        return w < ct.w;
    }
} E[M]; int cnt;

int P[N];

int Find(int x)
{
    if (x != P[x]) P[x] = Find(P[x]);
    return P[x];
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    int res = 0, tot = 0;
    for (int i = 1; i <= n; i++) P[i] = i;
    for (int i = 1; i <= m; i++)
    {
        int a, b, w, p; cin >> p >> a >> b >> w;
        if (p == 1)
        {
            a = Find(a), b = Find(b);
            if (a != b)
            {
                P[a] = b;
                tot++;
            }
            res += w;
        }
        else E[cnt++] = { a, b, w };
    }

    sort(E, E + cnt);

    for (int i = 0; i < cnt; i++)
    {
        int a = E[i].a, b = E[i].b, w = E[i].w;
        a = Find(a), b = Find(b);
        if (a != b)
        {
            P[a] = b;
            res += w;
            if (++tot == n - 1) break; 
        }
    }

    cout << res << endl;

    return 0;
}
```

### 连接格点

题目：https://www.acwing.com/problem/content/description/1146/

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010, M = 1e6 + 10;

int n, m, tot;
int P[M];

int Find(int x)
{
    if (x != P[x]) P[x] = Find(P[x]);
    return P[x];
}

int GetId(int x, int y)
{
    return (x - 1) * m + y;
}

struct Edge
{
    int a, b, w;

    bool operator< (const Edge& ct) const
    {
        return w < ct.w;
    }
} E[2 * M]; int cnt;

void Build() // 先纵向再横向建图就不用排序了
{
    for (int j = 1; j <= m; j++)
    {
        int idx = j;
        for (int i = 2; i <= n; i++)
        {
            if (Find(idx) != Find(idx + m))
                E[cnt++] = {idx, idx + m, 1};
            idx += m;
        }
    }

    int idx = 1;
    for (int i = 1; i <= n; i++)
    {
        for (int j = 2; j <= m; j++)
        {
            if (Find(idx) != Find(idx + 1))
                E[cnt++] = {idx, idx + 1, 2};
            idx++;
        }
        idx++;
    }
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    tot = n * m;
    for (int i = 1; i <= tot; i++) P[i] = i;
    int x1, y1, x2, y2;
    int times = 0;
    while (cin >> x1 >> y1 >> x2 >> y2)
    {
        int a = GetId(x1, y1), b = GetId(x2, y2);
        a = Find(a), b = Find(b);
        if (a != b)
        {
            P[a] = b;
            times++;
        }
    }

    Build();

    // sort(E, E + cnt);

    int res = 0;
    for (int i = 0; i < cnt; i++)
    {
        int a = E[i].a, b = E[i].b, w = E[i].w;
        a = Find(a), b = Find(b);
        if (a != b)
        {
            P[a] = b;
            res += w;
            if (++times == tot - 1) break;
        }
    }
    
    cout << res << endl;

    return 0;
}
```

## 最小生成树的扩展应用

### 新的开始

题目：https://www.acwing.com/problem/content/description/1148/

本题的核心思想是，设置一个虚拟源点，该点到其他各个点的距离为建站的代价。

```c++
#include <cstring>
#include <iostream>

using namespace std;

const int N = 310, INF = 0x3f3f3f3f;

int n;
int G[N][N];

int dist[N];
bool st[N];
int Prim()
{
    memset(dist, 0x3f, sizeof dist);
    dist[0] = 0;    

    int res = 0;
    for (int i = 0 ; i <= n; i++)
    {
        int cur = -1;
        for (int j = 0; j <= n; j++)
            if (!st[j] && (cur == -1 || dist[j] < dist[cur]))
                cur = j;

        st[cur] = true;
        res += dist[cur];

        for (int j = 0; j <= n; j++)
            if (!st[j] && G[cur][j] < dist[j])
                dist[j] = G[cur][j];
    }

    return res;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        int v; cin >> v;
        G[0][i] = G[i][0] = v;
    }
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            cin >> G[i][j];

    cout << Prim() << endl;

    return 0;
}
```

### 北极通讯网络

题目：https://www.acwing.com/problem/content/description/1147/

很直观的思路，每次都选最小边，直到连通块数量小于等于K。

```c++
#include <cmath>
#include <iostream>
#include <iomanip>
#include <algorithm>

using namespace std;

const int N = 510, M = N * N / 2;

int n, m, K;
struct Point
{
    int x, y;
} pt[N];

struct Edge
{
    int a, b;
    double w;

    bool operator< (const Edge& ct) const
    {
        return w < ct.w;
    }
} E[M];

inline double GetDist(Point& a, Point& b)
{
    int dx = a.x - b.x, dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
}

int P[N];

int Find(int x)
{
    if (x != P[x]) P[x] = Find(P[x]);
    return P[x];
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> K;
    for (int i = 1; i <= n; i++) cin >> pt[i].x >> pt[i].y;

    for (int i = 1; i <= n; i++)
        for (int j = i + 1; j <= n; j++)
            E[++m] = {i, j, GetDist(pt[i], pt[j])};

    int cnt = n;
    double res = 0;
    sort(E + 1, E + 1 + m);
    for (int i = 1; i <= n; i++) P[i] = i;
    for (int i = 1; i <= m; i++)
    {
        if (cnt <= K) break; 

        int a = E[i].a, b = E[i].b;
        double w = E[i].w;
        a = Find(a), b = Find(b);
        if (a != b)
        {
            P[a] = b;
            cnt--;
            res = w;
        }
    }

    cout << setprecision(2) << fixed << res << endl;

    return 0;
}
```

### 走廊泼水节

题目：https://www.acwing.com/problem/content/description/348/

dijkstra每次的有效操作（即并查集的Union操作）相当于连接两个连通块，只需要在每次两个连通块被连通时，使新生成的连通块是完全子图即可。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 6010;

int n;
struct Edge
{
    int a, b, w;

    bool operator< (const Edge& ct) const
    {
        return w < ct.w;
    }
} E[N];
int P[N], cnt[N];

int Find(int x)
{
    if (x != P[x]) P[x] = Find(P[x]);
    return P[x];
}

int main()
{
    int T; cin >> T;

    while (T--)
    {
        cin >> n;
        for (int i = 0; i < n - 1; i++)
            cin >> E[i].a >> E[i].b >> E[i].w;

        sort(E, E + n - 1);
        for (int i = 1; i <= n; i++)
            P[i] = i, cnt[i] = 1;
    
        int res = 0;
        for (int i = 0; i < n - 1; i++)
        {
            int a = E[i].a, b = E[i].b, w = E[i].w;
            a = Find(a), b = Find(b);
            if (a != b)
            {
                res += (cnt[a] * cnt[b] - 1) * (w + 1);
                P[a] = b;
                cnt[b] += cnt[a];
            }
        }

        cout << res << endl;
    }

    return 0;
}
```

### 秘密的牛奶运输

题目：https://www.acwing.com/problem/content/description/1150/

题解：https://www.acwing.com/solution/content/93261/

```c++
#include <climits>
#include <iostream>
#include <algorithm>
#include <numeric>

using namespace std;
using LL = long long;

const int N = 510, M = 1e4 + 10;

int n, m;
struct Edge
{
    int a, b, w;
    bool f;

    bool operator< (const Edge& ct) const
    {
        return w < ct.w;
    }
} E[M];
int P[N];

int Find(int x)
{
    if (x != P[x]) P[x] = Find(P[x]);
    return P[x];
}

int H[N];
struct ListNode
{
    int v, w, n;
} L[N * 2]; int idx = 1;

void Add(int a, int b, int w)
{
    L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

int dist1[N][N], dist2[N][N];

void dfs(int u, int fa, int mx1, int mx2, int d1[], int d2[])
{
    d1[u] = mx1, d2[u] = mx2;

    for (int p = H[u]; p; p = L[p].n)
    {
        int v = L[p].v, w = L[p].w;
        if (v != fa)
        {
            int t1 = mx1, t2 = mx2;
            if (w > t1) t2 = t1, t1 = w;
            else if (w < t1 && w > t2) t2 = w;
            dfs(v, u, t1, t2, d1, d2);
        }
    }
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
        cin >> E[i].a >> E[i].b >> E[i].w;

    sort(E, E + m);
    for (int i = 1; i <= n; i++) P[i] = i;
    LL sum = 0;
    int cnt = 0;
    for (int i = 0; i < m; i++)
    {
        int a = E[i].a, b = E[i].b, w = E[i].w;
        int pa = Find(a), pb = Find(b);
        if (pa != pb)
        {
            Add(a, b, w), Add(b, a, w);
            P[pa] = pb;
            sum += w;
            E[i].f = true;
            if (++cnt == n - 1) break;
        }
    }
    
    for (int i = 1; i <= n; i++)
        dfs(i, -1, INT_MIN, INT_MIN, dist1[i], dist2[i]);

    LL res = LONG_LONG_MAX;
    for (int i = 0; i < m; i++)
        if (!E[i].f)
        {
            int a = E[i].a, b = E[i].b, w = E[i].w;
            if (w > dist1[a][b]) res = min(res, sum + w - dist1[a][b]);
            else res = min(res, sum + w - dist2[a][b]);
        }

    cout << res << endl;

    return 0;
}
```

## 负环

### 虫洞

题目：https://www.acwing.com/problem/content/description/906/

入队次数大于等于n说明有负环；路径长度大于等于n也说明有负环，并且判断效率更高。

```c++
#include <cstring>
#include <iostream>
#include <queue>

using namespace std;

const int N = 510, M = 5210;

int n, m1, m2;
int H[N];
struct ListNode
{
    int v, w, n;
} L[M]; int idx = 1;

void Add(int a, int b, int w)
{
    L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

bool st[N];
int dist[N], cnt[N];

bool Spfa()
{
    memset(st, false, sizeof st);
    memset(dist, 0, sizeof dist);
    memset(cnt, 0, sizeof cnt);

    queue<int> Q;
    for (int i = 1; i <= n; i++)
    {
        Q.push(i);
        st[i] = true;
    }

    while (!Q.empty())
    {
        int u = Q.front(); Q.pop();
        st[u] = true;

        for (int p = H[u]; p; p = L[p].n)
        {
            int v = L[p].v, w = L[p].w;
            st[v] = false;
            if (dist[u] + w < dist[v])
            {
                dist[v] = dist[u] + w;
                cnt[v] = cnt[u] + 1;
                if (cnt[v] >= n) return true;
                if (!st[v])
                {
                    Q.push(v);
                    st[v] = true;
                }
            }
        }
    }

    return false;
}

int main()
{
    int T; cin >> T;

    while (T--)
    {
        cin >> n >> m1 >> m2;
        memset(H, 0, sizeof H);
        idx = 1;
        for (int i = 1; i <= m1; i++)
        {
            int a, b, w; cin >> a >> b >> w;
            Add(a, b, w), Add(b, a, w);
        }
        for (int i = 1; i <= m2; i++)
        {
            int a, b, w; cin >> a >> b >> w;
            Add(a, b, -w);
        }

        if (Spfa()) puts("YES");
        else puts("NO");
    }

    return 0;
}
```

### 观光奶牛

题目：https://www.acwing.com/problem/content/description/363/

题解：https://www.acwing.com/solution/content/37185/

```c++
#include <cstring>
#include <iostream>
#include <queue>

using namespace std;

const int N = 1010, M = 5010;

int n, m;
int P[N];
int H[N];
struct ListNode
{
    int v, w, n;
} L[M]; int idx = 1;

void Add(int a, int b, int w)
{
    L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

double dist[N];
int cnt[N];
bool st[N];
bool check(double mid)
{
    memset(dist, 0, sizeof dist);
    memset(cnt, 0, sizeof cnt);
    queue<int> Q;
    for (int i = 1; i <= n; i++)
    {
        Q.push(i);
        st[i] = true;
    }

    while (!Q.empty())
    {
        int u = Q.front(); Q.pop();
        st[u] = false;

        for (int p = H[u]; p; p = L[p].n)
        {
            int v = L[p].v, w = L[p].w;
            if (double len = dist[u] + P[u] - mid * w; len > dist[v])
            {
                dist[v] = len;
                cnt[v] = cnt[u] + 1;
                if (cnt[v] >= n) return true;
                if (!st[v])
                {
                    Q.push(v);
                    st[v] = true;
                }
            }
        }
    }

    return false;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> P[i];
    for (int i = 1; i <= m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        Add(a, b, w);
    }

    double l = 0, r = 1000;
    while (r - l > 1e-4)
    {
        double mid = (l + r) / 2;
        if (check(mid)) l = mid;
        else r = mid;
    }

    printf("%.2lf\n", l);

    return 0;
}
```

### 单词环

题目：https://www.acwing.com/problem/content/description/1167/

题解：https://www.acwing.com/solution/content/17712/

可以把队列换成栈，能保证不超时并且一定正确。

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 26 * 26 + 10, M = 1e5 + 10;

int n, m;
int H[N];
struct ListNode
{
    int v, w, n;
} L[M]; int idx = 1;

void Add(int a, int b, int w)
{
    L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

bool st[N];
double dist[N];
int cnt[N];
int Q[N], hh, tt;
bool Check(double mid)
{
    memset(st, 0, sizeof st);
    memset(dist, 0, sizeof dist);
    memset(cnt, 0, sizeof cnt);
    hh = tt = 0;

    for (int i = 1; i <= n; i++)
    {
        Q[tt++] = i;
        st[i] = true;
    }

    int flag = 0;
    while (hh != tt)
    {
        int u = Q[hh++];
        if (hh == N) hh = 0;
        st[u] = false;

        for (int p = H[u]; p; p = L[p].n)
        {
            int v = L[p].v, w = L[p].w;

            if (double len = dist[u] + w - mid; len > dist[v])
            {
                dist[v] = len;
                cnt[v] = cnt[u] + 1;
                if (cnt[v] >= N) return true;
                if (++flag > 4 * n) return true;
                if (!st[v])
                {
                    Q[tt++] = v;
                    if (tt == N) tt = 0;
                    st[v] = true;
                }
            }
        }
    }

    return false;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    while (cin >> m, m)
    {
        memset(H, 0, sizeof H);
        idx = 1;
        n = 0;
        for (int i = 1; i <= m; i++)
        {
            string s; cin >> s;
            int len = s.size();
            if (len >= 2)
            {
                int a = (s[0] - 'a') * 26 + s[1] - 'a' + 1;
                int b = (s[len - 2] - 'a') * 26 + s[len - 1] - 'a' + 1;
                n = max({n, a, b});
                Add(a, b, len);
            }
        }

        if (!Check(0)) cout << "No solution" << '\n';
        else
        {
            double l = 0, r = 1000;
            while (r - l > 1e-4)
            {
                double mid = (l + r) / 2;
                if (Check(mid)) l = mid;
                else r = mid;
            }

            cout << r << '\n';
        }
    }

    return 0;
}
```

## 差分约束

### 糖果

题目：https://www.acwing.com/problem/content/description/1171/

题解：https://www.acwing.com/solution/content/37324/

```c++
#include <cstring>
#include <iostream>

using namespace std;
using LL = long long;

const int N = 1e5 + 10, M = 3e5 + 10; // 还需要考虑虚拟源点的边

int n, m;
int H[N];
struct ListNode
{
    int v, w, n;
} L[M]; int idx;

void Add(int a, int b, int w)
{
    L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

bool st[N];
LL dist[N];
int cnt[N];
int stk[N], tt = 0;
bool Spfa()
{
    memset(dist, -0x3f, sizeof dist);
    dist[0] = 0;
    stk[++tt] = 0;
    st[0] = true;

    while (tt)
    {
        int u = stk[tt--];
        st[u] = false;

        for (int p = H[u]; ~p; p = L[p].n)
        {
            int v = L[p].v, w = L[p].w;
            if (int len = dist[u] + w; len > dist[v])
            {
                dist[v] = len;
                cnt[v] = cnt[u] + 1;
                if (cnt[v] >= n + 1) return true;
                if (!st[v])
                {
                    stk[++tt] = v;
                    st[v] = true;
                }
            }
        }
    }

    return false;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    memset(H, -1, sizeof H);
    for (int i = 1; i <= m; i++)
    {
        int x, a, b; cin >> x >> a >> b;
        switch (x)
        {
        case 1:
            Add(a, b, 0), Add(b, a, 0);
            break;
        case 2:
            Add(a, b, 1);
            break;
        case 3:
            Add(b, a, 0);
            break;
        case 4:
            Add(b, a, 1);
            break;
        case 5:
            Add(a, b, 0);
            break;
        }
    }
    for (int i = 1; i <= n; i++) Add(0, i, 1);
    
    if (Spfa()) cout << -1 << '\n';
    else
    {
        LL res = 0;
        for (int i = 1; i <= n; i++) res += dist[i];
        cout << res << '\n';
    }

    return 0;
}
```

### 区间

题目：https://www.acwing.com/problem/content/description/364/

题解：https://www.acwing.com/solution/content/42920/

```c++
#include <cstring>
#include <iostream>

using namespace std;

const int N = 5e4 + 10, M = 3 * N;

int n, m;
int H[N];
struct ListNode
{
    int v, w, n;
} L[M]; int idx;

void Add(int a, int b, int w)
{
    L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

bool st[N];
int dist[N];
int Q[N], hh, tt;
void Spfa()
{
    memset(dist, -0x3f, sizeof dist);
    dist[0] = 0;
    hh = tt = 0;
    Q[tt++] = 0;
    st[0] = true;

    while (hh != tt)
    {
        int u = Q[hh++];
        if (hh == N) hh = 0;
        st[u] = false;

        for (int p = H[u]; ~p; p = L[p].n)
        {
            int v = L[p].v, w = L[p].w;
            if (int len = dist[u] + w; len > dist[v])
            {
                dist[v] = len;
                if (!st[v])
                {
                    Q[tt++] = v;
                    if (tt == N) tt = 0;
                    st[v] = true;
                }
            }
        }
    }
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    n = 50001;
    cin >> m;
    memset(H, -1, sizeof H);
    for (int i = 1; i <= n; i++)
        Add(i - 1, i, 0), Add(i, i - 1, -1);
    for (int i = 1; i <= m; i++)
    {
        int a, b, c; cin >> a >> b >> c;
        a++, b++;
        Add(a - 1, b, c);
    }

    Spfa();

    cout << dist[n] << '\n';

    return 0;
}
```

### 排队布局

题目：https://www.acwing.com/problem/content/description/1172/

题解：https://www.acwing.com/solution/content/80505/

```c++
#include <cstring>
#include <iostream>

using namespace std;
using LL = long long;

const int N = 1010, M = 2e4 + N;
const LL INF = 0x3f3f3f3f3f3f3f3f;

int n, m1, m2;
int H[N];
struct ListNode
{
    int v, w, n;
} L[M]; int idx = 1;

void Add(int a, int b, int w)
{
    L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

LL dist[N];
int cnt[N];
bool st[N];
int Q[N], hh, tt;
bool Spfa(int to)
{
    memset(dist, 0x3f, sizeof dist);
    memset(cnt, 0, sizeof cnt);
    memset(st, false, sizeof st);
    hh = tt = 0;
    for (int i = 1; i <= to; i++)
    {
        dist[i] = 0;
        Q[tt++] = i;
        st[i] = true;
    }

    while (hh != tt)
    {
        int u = Q[hh++];
        if (hh == N) hh = 0;
        st[u] = false;

        for (int p = H[u]; p; p = L[p].n)
        {
            int v = L[p].v, w = L[p].w;
            if (LL len = dist[u] + w; len < dist[v])
            {
                dist[v] = len;
                cnt[v] = cnt[u] + 1;
                if (cnt[v] >= n) return true;
                if (!st[v])
                {
                    Q[tt++] = v;
                    if (tt == N) tt = 0;
                    st[v] = true;
                }
            }
        }
    }

    return false;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m1 >> m2;
    for (int i = 1; i <= m1; i++)
    {
        int a, b, c; cin >> a >> b >> c;
        if (a > b) swap(a, b);
        Add(a, b, c);
    }
    for (int i = 1; i <= m2; i++)
    {
        int a, b, c; cin >> a >> b >> c;
        if (a > b) swap(a, b);
        Add(b, a, -c);
    }
    for (int i = 1; i < n; i++) Add(i + 1, i, 0);

    if (Spfa(n)) cout << -1 << '\n';
    else
    {
        Spfa(1);
        if (dist[n] == INF) cout << -2 << '\n';
        else cout << dist[n] << endl;
    }

    return 0;
}
```

### 雇佣收银员

题目：https://www.acwing.com/problem/content/description/395/

题解：https://www.acwing.com/solution/content/63552/

```c++
#include <cstring>
#include <iostream>

using namespace std;

const int N = 25, M = 100;

int sum;
int R[N], num[N];

int H[N];
struct ListNode
{
    int v, w, n;
} L[M]; int idx;

void Add(int a, int b, int w)
{
    L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

void Build(int c)
{
    memset(H, -1, sizeof H);
    idx = 0;

    for (int i = 1; i <= 24; i++)
    {
        Add(i - 1, i, 0);
        Add(i, i - 1, -num[i]);
    }
    for (int i = 1; i <= 7; i++) 
        Add(16 + i, i, -c + R[i]);
    for (int i = 8; i <= 24; i++)
        Add(i - 8, i, R[i]);
    Add(0, 24, c), Add(24, 0, -c);
}


int dist[N], cnt[N];
bool st[N];
int Q[N], hh, tt;

bool Spfa()
{
    memset(dist, -0x3f, sizeof dist);
    memset(cnt, 0, sizeof cnt);
    memset(st, false, sizeof st);
    hh = tt = 0;

    dist[0] = 0;
    Q[tt++] = 0;
    st[0] = true;

    while (hh != tt)
    {
        int u = Q[hh++];
        if (hh == N) hh = 0;
        st[u] = false;

        for (int p = H[u]; ~p; p = L[p].n)
        {
            int v = L[p].v, w = L[p].w;

            if (int len = dist[u] + w; len > dist[v])
            {
                dist[v] = len;
                cnt[v] = cnt[u] + 1;
                if (cnt[v] >= 25) return true;
                if (!st[v])
                {
                    Q[tt++] = v;
                    if (tt == N) tt = 0;
                    st[v] = true;
                }
            }
        }
    }

    return false;
}

void Solve()
{
    for (int i = 1; i <= 24; i++) cin >> R[i];
    cin >> sum;
    memset(num, 0, sizeof num);
    for (int i = 1; i <= sum; i++)
    {
        int x; cin >> x;
        num[x + 1]++;
    }

    // for (int c = 0; c <= sum; c++)
    // {
    //     Build(c);
    //     if (!Spfa())
    //     {
    //         cout << dist[24] << '\n';
    //         return;
    //     }
    // }
    // cout << "No Solution" << '\n';

    int l = 0, r = sum + 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        Build(mid);
        if (!Spfa()) r = mid;
        else l = mid + 1;
    }
    if (l <= sum) cout << l << '\n';
    else cout << "No Solution" << '\n';
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t; cin >> t;
    while (t--)
        Solve();

    return 0;
}
```

## 最近公共祖先

### 祖孙询问

题目：https://www.acwing.com/problem/content/description/1174/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 4e4 + 10, M = N * 2;

int n, m, root;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M]; int idx;

void Add(int a, int b)
{
    E[idx].v = b, E[idx].n = H[a], H[a] = idx++;
}

int ft[N][17];
int Q[N], hh, tt;
int depth[N];

void BFS()
{
    memset(depth, 0x3f, sizeof depth);

    hh = 0, tt = -1;
    Q[++tt] = root;
    depth[root] = 1;
    depth[0] = 0;

    while (hh <= tt)
    {
        int u = Q[hh++];

        for (int p = H[u]; ~p; p = E[p].n)
        {
            int v = E[p].v;

            if (int len = depth[u] + 1; len < depth[v])
            {
                depth[v] = len;

                ft[v][0] = u;
                for (int i = 1; i <= 16; i++)
                    ft[v][i] = ft[ft[v][i - 1]][i - 1];

                Q[++tt] = v;
            }
        }
    }
}

int LCA(int a, int b)
{
    if (depth[a] < depth[b]) swap(a, b);
    for (int i = 16; i >= 0; i--)
        if (depth[ft[a][i]] >= depth[b])
            a = ft[a][i];

    if (a == b) return b;

    for (int i = 16; i >= 0; i--)
        if (ft[a][i] != ft[b][i])
        {
            a = ft[a][i];
            b = ft[b][i];
        }
    
    return ft[a][0];
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n;
    memset(H, -1, sizeof H);
    for (int i = 1; i <= n; i++)
    {
        int a, b; cin >> a >> b;
        if (b == -1) root = a;
        else Add(a, b), Add(b, a);
    }

    BFS();

    cin >> m;
    while (m--)
    {
        int a, b; cin >> a >> b;
        int c = LCA(a, b);
        if      (c == a) puts("1");
        else if (c == b) puts("2");
        else puts("0");
    }

    return 0;
}
```

### 距离

题目：https://www.acwing.com/problem/content/description/1173/

题解：https://www.acwing.com/solution/content/42924/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int N = 1e4 + 10, M = N * 2;

int n, m;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M]; int idx = 1;

void Add(int a, int b, int w)
{
    E[idx].v = b, E[idx].w = w, E[idx].n = H[a], H[a] = idx++;
}

struct Node
{
    int v, idx;
};
vector<Node> query[N];
int depth[N];

void DFS(int u, int ft)
{
    for (int p = H[u]; p; p = E[p].n)
    {
        int v = E[p].v, w = E[p].w;
        if (v == ft) continue;
        depth[v] = depth[u] + w;
        DFS(v, u);
    }
}

int res[M];
int st[N];
int P[N];

int Find(int x)
{
    if (x != P[x]) P[x] = Find(P[x]);
    return P[x];
}

void Tarjan(int u)
{
    st[u] = 1;

    for (int p = H[u]; p; p = E[p].n)
    {
        int v = E[p].v;
        if (st[v] == 0)
        {
            Tarjan(v);
            P[v] = u;
        }

    }

    for (auto q : query[u])
        if (st[q.v] == 2)
        {
            int p = Find(q.v);
            res[q.idx] = depth[u] + depth[q.v] - 2 * depth[p];
        }

    st[u] = 2;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < n - 1; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        Add(a, b, w), Add(b, a, w);
    }
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        if (a != b)
        {
            query[a].push_back({b, i});
            query[b].push_back({a, i});
        }
    }

    DFS(1, 0);

    for (int i = 1; i <= n; i++) P[i] = i;
    Tarjan(1);

    for (int i = 0; i < m; i++) cout << res[i] << '\n';

    return 0;
}
```

### 次小生成树

题目：https://www.acwing.com/problem/content/description/358/

在计算ft的时候，同时维护一个W1和W2，记录对应路径的最长边和次长边，之后根据最近公共祖先来计算应该删去的最长边。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;
using LL = long long;

const int N = 1e5 + 10, M = 3e5 + 10;

int n, m;
struct Edge
{
    int a, b, w;
    bool isMin;

    Edge() : a(0), b(0), w(0), isMin(false) {}

    bool operator< (const Edge& ct) const
    {
        return w < ct.w;
    }
} edge[M];

int H[N];
struct EdgeNode
{
    int v, w, n;
} E[N * 2]; int idx = 1;

void Add(int a, int b, int w)
{
    E[idx].v = b, E[idx].w = w, E[idx].n = H[a], H[a] = idx++;
}

int P[N];

int Find(int x)
{
    if (x != P[x]) P[x] = Find(P[x]);
    return P[x];
}

LL Kruskal()
{
    for (int i = 1; i <= n; i++) P[i] = i;

    LL res = 0;
    int cnt = 0;
    for (int i = 0; i < m; i++)
    {
        int a = edge[i].a, b = edge[i].b, w = edge[i].w;
        int pa = Find(a), pb = Find(b);
        if (pa != pb)
        {
            edge[i].isMin = true;
            P[pa] = pb;
            res += w;
            if (++cnt == n - 1) return res;
        }
    }

    return res;
}

void Build()
{
    memset(H, -1, sizeof H);
    
    for (int i = 0; i < m; i++)
        if (edge[i].isMin)
        {
            int a = edge[i].a, b = edge[i].b, w = edge[i].w;
            Add(a, b, w), Add(b, a, w);
        }
}

int depth[N];
int ft[N][17];
int W1[N][17], W2[N][17];
int Q[N], hh, tt;

void BFS()
{
    memset(depth, 0x3f, sizeof depth);
    depth[0] = 0, depth[1] = 1;

    hh = 0, tt = -1;
    Q[++tt] = 1;

    while (hh <= tt)
    {
        int u = Q[hh++];

        for (int p = H[u]; ~p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (int len = depth[u] + 1; len < depth[v])
            {
                depth[v] = len;
                ft[v][0] = u;
                W1[v][0] = w, W2[v][0] = -1;
                for (int i = 1; i <= 16; i++)
                {
                    int mid = ft[v][i - 1];
                    ft[v][i] = ft[mid][i - 1];
                    W1[v][i] = max(W1[v][i - 1], W1[mid][i - 1]);
                    W2[v][i] = -1;
                    for (int tmp : {W1[v][i - 1], W1[mid][i - 1], W2[v][i - 1], W2[mid][i - 1]})
                    {
                        if (tmp != W1[v][i])
                            W2[v][i] = max(W2[v][i], tmp);
                    }
                }
                Q[++tt] = v;
            }
        }
    }
}

int LCA(int a, int b, int w)
{
    if (a == b) return -1; // 任何生成树上都不能有环

    static int W[N * 2];
    int cnt = 0;

    if (depth[a] < depth[b]) swap(a, b);

    for (int i = 16; i >= 0; i--)
        if (depth[ft[a][i]] >= depth[b])
        {
            W[cnt++] = W1[a][i];
            W[cnt++] = W2[a][i];
            a = ft[a][i];
        }
    
    if (a != b)
    {
        for (int i = 16; i >= 0; i--)
            if (ft[a][i] != ft[b][i])
            {
                W[cnt++] = W1[a][i], W[cnt++] = W2[a][i];
                W[cnt++] = W1[b][i], W[cnt++] = W2[b][i];
                a = ft[a][i];
                b = ft[b][i];
            }
        W[cnt++] = W1[a][0];
        W[cnt++] = W1[b][0];
    }
    
    int w1 = *max_element(W, W + cnt);
    if (w == w1)
    {
        int w2 = -1;
        for (int i = 0; i < cnt; i++)
            if (w1 != W[i])
                w2 = max(w2, W[i]);
        return w2;
    }
    else return w1;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        cin >> edge[i].a >> edge[i].b >> edge[i].w;
    }
    sort(edge, edge + m);
    LL sum = Kruskal();

    Build();
    BFS();
    
    LL res = 1e11;
    for (int i = 0; i < m; i++)
        if (!edge[i].isMin)
        {
            int a = edge[i].a, b = edge[i].b, w1 = edge[i].w;

            int w2 = LCA(a, b, w1);
            if (w2 != -1) res = min(res, sum - w2 + w1);
        }

    cout << res << '\n';

    return 0;
}
```

### 闇の連鎖

题目：https://www.acwing.com/problem/content/description/354/

题解：https://www.acwing.com/solution/content/24653/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10, M = 2e5 + 10;

int n, m;
struct Edge
{
    int a, b;
} edge[M];
int H[N];
struct EdgeNode
{
    int v, n;
} E[N * 2]; int idx;

void Add(int a, int b)
{
    E[idx].v = b, E[idx].n = H[a], H[a] = idx++;
}

int depth[N];
int ft[N][17];
int Q[N], hh, tt;

void BFS()
{
    memset(depth, 0x3f, sizeof depth);
    depth[0] = 0, depth[1] = 1;
    
    hh = 0, tt = -1;
    Q[++tt] = 1;

    while (hh <= tt)
    {
        int u = Q[hh++];

        for (int p = H[u]; ~p; p = E[p].n)
        {
            int v = E[p].v;

            if (int len = depth[u] + 1; len < depth[v])
            {
                depth[v] = len;

                ft[v][0] = u;
                for (int i = 1; i <= 16; i++)
                {
                    int mid = ft[v][i - 1];
                    ft[v][i] = ft[mid][i - 1];
                }

                Q[++tt] = v;
            }
        }
    }
}

int LCA(int a, int b)
{
    if (depth[a] < depth[b]) swap(a, b);

    for (int i = 16; i >= 0; i--)
        if (depth[ft[a][i]] >= depth[b])
            a = ft[a][i];

    if (a == b) return a;

    for (int i = 16; i >= 0; i--)
        if (ft[a][i] != ft[b][i])
        {
            a = ft[a][i];
            b = ft[b][i];
        }

    return ft[a][0];
}

int D[N]; // 树上差分
int res;

int DFS(int u, int f)
{
    int cur = 0;
    for (int p = H[u]; ~p; p = E[p].n)
        if (int v = E[p].v; v != f)
        {
            int pre = DFS(v, u);
            if      (pre == 0) res += m;
            else if (pre == 1) res += 1;
            cur += pre;
        }

    return cur + D[u];
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    memset(H, -1, sizeof H);
    for (int i = 0; i < n - 1; i++)
    {
        int a, b; cin >> a >> b; 
        Add(a, b), Add(b, a);
    }
    for (int i = 0; i < m; i++)
    {
        cin >> edge[i].a >> edge[i].b;
    }

    BFS();

    for (int i = 0; i < m; i++)
    {
        int a = edge[i].a, b = edge[i].b;
        int p = LCA(a, b);

        D[a] += 1, D[b] += 1, D[p] -= 2;
    }

    DFS(1, -1);

    cout << res << '\n';

    return 0;
}
```

## 有向图的强连通分量

### 受欢迎的牛

题目：https://www.acwing.com/problem/content/description/1176/

题解：https://www.acwing.com/solution/content/20678/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <functional>

using namespace std;

const int N = 1e4 + 10, M = 5e4 + 10;

int n, m;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M]; int idx;

void InitG()
{
    memset(H, -1, sizeof H);
}

void Add(int a, int b)
{
    E[idx].v = b, E[idx].n = H[a], H[a] = idx++;
}

int SSCCnt, SSCSize[N];
int SSC[N];
int low[N], dfn[N], timeStamp;
int stk[N], top;
bool inStk[N];

void Tarjan()
{
    function<void(int)> DFS = [&](int u)
    {
        dfn[u] = low[u] = ++timeStamp;
        stk[++top] = u, inStk[u] = true;

        for (int p = H[u]; p != -1; p = E[p].n)
        {
            int v = E[p].v;

            if (!dfn[v])
            {
                DFS(v);
                low[u] = min(low[u], low[v]);
            }
            else if (inStk[v])
            {
                low[u] = min(low[u], low[v]);
            }
        }

        if (low[u] == dfn[u])
        {
            int v;
            SSCCnt++;
            do
            {
                v = stk[top--], inStk[v] = false;
                SSCSize[SSCCnt]++;
                SSC[v] = SSCCnt;
            } while (v != u);
        }
    };

    for (int i = 1; i <= n; i++)
        if (!dfn[i])
            DFS(i);
}

int dout[N];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    InitG();
    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        Add(a, b);
    }

    Tarjan();

    for (int u = 1; u <= n; u++)
        for (int p = H[u], a = SSC[u]; ~p; p = E[p].n)
        {
            int v = E[p].v;
            int b = SSC[v];
            if (a != b)
            {
                dout[a]++;
            }
        }

    int res = 0;
    int zeroCnt = 0;
    for (int i = 1; i <= SSCCnt; i++)
        if (dout[i] == 0)
        {
            if (++zeroCnt > 1)
            {
                res = 0;
                break;
            }
            res += SSCSize[i];
        }

    cout << res << '\n';

    return 0;
}
```

### 学校网络

题目：https://www.acwing.com/problem/content/description/369/

题解：https://www.acwing.com/solution/content/4663/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <functional>

using namespace std;

const int N = 110;

int n;
int H[N];
struct EdgeNode
{
    int v, n;
} E[N * N]; int idx;

void InitG()
{
    idx = 1;
}

void Add(int a, int b)
{
    E[idx].v = b, E[idx].n = H[a], H[a] = idx++;
}

int SSC[N], SSCCnt;
int low[N], dfn[N], timeStamp;
int stk[N], top;
bool inStk[N];

void Tarjan()
{
    function<void(int)> DFS = [&](int u)
    {
        low[u] = dfn[u] = ++timeStamp;
        stk[++top] = u, inStk[u] = true;

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            if (!dfn[v])
            {
                DFS(v);
                low[u] = min(low[u], low[v]);
            }
            else if (inStk[v]) low[u] = min(low[u], low[v]);
        }

        if (low[u] == dfn[u])
        {
            ++SSCCnt;
            int v;
            do
            {
                v = stk[top--];
                inStk[v] = false;
                SSC[v] = SSCCnt;
            } while (v != u);
        }
    };

    for (int i = 1; i <= n; i++)
        if (!dfn[i])
            DFS(i);
}

int din[N], dout[N];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    InitG();

    cin >> n;
    for (int a = 1, b = 0; a <= n; a++)
    {
        while (cin >> b, b) Add(a, b);
    }

    Tarjan();

    for (int u = 1; u <= n; u++)
        for (int p = H[u], a = SSC[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            int b = SSC[v];
            if (a != b)
            {
                dout[a]++;
                din[b]++;
            }
        }

    int p = 0, q = 0;
    for (int i = 1; i <= SSCCnt; i++)
    {
        if (din[i] == 0) p++;
        if (dout[i] == 0) q++;
    }

    cout << p << '\n';
    cout << (SSCCnt > 1 ? max(p, q) : 0) << '\n';

    return 0;
}
```

### 最大半连通子图

题目：https://www.acwing.com/problem/content/description/1177/

题解：https://www.acwing.com/solution/content/24796/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <functional>
#include <unordered_set>

using namespace std;
using LL = long long;

const int N = 1e5 + 10, M = 2e6 + 10;

int n, m, MOD;
int H1[N], H2[N];
struct EdgeNode
{
    int v, n;
} E[M]; int idx;

void InitG()
{
    idx = 1;
}

void Add(int H[], int a, int b)
{
    E[idx].v = b, E[idx].n = H[a], H[a] = idx++;
}

int SSCCnt, SSC[N], SSCSize[N];
int low[N], dfn[N], timeStamp;
int stk[N], top;
bool inStk[N];

void Tarjan()
{
    function<void(int)> DFS = [&](int u)
    {
        low[u] = dfn[u] = ++timeStamp;
        stk[++top] = u, inStk[u] = true;

        for (int p = H1[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            if (dfn[v] == 0)
            {
                DFS(v);
                low[u] = min(low[u], low[v]);
            }
            else if (inStk[v])
                low[u] = min(low[u], low[v]);
        }

        if (low[u] == dfn[u])
        {
            int v;
            ++SSCCnt;
            do
            {
                v = stk[top--];
                inStk[v] = false;
                SSC[v] = SSCCnt;
                SSCSize[SSCCnt]++;
            } while (v != u);
        }
    };

    for (int i = 1; i <= n; i++)
        if (!dfn[i])
            DFS(i);
}

int f[N], g[N];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    InitG();

    cin >> n >> m >> MOD;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        Add(H1, a, b);
    }

    Tarjan();

    unordered_set<LL> set;
    for (int u = 1; u <= n; u++)
        for (int p = H1[u], a = SSC[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            int b = SSC[v];
            if (a != b)
            {
                LL code = (LL(a) << 20) + b;
                if (!set.count(code))
                {
                    Add(H2, a, b);
                    set.insert(code);
                }
            }
        }

    for (int u = SSCCnt; u >= 1; u--)
    {
        if (f[u] == 0)
        {
            f[u] = SSCSize[u];
            g[u] = 1;
        }

        for (int p = H2[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            if (int tot = f[u] + SSCSize[v]; tot > f[v])
            {
                f[v] = tot;
                g[v] = g[u];
            }
            else if (tot == f[v])
                g[v] = (g[v] + g[u]) % MOD;
        }
    }
    
    int mx = 0, cnt = 0;
    for (int i = 1; i <= SSCCnt; i++)
    {
        if (f[i] > mx)
        {
            mx = f[i];
            cnt = g[i];
        }
        else if (f[i] == mx)
            cnt = (cnt + g[i]) % MOD;
    }

    cout << mx << '\n' << cnt << '\n';

    return 0;
}
```

### 银河

题目：https://www.acwing.com/problem/content/description/370/

题解：https://www.acwing.com/solution/content/24811/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <functional>
#include <queue>

using namespace std;
using LL = long long;

const int N = 1e5 + 10, M = 6e5 + 10;

int n, m;
int H1[N], H2[N];
struct EdgeNode
{
    int v, w, n;
} E[M]; int idx;

void InitG()
{
    memset(H1, -1, sizeof H1);
    memset(H2, -1, sizeof H2);
}

void Add(int H[], int a, int b, int w)
{
    E[idx] = {b, w, H[a]}, H[a] = idx++;
}

int SSCCnt, SSC[N], SSCSize[N];
int low[N], dfn[N], timeStamp;
int stk[N], top;
bool inStk[N];

void Tarjan()
{
    function<void(int)> DFS = [&](int u)
    {
        low[u] = dfn[u] = ++timeStamp;
        stk[++top] = u, inStk[u] = true;

        for (int p = H1[u]; ~p; p = E[p].n)
        {
            int v = E[p].v;
            if (dfn[v] == 0)
            {
                DFS(v);
                low[u] = min(low[u], low[v]);
            }
            else if (inStk[v])
                low[u] = min(low[u], low[v]);
        }
        
        if (low[u] == dfn[u])
        {
            ++SSCCnt;
            int v;
            do
            {
                v = stk[top--];
                inStk[v] = false;
                SSC[v] = SSCCnt;
                SSCSize[SSCCnt]++;
            } while (v != u);
        }
    };

    DFS(0);
}

int dist[N];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    InitG();
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        Add(H1, 0, i, 1);
    for (int i = 0; i < m; i++)
    {
        int t, a, b; cin >> t >> a >> b;
        switch (t)
        {
        case 1: 
            Add(H1, a, b, 0), Add(H1, b, a, 0);
            break;
        case 2:
            Add(H1, a, b, 1);
            break;
        case 3:
            Add(H1, b, a, 0);
            break;
        case 4:
            Add(H1, b, a, 1);
            break;
        case 5:
            Add(H1, a, b, 0);
            break;
        }
    }

    Tarjan();

    for (int u = 0; u <= n; u++)
    {
        int a = SSC[u];
        for (int p = H1[u]; ~p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            int b = SSC[v];
            if (a != b)
                Add(H2, a, b, w);
            else if (w == 1)
            {
                cout << -1 << '\n';
                return 0;
            }
        }
    }

    for (int u = SSCCnt; u >= 1; u--)
        for (int p = H2[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            dist[v] = max(dist[v], dist[u] + w);
        }

    LL res = 0;
    for (int i = 1; i <= SSCCnt; i++)
        res += (LL) dist[i] * SSCSize[i];
    cout << res << '\n';    

    return 0;
}
```

## 无向图的双连通分量

### 冗余路径

题目：https://www.acwing.com/problem/content/description/397/

题解：算法竞赛（下册）249/P619，必须要注意的是，如果要处理重边的情况，那么DFS中传输的参数必须是父节点到子节点的边，并且idx必须从0开始计数。无重边的情况可以考虑使用父节点编号。

**不标记桥，因为两个双连通分量之间是桥：**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <functional>

using namespace std;

const int N = 5010, M = 2e4 + 10;

int n, m;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M]; int idx;

void InitG()
{
    memset(H, -1, sizeof H);
}

void Add(int a, int b)
{
    E[idx] = {b, H[a]}, H[a] = idx++;
}

int DCCCnt, DCC[N];
int low[N], dfn[N], timeStamp;
int stk[N], top;

void Tarjan()
{
    function<void(int, int)> DFS = [&](int u, int e)
    {
        low[u] = dfn[u] = ++timeStamp;
        stk[++top] = u;

        for (int p = H[u]; ~p; p = E[p].n)
        {
            if (p == (e ^ 1)) continue;
            int v = E[p].v;
            if (!dfn[v]) DFS(v, p);
            low[u] = min(low[u], low[v]);
        }

        if (low[u] == dfn[u])
        {
            int v;
            ++DCCCnt;
            do
            {
                v = stk[top--];
                DCC[v] = DCCCnt;
            } while (v != u);
        }
    };

    DFS(1, -1);
}

int D[N];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    InitG();

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        Add(a, b), Add(b, a);
    }

    Tarjan();

    for (int u = 1; u <= n; u++)
    {
        int a = DCC[u];
        for (int p = H[u]; ~p; p = E[p].n)
        {
            int v = E[p].v;
            int b = DCC[v];
            if (a != b) D[a]++;
        }
    }

    int cnt = 0;
    for (int i = 1; i <= DCCCnt; i++)
        if (D[i] == 1)
            cnt++;
    
    cout << (cnt + 1) / 2 << '\n';

    return 0;
}
```

**标记桥：**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <functional>

using namespace std;

const int N = 5010, M = 2e4 + 10;

int n, m;
int H[N];
struct EdgeNode
{
    int v, n;
    bool isBridge;
} E[M]; int idx;

void InitG()
{
    memset(H, -1, sizeof H);
}

void Add(int a, int b)
{
    E[idx] = {b, H[a], false}, H[a] = idx++;
}

int DCCCnt, DCC[N];
int low[N], dfn[N], timeStamp;
int stk[N], top;

void Tarjan()
{
    function<void(int, int)> DFS = [&](int u, int e)
    {
        low[u] = dfn[u] = ++timeStamp;
        stk[++top] = u;

        for (int p = H[u]; ~p; p = E[p].n)
        {
            if (p == (e ^ 1)) continue;
            int v = E[p].v;
            if (!dfn[v]) DFS(v, p);
            low[u] = min(low[u], low[v]);
            if (low[v] > dfn[u]) 
                E[p ^ 1].isBridge = E[p].isBridge = true;
        }

        if (low[u] == dfn[u])
        {
            int v;
            ++DCCCnt;
            do
            {
                v = stk[top--];
                DCC[v] = DCCCnt;
            } while (v != u);
        }
    };

    DFS(1, -1);
}

int D[N];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    InitG();

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        Add(a, b), Add(b, a);
    }

    Tarjan();

    for (int p = 0; p < idx; p++)
        if (E[p].isBridge)
        {
            int v = E[p].v;
            D[DCC[v]]++;
        }

    int cnt = 0;
    for (int i = 1; i <= DCCCnt; i++)
        if (D[i] == 1)
            cnt++;
    
    cout << (cnt + 1) / 2 << '\n';

    return 0;
}
```

### 电力

题目：https://www.acwing.com/problem/content/1185/

题解：https://www.acwing.com/solution/content/20702/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <functional>

using namespace std;

const int N = 1e4 + 10, M = 3e4 + 10;

int n, m;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M]; int idx;

void InitG()
{
    idx = 0;
    memset(H, -1, sizeof H);
}

void Add(int a, int b)
{
    E[idx] = {b, H[a]}, H[a] = idx++;
}

int mx, cnt;
int dfn[N], low[N], timeStamp;

void Tarjan()
{
    memset(dfn, 0, sizeof dfn);
    memset(low, 0, sizeof low);
    timeStamp = mx = cnt = 0;
    int root = 0;

    function<void(int)> DFS = [&](int u)
    {
        dfn[u] = low[u] = ++timeStamp;

        int com = 0;
        for (int p = H[u]; ~p; p = E[p].n)
        {
            int v = E[p].v;
            if (!dfn[v])
            {
                DFS(v);
                low[u] = min(low[u], low[v]);
                if (low[v] >= dfn[u]) com++;
            }
            else low[u] = min(low[u], dfn[v]);
        }

        if (u != root) com++;

        mx = max(mx, com);
    };

    for (root = 0; root < n; root++)
        if (!dfn[root])
        {
            cnt++;
            DFS(root);
        }
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    while (cin >> n >> m, n || m)
    {
        InitG();
        
        for (int i = 0; i < m; i++)
        {
            int a, b; cin >> a >> b;
            Add(a, b), Add(b, a);
        }

        Tarjan();

        cout << mx + cnt - 1 << '\n';
    }

    return 0;
}
```

### 矿场搭建

题目：https://www.acwing.com/problem/content/description/398/

题解：https://www.acwing.com/solution/content/152028/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
#include <functional>

using namespace std;
using ULL = unsigned long long;

const int N = 1010, M = 1010;

int T;
int n, m;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M]; int idx;

void InitG()
{
    idx = 1;
    memset(H, 0, sizeof H);
}

void Add(int a, int b)
{
    E[idx] = {b, H[a]}, H[a] = idx++;
}

int singleCnt;
int dfn[N], low[N], timeStamp;
int stk[N], top;
bool isCV[N];
int VDCCCnt;
vector<int> VDCC[N];

void Tarjan()
{
    singleCnt = 0;
    timeStamp = 0;
    memset(dfn, 0, sizeof dfn);
    memset(low, 0, sizeof low);
    memset(isCV, 0, sizeof isCV);

    top = 0;

    for (int i = 1; i <= VDCCCnt; i++) 
        VDCC[i].clear();
    VDCCCnt = 0;
    
    int root = 0;

    function<void(int)> DFS = [&](int u)
    {
        if (u == root && H[u] == 0)
        {
            singleCnt++;
            return;
        }

        dfn[u] = low[u] = ++timeStamp;
        stk[++top] = u;

        int cnt = 0;
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            if (!dfn[v])
            {
                DFS(v);
                low[u] = min(low[u], low[v]);
                if (low[v] >= dfn[u])
                {
                    cnt++;
                    if (u != root || cnt > 1) isCV[u] = true;
                    ++VDCCCnt;
                    int w;
                    do
                    {
                        w = stk[top--];
                        VDCC[VDCCCnt].push_back(w);
                    } while (w != v);
                    VDCC[VDCCCnt].push_back(u);
                }
            }
            else low[u] = min(low[u], dfn[v]);
        }
    };

    for (root = 1; root <= n; root++)
        if (!dfn[root])
            DFS(root);
}

void Solve()
{
    InitG();
    n = 0;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        Add(a, b), Add(b, a);
        n = max({n, a, b});
    }

    Tarjan();

    int cnt = singleCnt;
    ULL tot = 1;
    for (int i = 1; i <= VDCCCnt; i++)
    {
        int CVCnt = 0;
        for (int e : VDCC[i])
            if (isCV[e])
                CVCnt++;

        switch (CVCnt)
        {
        case 0:
            cnt += 2;
            tot *= VDCC[i].size() * (VDCC[i].size() - 1) / 2;
            break;
        case 1:
            cnt += 1;
            tot *= VDCC[i].size() - 1;
            break;
        }
    }

    printf("Case %d: %d %llu\n", T, cnt, tot);
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    while (cin >> m, m)
    {
        T++;
        Solve();
    }

    return 0;
}
```

## 二分图

### 关押罪犯

题目：https://www.acwing.com/problem/content/description/259/

题解：https://www.acwing.com/solution/content/3042/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 2e4 + 10, M = 2e5 + 10;

int n, m;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M]; int idx;

void InitG()
{
    idx = 1;
}

void Add(int a, int b, int w)
{
    E[idx] = {b, w, H[a]}, H[a] = idx++;
}

int color[N];
int Q[N], hh, tt;

bool BFS(int start, int mid)
{
    hh = 0, tt = -1;
    Q[++tt] = start;
    color[start] = 1;

    while (hh <= tt)
    {
        int u = Q[hh++];
        int c = color[u];

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (w > mid)
            {
                if (color[v])
                {
                    if (color[v] == c) return false;
                }
                else
                {
                    color[v] = -c;
                    Q[++tt] = v;
                }
            }
        }
    }

    return true;
}

bool check(int mid)
{
    memset(color, 0, sizeof color);

    for (int i = 1; i <= n; i++)
        if (!color[i])
            if (!BFS(i, mid))
                return false;
    return true;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    InitG();

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        Add(a, b, w), Add(b, a, w);
    }

    int l = 0, r = 1e9;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }

    cout << l << '\n';

    return 0;
}
```

### 棋盘覆盖

题目：https://www.acwing.com/problem/content/description/374/

题解：https://www.acwing.com/solution/content/25013/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

int n, m;
bool G[N][N], st[N][N];
struct Point
{
    int x, y;
} match[N][N];

int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

bool Find(Point u)
{
    for (int i = 0; i < 4; i++)
    {
        int x = u.x + dx[i], y = u.y + dy[i];
        if (x < 1 || x > n || y < 1 || y > n) continue;
        if (st[x][y] || G[x][y]) continue;
        
        st[x][y] = true;
        if (match[x][y].x == 0 || Find(match[x][y]))
        {
            match[x][y] = u;
            return true;
        }
    }

    return false;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        G[a][b] = true;
    }

    int res = 0;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            if ((i + j) % 2 && !G[i][j])
            {
                memset(st, 0, sizeof st);
                res += Find({i, j});
            }

    cout << res << '\n';

    return 0;
}
```

### 机器任务

题目：https://www.acwing.com/problem/content/378/

题解：https://www.acwing.com/solution/content/25058/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110, M = 1010;

int n1, n2, m;
bool G[N][N];

bool st[N];
int match[N];

bool Find(int u)
{
    for (int v = 1; v < n2; v++)
        if (G[u][v] && !st[v])
        {
            st[v] = true;
            if (match[v] == 0 || Find(match[v]))
            {
                match[v] = u;
                return true;
            }
        }

    return false;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    while (cin >> n1, n1)
    {
        memset(G, 0, sizeof G);
        memset(match, 0, sizeof match);

        cin >> n2 >> m;
        for (int i = 0; i < m; i++)
        {
            int t, a, b; cin >> t >> a >> b;
            if (a == 0 || b == 0) continue;
            G[a][b] = true;
        }

        int res = 0;
        for (int i = 1; i < n1; i++)
        {
            memset(st, 0, sizeof st);
            res += Find(i);
        }

        cout << res << '\n';
    }

    return 0;
}
```

### 骑士放置

题目：https://www.acwing.com/problem/content/description/380/

最大独立集=删除最少点和连接它们的边，使得剩下的点互不相连

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

int n, m, K;
bool G[N][N];

bool st[N][N];
struct Point
{
    int x, y;
} match[N][N];

int dx[8] = {-2, -1, 1, 2, 2, 1, -1, -2};
int dy[8] = {1, 2, 2, 1, -1, -2, -2, -1};

bool Find(Point u)
{
    for (int i = 0; i < 8; i++)
    {
        int x = u.x + dx[i], y = u.y + dy[i];
        if (x < 1 || x > n || y < 1 || y > m) continue;
        if (st[x][y] || G[x][y]) continue;

        st[x][y] = true;
        auto& v = match[x][y];
        if (v.x == 0 || Find(v))
        {
            v = u;
            return true;
        }
    }

    return false;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m >> K;
    for (int i = 0; i < K; i++)
    {
        int x, y; cin >> x >> y;
        G[x][y] = true;
    }

    int cnt = 0;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            if ((i + j) % 2 && !G[i][j])
            {
                memset(st, 0, sizeof st);
                cnt += Find({i, j});
            }

    cout << n * m - K - cnt << '\n';

    return 0;
}
```

### 捉迷藏

题目：https://www.acwing.com/problem/content/381/

题解：https://www.acwing.com/solution/content/15162/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 210;

int n, m;
bool G[N][N];

bool st[N];
int match[N];

bool Find(int u)
{
    for (int v = 1; v <= n; v++)
        if (G[u][v] && !st[v])
        {
            st[v] = true;

            if (match[v] == 0 || Find(match[v]))
            {
                match[v] = u;
                return true;
            }
        }

    return false;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int x, y; cin >> x >> y;
        G[x][y] = true;
    }

    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                G[i][j] |= G[i][k] & G[k][j];

    int cnt = 0;
    for (int i = 1; i <= n; i++)
    {
        memset(st, 0, sizeof st);
        cnt += Find(i);
    }
    
    cout << n - cnt << '\n';

    return 0;
}
```

## 欧拉回路和欧拉路径

### 铲雪车

题目：https://www.acwing.com/problem/content/description/1125/

```c++
#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
#include <algorithm>

using namespace std;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    double x, y; cin >> x >> y;
    double d = 0;
    double x1, y1, x2, y2;
    while (cin >> x1 >> y1 >> x2 >> y2)
    {
        double dx = x2 - x1, dy = y2 - y1;
        d += sqrt(dx * dx + dy * dy);
    }

    int minutes = round(d * 2 / 1000 / 20 * 60);
    printf("%d:%02d", minutes / 60, minutes % 60);

    return 0;
}
```

### 欧拉回路

题目：https://www.acwing.com/problem/content/description/1186/

题解：https://www.acwing.com/solution/content/53434/

**st剔除重复无向边：**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10, M = 4e5 + 10;

int T;
int n, m;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M]; int idx;

void InitG()
{
    memset(H, -1, sizeof H);
}

void Add(int a, int b)
{
    E[idx] = {b, H[a]}, H[a] = idx++;
}

int din[N], dout[N];

bool st[M];
int res[M / 2], cnt;

void DFS(int u)
{
    while (~H[u])
    {
        int p = H[u];
        if (st[p])
        {
            H[u] = E[p].n;
            continue;
        }

        // st[p] = true;
        if (T == 1) st[p ^ 1] = true;

        H[u] = E[p].n;

        int v = E[p].v;
        DFS(v);
        if (T == 1)
        {
            if (p % 2) p = -(p / 2 + 1);
            else p = p / 2 + 1;
        }
        else p++;
        res[++cnt] = p;
    }
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    InitG();

    cin >> T >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        Add(a, b);
        if (T == 1) Add(b, a);
        din[b]++, dout[a]++;
    }

    for (int u = 1; u <= n; u++)
        if (~H[u])
        {
            DFS(u);
            break;
        }

    if (cnt < m)
    {
        puts("NO");
        return 0;
    }
    if (T == 1)
    {
        for (int i = 1; i <= n; i++)
            if ((din[i] + dout[i]) % 2)
            {
                puts("NO");
                return 0;
            }
    }
    else
    {
        for (int i = 1; i <= n; i++)
            if (din[i] != dout[i])
            {
                puts("NO");
                return 0;
            }
    }

    puts("YES");
    for (int i = cnt; i >= 1; i--)
        printf("%d ", res[i]);
    puts("");

    return 0;
}
```

**双链表删除无向图的重复边：**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10, M = 4e5 + 10;

int T;
int n, m;
int H[N];
struct EdgeNode
{
    int u, v, p, n;
} E[M]; int idx;

void InitG()
{
    memset(H, -1, sizeof H);
}

void Add(int a, int b)
{
    E[idx] = {a, b, -1, H[a]};
    if (~H[a]) E[H[a]].p = idx;
    H[a] = idx++;
}

int din[N], dout[N];
int res[M / 2], cnt;

void DFS(int u)
{
    while (~H[u])
    {
        int p = H[u];

        H[u] = E[p].n;
        if (T == 1)
        {
            if (~H[u]) E[H[u]].p = -1;
            int h = E[p ^ 1].u, pre = E[p ^ 1].p, nxt = E[p ^ 1].n;
            if (~pre)
            {
                E[pre].n = nxt;
                if (~nxt) E[nxt].p = pre;
            }
            else H[h] = nxt;
        }

        int v = E[p].v;
        DFS(v);
        if (T == 1)
        {
            if (p % 2) p = -(p / 2 + 1);
            else p = p / 2 + 1;
        }
        else p++;
        res[++cnt] = p;
    }
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    InitG();

    cin >> T >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        Add(a, b);
        if (T == 1) Add(b, a);
        din[b]++, dout[a]++;
    }

    for (int u = 1; u <= n; u++)
        if (~H[u])
        {
            DFS(u);
            break;
        }

    if (cnt < m)
    {
        puts("NO");
        return 0;
    }
    if (T == 1)
    {
        for (int i = 1; i <= n; i++)
            if ((din[i] + dout[i]) % 2)
            {
                puts("NO");
                return 0;
            }
    }
    else
    {
        for (int i = 1; i <= n; i++)
            if (din[i] != dout[i])
            {
                puts("NO");
                return 0;
            }
    }

    puts("YES");
    for (int i = cnt; i >= 1; i--)
        printf("%d ", res[i]);
    puts("");

    return 0;
}
```

### 骑马修栅栏

题目：https://www.acwing.com/problem/content/description/1126/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 510, M = 1050;

int n = 500, m;
int G[N][N], D[N];

int res[M], cnt;

void DFS(int u)
{
    for (int v = 1; v <= n; v++)
        if (G[u][v])
        {
            G[u][v]--, G[v][u]--;
            DFS(v);
        }

    res[++cnt] = u;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        G[a][b]++, G[b][a]++;
        D[a]++, D[b]++;
    }

    // 两个循环应对欧拉路径的两种情况
    int start = 1;
    for (int i = 1; i <= n; i++)
        if (D[i] != 0)
        {
            start = i;
            break;
        }
    for (int i = start; i <= n; i++)
        if (D[i] % 2)
        {
            start = i;
            break;
        }

    DFS(start);

    for (int i = cnt; i >= 1; i--) cout << res[i] << '\n';

    return 0;
}
```

### 单词游戏

题目：https://www.acwing.com/problem/content/description/1187/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 30, M = 1e5 + 10;

int n = 26, m;
int din[N], dout[N];

int P[N];

int Find(int x)
{
    if (x != P[x]) P[x] = Find(P[x]);
    return P[x];
}

bool st[N];

void Solve()
{
    memset(din, 0, sizeof din);
    memset(dout, 0, sizeof dout);
    for (int i = 0; i < n; i++) P[i] = i;
    memset(st, 0, sizeof st);

    cin >> m;
    for (int i = 0; i < m; i++)
    {
        string str; cin >> str;
        int a = str.front() - 'a', b = str.back() - 'a';

        dout[a]++, din[b]++;
        st[a] = st[b] = true;
        P[Find(a)] = Find(b);
    }

    int root = -1;
    for (int i = 0; i < n; i++)
        if (st[i])
        {
            root = Find(i);
            break;
        }
    for (int i = 0; i < n; i++)
        if (st[i] && root != Find(i))
        {
            cout << "The door cannot be opened." << '\n';
            return;
        }

    int start = 0, end = 0;
    for (int i = 0; i < n; i++)
        if (din[i] != dout[i])
        {
            if      (din[i] == dout[i] + 1) end++;
            else if (din[i] + 1 == dout[i]) start++;
            else
            {
                cout << "The door cannot be opened." << '\n';
                return;
            }
        }
    if ((start == 1 && end == 1) || (start == 0 && end == 0))
        cout << "Ordering is possible." << '\n';
    else cout << "The door cannot be opened." << '\n';
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    
    int t; cin >> t;
    while (t--) Solve();

    return 0;
}
```

## 拓扑排序

### 家谱树

题目：https://www.acwing.com/problem/content/description/1193/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

int n;
bool G[N][N];
int D[N];

int Q[N], hh, tt;

bool TopSort()
{
    hh = 0, tt = -1;
    for (int i = 1; i <= n; i++)
        if (D[i] == 0)
            Q[++tt] = i;

    while (hh <= tt)
    {
        int u = Q[hh++];
        for (int v = 1; v <= n; v++)
            if (G[u][v])
            {
                D[v]--;
                if (D[v] == 0) Q[++tt] = v;
            }
    }

    return tt + 1 == n;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        int son;
        while (cin >> son, son)
        {
            G[i][son] = true;
            D[son]++;
        }
    }

    TopSort();

    for (int i = 0; i < n; i++) cout << Q[i] << ' ';
    cout << '\n';

    return 0;
}
```

### 奖金

题目：https://www.acwing.com/problem/content/description/1194/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e4 + 10, M = 2e4 + 10;

int n, m;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M]; int idx = 1;

void Add(int a, int b)
{
    E[idx] = {b, H[a]}, H[a] = idx++;
}

int D[N];

int Q[N], hh, tt;

bool TopSort()
{
    hh = 0, tt = -1;
    for (int i = 1; i <= n; i++)
        if (D[i] == 0)
            Q[++tt] = i;

    while (hh <= tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            if (--D[v] == 0)
                Q[++tt] = v;
        }
    }
    
    return tt + 1 == n;
}

int dist[N];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        Add(b, a);
        D[a]++;
    }

    if (TopSort())
    {
        for (int i = 1; i <= n; i++) dist[i] = 100;
        for (int i = 0; i < n; i++)
        {
            int u = Q[i];
            for (int p = H[u]; p; p = E[p].n)
            {
                int v = E[p].v;
                dist[v] = max(dist[v], dist[u] + 1);
            }
        }

        int res = 0;
        for (int i = 1; i <= n; i++) res += dist[i];
        cout << res << '\n';
    }
    else cout << "Poor Xed" << '\n';

    return 0;
}
```

### 可达性统计

题目：https://www.acwing.com/problem/content/description/166/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <bitset>

using namespace std;

const int N = 3e4 + 10, M = 3e4 + 10;

int n, m;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M]; int idx = 1;

void Add(int a, int b)
{
    E[idx] = {b, H[a]}, H[a] = idx++;
}

int D[N];
int Q[N], hh, tt;

bitset<N> f[N];

void TopSort()
{
    hh = 0, tt = -1;
    for (int i = 1; i <= n; i++)
        if (D[i] == 0)
            Q[++tt] = i;

    while (hh <= tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            if (--D[v] == 0)
                Q[++tt] = v;
        }
    }
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        Add(a, b);
        D[b]++;
    }

    TopSort();

    for (int i = tt; i >= 0; i--)
    {
        int u = Q[i];
        f[u][u] = 1;
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            f[u] = f[u] | f[v];
        }
    }

    for (int i = 1; i <= n; i++) cout << f[i].count() << '\n';

    return 0;
}
```

### 车站分级

题目：https://www.acwing.com/problem/content/description/458/

题解：https://www.acwing.com/solution/content/17458/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 2010, M = 1e6 + 10;

int n, m;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M]; int idx = 1;

void Add(int a, int b, int w)
{
    E[idx] = {b, w, H[a]}, H[a] = idx++;
}

bool st[N];
int D[N];
int Q[N], hh, tt;

void TopSort()
{
    hh = 0, tt = -1;

    for (int i = 1; i <= n + m; i++)
        if (D[i] == 0)
            Q[++tt] = i;

    while (hh <= tt)
    {
        int u = Q[hh++];

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            if (--D[v] == 0)
                Q[++tt] = v;
        }
    }
}

int dist[N];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= m; i++)
    {
        memset(st, 0, sizeof st);
        int cnt; cin >> cnt;
        int start; cin >> start;
        for (int j = 2; j < cnt; j++)
        {
            int x; cin >> x;
            st[x] = true;
        }
        int end; cin >> end;
        st[start] = st[end] = true;

        int vir = n + i;
        for (int j = start; j <= end; j++)
        {
            if (st[j])
            {
                Add(vir, j, 1);
                D[j]++;
            }
            else
            {
                Add(j, vir, 0);
                D[vir]++;
            }
        }
    }

    TopSort();

    for (int i = 1; i <= n; i++) dist[i] = 1;

    for (int i = 0; i <= tt; i++)
    {
        int u = Q[i];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            dist[v] = max(dist[v], dist[u] + w);
        }
    }

    int res = 0;
    for (int i = 1; i <= n; i++) res = max(res, dist[i]);
    cout << res << '\n';

    return 0;
}
```

