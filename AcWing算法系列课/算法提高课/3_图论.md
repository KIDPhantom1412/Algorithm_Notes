# 图论

## 单源最短路的建图方式

### 热浪

题目：https://www.acwing.com/problem/content/description/1131/

**堆优化dijkstra：**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using LL = long long;
using std::cin, std::cout;

const int N = 2510, M = 6210;

int n, m;
int start, end;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M * 2];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

bool st[N];
int dist[N];

void dijkstra()
{
    struct Node
    {
        int d, v;

        bool operator< (const Node &ct) const
        {
            return d >= ct.d;
        }
    };
    std::priority_queue<Node> Q;

    memset(dist, 0x3f, sizeof dist);
    dist[start] = 0;
    Q.push({0, start});

    while (!Q.empty())
    {
        auto [d, u] = Q.top(); Q.pop();

        if (st[u]) continue;
        st[u] = true;

        if (u == end) return;

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (d + w < dist[v])
            {
                dist[v] = d + w;
                Q.push({dist[v], v});
            }
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m >> start >> end;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w), add(b, a, w);
    }

    dijkstra();

    cout << dist[end] << '\n';

    return 0;
}
```

**spfa：**

```c++
#include <cstring>
#include <iostream>
#include <queue>

using namespace std;

const int N = 2510, M = 6210, INF = 0x3f3f3f3f;

int n, m, start, dest;
int H[N];
struct ListNode
{
    int v, w, n;
} L[M * 2]; int idx = 1;

void add(int a, int b, int w)
{
    L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

int dist[N];
bool st[N];
void spfa()
{
    memset(dist, 0x3f, sizeof dist);
    queue<int> Q;
    dist[start] = 0;
    st[start] = true;
    Q.push(start);
    
    while (!Q.empty())
    {
        int cur = Q.front(); Q.pop();
        st[cur] = false;

        for (int p = H[cur]; p; p = L[p].n)
        {
            int v = L[p].v, w = L[p].w;
            if (dist[cur] + w < dist[v])
            {
                dist[v] = dist[cur] + w;
                if (!st[v])
                {
                    st[v] = true;
                    Q.push(v);
                }
            }
        }
    }
}

int main()
{
    scanf("%d%d%d%d", &n, &m, &start, &dest);
    for (int i = 1; i <= m; i++)
    {
        int a, b, w; scanf("%d%d%d", &a, &b, &w);
        add(a, b, w), add(b, a, w);
    }

    spfa();

    printf("%d\n", dist[dest]);

    return 0;
}
```

### 信使

题目：https://www.acwing.com/problem/content/description/1130/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using LL = long long;
using std::cin, std::cout;

const int N = 110, M = 210, INF = 0x3f3f3f3f;

int n, m;
int G[N][N];

bool st[N];
int dist[N];
int res;

bool dijkstra()
{
    struct Node
    {
        int d, v;

        bool operator< (const Node &ct) const
        {
            return d >= ct.d;
        }
    };
    std::priority_queue<Node> Q;
    Q.push({0, 1});
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    int cnt = 0;
    while (!Q.empty())
    {
        auto [d, u] = Q.top(); Q.pop();

        if (st[u]) continue;
        st[u] = true;

        cnt++;
        res = std::max(res, dist[u]);

        for (int v = 1; v <= n; v++)
            if (d + G[u][v] < dist[v])
            {
                dist[v] = d + G[u][v];
                Q.push({dist[v], v});
            }
    }

    return cnt == n;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    memset(G, 0x3f, sizeof G);
    for (int i = 0; i < N; i++) G[i][i] = 0;

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        G[a][b] = G[b][a] = std::min(G[a][b], w);
    }

    if (dijkstra()) cout << res << '\n';
    else cout << -1 << '\n';
    
    return 0;
}
```

### 香甜的黄油

题目：https://www.acwing.com/problem/content/description/1129/

本题用floyd算法无法通过。

**spfa：**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using LL = long long;
using std::cin, std::cout;

const int N = 1000, M = 3000, INF = 0x3f3f3f3f;

int n, m, numCow;
int cow[N];
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

int dist[N];
bool st[N];

void spfa(int start)
{
    memset(dist, 0x3f, sizeof dist);
    memset(st, 0, sizeof st);
    std::queue<int> Q;
    Q.push(start);
    st[start] = true;
    dist[start] = 0;

    while (!Q.empty())
    {
        int u = Q.front(); Q.pop();
        st[u] = false;

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[u] + w < dist[v])
            {
                dist[v] = dist[u] + w;
                if (!st[v])
                {
                    Q.push(v);
                    st[v] = true;
                }
            }
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> numCow >> n >> m;
    for (int i = 1; i <= numCow; i++) cin >> cow[i];
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w), add(b, a, w);
    }

    int res = INF;
    for (int i = 1; i <= n; i++)
    {
        spfa(i);
        int sum = 0;
        for (int i = 1; i <= numCow; i++)
        {
            if (dist[cow[i]] == INF)
            {
                sum = INF;
                break;
            }
            sum += dist[cow[i]];
        }
        res = std::min(res, sum);
    }

    cout << res << '\n';

    return 0;
}
```

**堆优化dijkstra：**

就本题来说，dijkstra比spfa慢多了。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using LL = long long;
using std::cin, std::cout;

const int N = 1000, M = 3000, INF = 0x3f3f3f3f;

int n, m;
int cow[N], numCow;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

int dist[N];
bool st[N];

void dijkstra(int start)
{
    struct Node
    {
        int d, v;

        bool operator< (const Node &ct) const
        {
            return d >= ct.d;
        }
    };
    std::priority_queue<Node> Q;
    Q.push({0, start});
    memset(dist, 0x3f, sizeof dist);
    dist[start] = 0;
    memset(st, 0, sizeof st);

    while (!Q.empty())
    {
        auto [d, u] = Q.top(); Q.pop();

        if (st[u]) continue;
        st[u] = true;

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (d + w < dist[v])
            {
                dist[v] = d + w;
                Q.push({dist[v], v});
            }
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> numCow >> n >> m;
    for (int i = 1; i <= numCow; i++) cin >> cow[i];
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w), add(b, a, w);
    }

    int res = INF;
    for (int i = 1; i <= n; i++)
    {
        dijkstra(i);
        int sum = 0;
        for (int j = 1; j <= numCow; j++)
        {
            if (dist[cow[j]] == INF)
            {
                sum = INF;
                break;
            }
            sum += dist[cow[j]];
        }
        res = std::min(res, sum);
    }

    cout << res << '\n';

    return 0;
}
```

### 最小花费

题目：https://www.acwing.com/problem/content/description/1128/

题解：https://www.acwing.com/solution/content/94237/

**dijkstra：**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 2005;

int n, m;
int start, end;
double G[N][N];

double dist[N];
bool st[N];

void dijkstra()
{
    dist[start] = 1;

    for (int i = 0; i < n; i++)
    {
        int u = -1;
        for (int j = 1; j <= n; j++)
            if (!st[j] && (u == -1 || dist[j] > dist[u]))
                u = j;

        st[u] = true;
        if (u == end) return;

        for (int v = 1; v <= n; v++)
            dist[v] = std::max(dist[v], dist[u] * G[u][v]);
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    for (int i = 0; i < N; i++) G[i][i] = 1;

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        G[a][b] = G[b][a] = std::max(G[a][b], double(100 - w) / 100);
    }
    cin >> start >> end;

    dijkstra();

    printf("%.8lf\n", 100 / dist[end]);

    return 0;
}
```

**spfa：**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 2010;

int n, m;
int start, end;
double G[N][N];

double dist[N];
bool st[N];
int Q[N], hh, tt;

void spfa()
{
    dist[start] = 1;
    Q[tt++] = start;
    st[start] = true;

    while (hh != tt)
    {
        int u = Q[hh++]; hh %= N;
        st[u] = false;

        for (int v = 1; v <= n; v++)
            if (dist[u] * G[u][v] > dist[v])
            {
                dist[v] = dist[u] * G[u][v];
                if (!st[v])
                {
                    Q[tt++] = v; tt %= N;
                    st[v] = true;
                }
            }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    for (int i = 0; i < N; i++) G[i][i] = 1;

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        G[a][b] = G[b][a] = std::max(G[a][b], double(100 - w) / 100);
    }
    cin >> start >> end;

    spfa();

    printf("%.8lf\n", 100 / dist[end]);

    return 0;
}
```



### 最优乘车

题目：https://www.acwing.com/problem/content/description/922/

本题难在建图。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <sstream>

using LL = long long;
using std::cin, std::cout;

const int N = 510, M = 110;

int n, m;
bool G[N][N];
int stop[M];

int Q[N], hh, tt;
bool st[N];
int dist[N];

bool bfs()
{
    Q[tt++] = 1;
    st[1] = true;
    dist[1] = -1;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int v = 1; v <= n; v++)
            if (G[u][v] && !st[v])
            {
                dist[v] = dist[u] + 1;
                st[v] = true;
                if (v == n) return true;
                Q[tt++] = v;
            }
    }

    return false;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> m >> n; 
    std::string line;
    std::getline(cin, line); // 读回车
    for (int i = 0; i < m; i++)
    {
        std::getline(cin, line);
        std::stringstream ss(line);
        int p = 0, cnt = 0;
        while (ss >> p) stop[++cnt] = p;
        for (int j = 1; j <= cnt; j++)
            for (int k = j + 1; k <= cnt; k++)
                G[stop[j]][stop[k]] = true;
    }

    if (bfs()) cout << dist[n] << '\n';
    else cout << "NO" << '\n';

    return 0;
}
```

### 昂贵的聘礼

题目：https://www.acwing.com/problem/content/description/905/

思路是反向建图，0号点是虚拟原点，从0号点到其他点的边权是直接购买该物品需要的钱。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 110, INF = 0x3f3f3f3f;

int n, m;
int G[N][N];
int L[N];

int dist[N];
bool st[N];

bool dijkstra(int dn, int up)
{
    memset(dist, 0x3f, sizeof dist);
    memset(st, 0, sizeof st);
    dist[0] = 0;

    for (int i = 0; i <= n; i++)
    {
        int u = -1;
        for (int j = 0; j <= n; j++)
            if (!st[j] && (u == -1 || dist[j] < dist[u]))
                u = j;

        st[u] = true;
        if (u == 1) return true;

        for (int v = 1; v <= n; v++)
            if (L[v] >= dn && L[v] <= up)
                dist[v] = std::min(dist[v], dist[u] + G[u][v]);
    }

    return false;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    memset(G, 0x3f, sizeof G);
    for (int i = 0; i < N; i++) G[i][i] = 0;

    cin >> m >> n;
    for (int i = 1; i <= n; i++)
    {
        int p, l, x; cin >> p >> l >> x;
        G[0][i] = std::min(G[0][i], p);
        L[i] = l;
        while (x--)
        {
            int t, v; cin >> t >> v;
            G[t][i] = std::min(G[t][i], v);
        }
    }

    int res = INF;
    for (int i = L[1] - m; i <= L[1]; i++)
        if (dijkstra(i, i + m))
            res = std::min(res, dist[1]);

    cout << res << '\n';
    return 0;
}
```

## 单源最短路的综合应用

### 新年好

题目：https://www.acwing.com/problem/content/description/1137/

先将1和输入给的五个点分别做源点使用dijkstra，之后通过dfs搜索访问顺序。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using LL = long long;
using std::cin, std::cout;

const int N = 5e4 + 5, M = 1e5 + 5, INF = 0x3f3f3f3f;

int n, m;
int stop[6];
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M * 2];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

int dist[6][N];
bool st[N];

void dijkstra(int start, int dist[N])
{
    memset(st, 0, sizeof st);
    for (int i = 1; i <= n; i++) dist[i] = INF;
    dist[start] = 0;

    struct Node
    {
        int d, v;

        bool operator< (const Node &ct) const
        {
            return d >= ct.d;
        }
    };
    std::priority_queue<Node> Q;
    Q.push({0, start});

    while (!Q.empty())
    {
        auto [d, u] = Q.top(); Q.pop();

        if (st[u]) continue;
        st[u] = true;

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[u] + w < dist[v])
            {
                dist[v] = dist[u] + w;
                Q.push({dist[v], v});
            }
        }
    }
}

int res;

void dfs(int i, int last, int time)
{
    if (time >= res) return;

    if (i > 5)
    {
        res = time;
        return;
    }

    for (int j = 1; j <= 5; j++)
        if (!st[j])
        {
            st[j] = true;
            dfs(i + 1, j, time + dist[last][stop[j]]);
            st[j] = false;
        }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    stop[0] = 1;
    for (int i = 1; i <= 5; i++) cin >> stop[i];
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w), add(b, a, w);
    }

    for (int i = 0; i <= 5; i++) dijkstra(stop[i], dist[i]);

    res = INF;
    for (int i = 1; i <= 5; i++) st[i] = false;
    dfs(1, 0, 0);

    cout << res << '\n';

    return 0;
}
```

### 通信线路

题目：https://www.acwing.com/problem/content/description/342/

题解：https://www.acwing.com/solution/content/13645/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using LL = long long;
using std::cin, std::cout;

const int N = 1010, M = 1e4 + 5, INF = 0x3f3f3f3f;

int n, m, K;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M * 2];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

int dist[N];
bool st[N];

bool dijkstra(int x)
{
    std::deque<int> Q;
    Q.push_back(1);
    memset(st, 0, sizeof st);
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    while (!Q.empty())
    {
        int u = Q.front(); Q.pop_front();

        if (st[u]) continue;
        st[u] = true;

        if (u == n) break;

        for (int p = H[u]; p; p = E[p].n)    
        {
            int v = E[p].v, w = E[p].w > x;
            if (dist[u] + w < dist[v])
            {
                dist[v] = dist[u] + w;
                if (w) Q.push_back(v);
                else Q.push_front(v);
            }
        }
    }

    return dist[n] <= K;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m >> K;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w), add(b, a, w);
    }

    dijkstra(0);
    if (dist[n] == INF)
    {
        cout << -1 << '\n';
        return 0;
    }

    int l = 0, r = 1e6;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (dijkstra(mid)) r = mid;
        else l = mid + 1;
    }
    cout << l << '\n';

    return 0;
}
```

### 道路与航线

题目：https://www.acwing.com/problem/content/description/344/

题解：https://www.acwing.com/solution/content/33202/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>

using LL = long long;
using std::cin, std::cout;

const int N = 25e3 + 5, M = 5e4 + 5, INF = 0x3f3f3f3f;

int n, m1, m2;
int start;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M * 3];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

int blkCnt;
int blkId[N];
std::vector<int> blk[N];

void dfs(int u)
{
    blkId[u] = blkCnt;
    blk[blkCnt].push_back(u);

    for (int p = H[u]; p; p = E[p].n)
    {
        int v = E[p].v;
        if (blkId[v] == 0) dfs(v);
    }
}


int dist[N];
bool st[N];
int blkQ[N], hh, tt;
int blkIn[N];

void dijkstra(int id)
{
    struct Node
    {
        int d, v;

        bool operator< (const Node &ct) const
        {
            return d >= ct.d;
        }
    };
    std::priority_queue<Node> Q;

    for (int u : blk[id]) Q.push({dist[u], u});

    while (!Q.empty())
    {
        auto [d, u] = Q.top(); Q.pop();

        if (st[u]) continue;
        st[u] = true;

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (blkId[u] != blkId[v] && --blkIn[blkId[v]] == 0) 
                blkQ[tt++] = blkId[v];
            if (dist[u] + w < dist[v])
            {
                dist[v] = dist[u] + w;
                if (blkId[u] == blkId[v]) Q.push({dist[v], v});
            }
        }
    }

}

void topSort()
{
    memset(dist, 0x3f, sizeof dist);
    dist[start] = 0;

    for (int i = 1; i <= blkCnt; i++)
        if (blkIn[i] == 0)
            blkQ[tt++] = i;

    while (hh != tt)
    {
        int id = blkQ[hh++];
        dijkstra(id);
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m1 >> m2 >> start;
    for (int i = 0; i < m1; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w), add(b, a, w);
    }

    for (int i = 1; i <= n; i++)
        if (blkId[i] == 0)
        {
            blkCnt++;
            dfs(i);
        }

    for (int i = 0; i < m2; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w);
        blkIn[blkId[b]]++;
    }

    topSort();

    for (int i = 1; i <= n; i++)
    {
        if (dist[i] < INF / 2) cout << dist[i] << '\n';
        else cout << "NO PATH" << '\n';
    }

    return 0;
}
```

### 最优贸易

题目：https://www.acwing.com/problem/content/description/343/

题解：https://www.acwing.com/solution/content/3709/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e5 + 5, M = 5e5 + 5;

int n, m;
int price[N];
int H[N], HR[N];
struct EdgeNode
{
    int v, n;
} E[M * 4];
int idx;

void add(int H[], int a, int b)
{
    E[++idx] = {b, H[a]}, H[a] = idx;
}

int Q[N];
bool st[N];
int mn[N];

void spfaMin()
{
    memset(mn, 0x3f, sizeof mn);

    int hh = 0, tt = 0;
    Q[tt++] = 1;
    st[1] = true;
    mn[1] = price[1];

    while (hh != tt)
    {
        int u = Q[hh++]; hh %= N;
        st[u] = false;

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            if (std::min(mn[u], price[v]) < mn[v])
            {
                mn[v] = std::min(mn[u], price[v]);
                if (!st[v])
                {
                    Q[tt++] = v; tt %= N;
                    st[v] = true;
                }
            }
        }
    }
}

int mx[N];

void spfaMax()
{
    int hh = 0, tt = 0;
    Q[tt++] = n;
    st[n] = true;
    mx[n] = price[n];

    while (hh != tt)
    {
        int u = Q[hh++]; hh %= N;
        st[u] = false;

        for (int p = HR[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            if (std::max(mx[u], price[v]) > mx[v])  
            {
                mx[v] = std::max(mx[u], price[v]);
                if (!st[v])
                {
                    Q[tt++] = v; tt %= N;
                    st[v] = true;
                }
            }
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> price[i];
    for (int i = 0; i < m; i++)
    {
        int a, b, c; cin >> a >> b >> c;
        add(H, a, b), add(HR, b, a);
        if (c == 2) add(H, b, a), add(HR, a, b);
    }

    spfaMin();
    spfaMax();

    int res = 0;
    for (int i = 1; i <= n; i++)
        if (mx[i] - mn[i] > res)
            res = mx[i] - mn[i];

    cout << res << '\n';

    return 0;
}
```

## 单源最短路的扩展应用

### 选择最佳线路

题目：https://www.acwing.com/problem/content/description/1139/

虚拟源点法。本题可以用spfa或dijkstra。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using LL = long long;
using std::cin, std::cout;

const int N = 1010, M = 2e4 + 5;

int n, m, end;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

bool st[N];
int dist[N];

void solve()
{
    memset(H, 0, sizeof H);
    idx = 0;

    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w);
    }

    memset(dist, 0x3f, sizeof dist);
    memset(st, 0, sizeof st);

    struct Node
    {
        int d, v;

        bool operator< (const Node &ct) const
        {
            return d >= ct.d;
        }
    };
    std::priority_queue<Node> Q;
    int cnt; cin >> cnt;
    while (cnt--)
    {
        int start; cin >> start;
        Q.push({0, start});
        dist[start] = 0;        
    }

    while (!Q.empty())
    {
        auto [d, u] = Q.top(); Q.pop();

        if (st[u]) continue;
        st[u] = true;

        if (u == end) break;

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[u] + w < dist[v])
            {
                dist[v] = dist[u] + w;
                Q.push({dist[v], v});
            }
        }
    }

    if (st[end]) cout << dist[end] << '\n';
    else cout << -1 << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    while (cin >> n >> m >> end)
        solve();

    return 0;
}
```

### 拯救大兵瑞恩

题目：https://www.acwing.com/problem/content/description/1133/

题解：https://www.acwing.com/solution/content/176795/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <unordered_set>
#include <queue>

using LL = long long;
using std::cin, std::cout;

const int N = 11, M = N * N, S = 1 << 10;

int n, m, p;
int H[M];
struct EdgeNode
{
    int v, w, n;
} E[M * 4];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

int G[N][N], cnt;
std::unordered_set<int> ht;

int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

void build()
{
    for (int px = 1; px <= n; px++)
        for (int py = 1; py <= m; py++)
        {
            int a = G[px][py];
            for (int i = 0; i < 4; i++)
            {
                int x = px + dx[i], y = py + dy[i];
                if (x >= 1 && x <= n && y >= 1 && y <= m)
                {
                    int b = G[x][y];
                    if (!ht.count((a << 16) + b)) add(a, b, 0);
                }
            }
        }
}

int key[M];
int dist[M][S];
bool st[M][S];

int bfs()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1][0] = 0;

    std::deque<std::pair<int, int>> Q;
    Q.push_back({1, 0});

    while (!Q.empty())
    {
        auto [ux, uy] = Q.front(); Q.pop_front();

        if (st[ux][uy]) continue;
        st[ux][uy] = true;

        if (ux == n * m) return dist[ux][uy];

        if (key[ux])
        {
            int vy = uy | key[ux];
            if (dist[ux][uy] < dist[ux][vy])
            {
                dist[ux][vy] = dist[ux][uy];
                Q.push_front({ux, vy});
            }
        }

        for (int p = H[ux]; p; p = E[p].n)
        {
            int vx = E[p].v, w = E[p].w;
            if ((w == 0 || uy >> (w - 1) & 1) &&
                dist[ux][uy] + 1 < dist[vx][uy])
            {
                dist[vx][uy] = dist[ux][uy] + 1;
                Q.push_back({vx, uy});
            }
        }
    }

    return -1;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m >> p;

    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            G[i][j] = ++cnt;

    int t; cin >> t;
    while (t--)
    {
        int x1, y1, x2, y2, g; cin >> x1 >> y1 >> x2 >> y2 >> g;
        int a = G[x1][y1], b = G[x2][y2];
        ht.insert((a << 16) + b), ht.insert((b << 16) + a);
        if (g) add(a, b, g), add(b, a, g);
    }

    build();

    cin >> t;
    while (t--)
    {
        int x, y, q; cin >> x >> y >> q;
        key[G[x][y]] |= 1 << (q - 1);
    }

    cout << bfs() << '\n';

    return 0;
}
```

### 最短路计数

题目：https://www.acwing.com/problem/content/description/1136/

在`bfs`的队列中，被取出的节点u的后驱节点v有几种类型，

1. 第一次访问的节点，即我们找到了第一条最短路；
2. 已经被访问过的节点，并且从u到v是某条最短路上的节点；
3. 已经被访问过的节点，但从u到v并不是任何一条最短路上的节点。

本题基于动态规划的思想，利用`bfs`队列的规律，我们可以知道，当队头节点u被取出时，任何一条最短路上的节点u的前驱节点已经被取出，因此到u节点的最短路条数可以被正确的计算得出，记作$f(u)$。根据节点u的后驱节点v的类型，可以去递推$f(v)$，

1. 第一种类型，$f(v) = f(u)$，
2. 第二种类型，$f(v) = f(v) + f(u)$，
3. 第三种类型，不做处理。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e5 + 5, M = 2e5 + 5, MOD = 100003;

int n, m;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M * 2];
int idx;

void add(int a, int b)
{
    E[++idx] = {b, H[a]}, H[a] = idx;
}

int dist[N];
bool st[N];
int Q[N], hh, tt;
int f[N];

void bfs()
{
    dist[1] = 0;
    st[1] = true;
    Q[tt++] = 1;
    f[1] = 1;

    while (hh != tt)
    {
        int u = Q[hh++];

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            if (!st[v])
            {
                dist[v] = dist[u] + 1;
                st[v] = true;
                Q[tt++] = v;
                f[v] = f[u];
            }
            else if (dist[u] + 1 == dist[v]) f[v] = (f[v] + f[u]) % MOD;
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        add(a, b), add(b, a);
    }

    bfs();

    for (int i = 1; i <= n; i++) cout << f[i] << '\n';

    return 0;
}
```

### 观光

题目：https://www.acwing.com/problem/content/description/385/

题解：https://www.acwing.com/solution/content/12246/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using LL = long long;
using std::cin, std::cout;

const int N = 1010, M = 1e4 + 5;

int n, m;
int S, F;

int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

int dist[N][2];
bool st[N][2];
int f[N][2];

void dijkstra()
{
    struct Node
    {
        int v, t, d;

        bool operator< (const Node &ct) const
        {
            return d >= ct.d;
        }
    };

    std::priority_queue<Node> Q;
    Q.push({S, 0, 0});
    memset(dist, 0x3f, sizeof dist);
    dist[S][0] = 0;
    memset(st, 0, sizeof st);
    memset(f, 0, sizeof f);
    f[S][0] = 1;
    
    while (!Q.empty())
    {
        auto [u, t, d] = Q.top(); Q.pop();

        if (st[u][t]) continue;
        st[u][t] = true;

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;

            if (dist[u][t] + w < dist[v][0])
            {
                dist[v][1] = dist[v][0];
                dist[v][0] = dist[u][t] + w;
                f[v][1] = f[v][0];
                f[v][0] = f[u][t];
                Q.push({v, 1, dist[v][1]});
                Q.push({v, 0, dist[v][0]});
            }
            else if (dist[u][t] + w == dist[v][0])
            {
                f[v][0] += f[u][t];
            }
            else if (dist[u][t] + w < dist[v][1])
            {
                dist[v][1] = dist[u][t] + w;
                f[v][1] = f[u][t];
                Q.push({v, 1, dist[v][1]});
            }
            else if (dist[u][t] + w == dist[v][1])
            {
                f[v][1] += f[u][t];
            }
        }
    }
}

void solve()
{
    idx = 0;
    memset(H, 0, sizeof H);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w);
    }
    cin >> S >> F;

    dijkstra();

    int res = f[F][0];
    if (dist[F][1] == dist[F][0] + 1) res += f[F][1];
    cout << res << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int t; cin >> t;
    while (t--) solve();

    return 0;
}
```

## Floyd算法

### 牛的旅行

题目：https://www.acwing.com/problem/content/1127/

先用floyd，然后用floyd的结论`dist[n][n]`去求连通块内距离每个点最远的点，记录在maxd数组中。

之后依次尝试连接两个不连通的点i和j，计算它们构成的连通块并通过这两个点的最大距离，即`maxd[i] + maxd[j] + D[i][j]`。

最终的答案有两种情况，如果任意新构成的连通块的直径没有连通之前的最大直径大，那么答案为连通之前的最大直径；如果连通后的连通块的直径更大，那么答案应该为连通后的连通块的最小直径。

```c++
#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 160;
const double INF = 1e10;

int n;
std::pair<int, int> point[N];
char G[N][N];
double dist[N][N];

double getDist(std::pair<int, int> &a, std::pair<int, int> &b)
{
    auto [x1, y1] = a; auto [x2, y2] = b;
    double dx = x1 - x2, dy = y1 - y2;
    return sqrt(dx * dx + dy * dy);
}

void floyd()
{
    for (int k = 0; k < n; k++)
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                dist[i][j] = std::min(dist[i][j], dist[i][k] + dist[k][j]);
}

double maxd[N];

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    for (int i = 0; i < n; i++)
    {
        int x, y; cin >> x >> y;
        point[i] = {x, y};
    }
    for (int i = 0; i < n; i++) cin >> G[i];

    for (int i = 0; i < n; i++)
        for (int j = 0; j < i; j++)
        {
            if (G[i][j] == '1')
                dist[i][j] = dist[j][i] = getDist(point[i], point[j]);
            else dist[i][j] = dist[j][i] = INF;
        }

    floyd();

    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            if (dist[i][j] < INF)
                maxd[i] = std::max(maxd[i], dist[i][j]);

    double res1 = *std::max_element(maxd, maxd + n);
    double res2 = INF;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < i; j++)
            if (dist[i][j] == INF)
            {
                double d = getDist(point[i], point[j]);
                res2 = std::min(res2, maxd[i] + d + maxd[j]);
            }

    printf("%.6lf\n", std::max(res1, res2));

    return 0;
}
```

### 排序

题目：https://www.acwing.com/problem/content/description/345/

**传递闭包/在线Floyd：**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 30, M = N * N;

int n, m;
bool G[N][N];
int inD[N];
int cnt, tot;

void connect(int a, int b)
{
    G[a][b] = true;
    cnt++, inD[b]++;
}

void floyd(int a, int b)
{
    connect(a, b);

    for (int i = 0; i < n; i++)
    {
        if (G[i][a] && !G[i][b]) connect(i, b);
        if (G[b][i] && !G[a][i]) connect(a, i);
    }

    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            if (!G[i][j] && G[i][a] && G[b][j])
                connect(i, j);
}

int Q[N];

void topSort()
{
    int hh = 0, tt = 0;
    for (int i = 0; i < n; i++)
        if (inD[i] == 0)
            Q[tt++] = i;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int v = 0; v < n; v++)
            if (G[u][v])
            {
                inD[v]--;
                if (inD[v] == 0) Q[tt++] = v;
            }
    }
}

void solve()
{
    cnt = 0, tot = n * (n - 1) / 2;
    memset(G, 0, sizeof G);
    memset(inD, 0, sizeof inD);

    int t = 1;
    for (; t <= m; t++)
    {
        char S[4]; cin >> S;
        int a = S[0] - 'A', b = S[2] - 'A';
        if (a != b && !G[b][a]) // 必须保证a和b不同才能连接，否则矛盾
        {
            if (!G[a][b])
            {
                floyd(a, b); // 在线floyd算法
                if (cnt == tot)
                {
                    topSort();
                    cout << "Sorted sequence determined after "
                         << t << " relations: ";
                    for (int i = 0; i < n; i++) cout << char('A' + Q[i]);
                    cout << ".\n";

                    for (t++; t <= m; t++) cin >> S;
                    return;
                }
            }
        }
        else // 矛盾
        {
            cout << "Inconsistency found after " << t << " relations."
                 << '\n';

            for (t++; t <= m; t++) cin >> S; 
            return;
        }
    }

    cout << "Sorted sequence cannot be determined." << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    while (cin >> n >> m, n || m)
        solve();

    return 0;
}
```

### 观光之旅

题目：https://www.acwing.com/problem/content/description/346/

题解：https://www.acwing.com/solution/content/144021/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 110, INF = 0x3f3f3f3f;

int n, m;
int G[N][N];

int dist[N][N], last[N][N];
int minV, path[N], cnt;

void getPath(int i, int j)
{
    int k = last[i][j];
    if (k == 0) return;

    getPath(k, j);
    path[cnt++] = k;
    getPath(i, k);
}

void floyd()
{
    memcpy(dist, G, sizeof G);
    minV = INF;

    for (int k = 1; k <= n; k++)
    {
        for (int i = 1; i < k; i++)
            for (int j = i + 1; j < k; j++)
            {
                LL len = LL(dist[i][j]) + G[i][k] + G[k][j]; // 三个INF相加会爆int
                if (len < minV)
                {
                    minV = len;
                    cnt = 0;
                    path[cnt++] = i;
                    path[cnt++] = k;
                    path[cnt++] = j;
                    getPath(i, j);
                }
            }

        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
            {
                if (dist[i][k] + dist[k][j] < dist[i][j])
                {
                    dist[i][j] = dist[i][k] + dist[k][j];
                    last[i][j] = k;
                }
            }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    memset(G, 0x3f, sizeof G);
    for (int i = 0; i < N; i++) G[i][i] = 0;

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        G[a][b] = G[b][a] = std::min(G[a][b], w);
    }

    floyd();

    if (minV < INF)
    {
        for (int i = 0; i < cnt; i++) cout << path[i] << ' ';
        cout << '\n';
    }
    else cout << "No solution." << '\n';

    return 0;
}
```

### 牛站

题目：https://www.acwing.com/problem/content/description/347/

题解：https://www.acwing.com/solution/content/36603/

本题的特色是理解res数组和G数组的初始化区别。G是不能把`G[i][i]`设置为0的，因为这样可能会在计算时导致少算边数；res数组将`res[i][i]`设置为0是因为必须保证第一次的`dp(res, res, G)`得到的res数组和G数组相同。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 210, M = 1010;

int K, m;
int n, disc[M];
int G[N][N];
int start, end;

int res[N][N];

void dp(int C[][N], int A[][N], int B[][N])
{
    static int tmp[N][N];
    memset(tmp, 0x3f, sizeof tmp);

    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                tmp[i][j] = std::min(tmp[i][j], A[i][k] + B[k][j]);

    memcpy(C, tmp, sizeof tmp);
}

void fp()
{
    memset(res, 0x3f, sizeof res);
    for (int i = 1; i <= n; i++) res[i][i] = 0;

    while (K)
    {
        if (K & 1) dp(res, res, G);
        dp(G, G, G);
        K >>= 1;
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    memset(G, 0x3f, sizeof G);

    cin >> K >> m >> start >> end;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> w >> a >> b;
        if (disc[a] == 0) disc[a] = ++n;
        if (disc[b] == 0) disc[b] = ++n;
        a = disc[a], b = disc[b];
        G[a][b] = G[b][a] = std::min(G[a][b], w);
    }
    start = disc[start], end = disc[end];

    fp();

    cout << res[start][end] << '\n';

    return 0;
}
```

## 最小生成树

### 最短网络

题目：https://www.acwing.com/problem/content/description/1142/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 110;

int n;
int G[N][N];

bool st[N];
int dist[N];

int prim()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    int res = 0;

    for (int i = 0; i < n; i++)
    {
        int u = -1;
        for (int j = 1; j <= n; j++)
            if (!st[j] && (u == -1 || dist[j] < dist[u]))
                u = j;

        st[u] = true;
        res += dist[u];

        for (int v = 1; v <= n; v++)
            dist[v] = std::min(dist[v], G[u][v]);
    }

    return res;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            cin >> G[i][j];
    
    cout << prim() << '\n';

    return 0;
}
```

### 局域网

题目：https://www.acwing.com/problem/content/description/1143/

Kruskal算法可以用于求“最小生成森林”。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 110, M = 210;

int n, m;
struct Edge
{
    int a, b, w;

    bool operator< (const Edge &ct) const
    {
        return w < ct.w;
    }
} E[M];

int P[N];

int find(int x)
{
    if (x != P[x]) P[x] = find(P[x]);
    return P[x];
}

int kruskal()
{
    for (int i = 1; i <= n; i++) P[i] = i;
    std::sort(E, E + m);

    int res = 0, cnt = 0;

    for (int i = 0; i < m; i++)
    {
        auto [a, b, w] = E[i];
        a = find(a), b = find(b);
        if (a != b)
        {
            P[a] = b;
            res += w;
            if (++cnt == n - 1) break;
        }
    }

    return res;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    int tot = 0;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        E[i] = {a, b, w};
        tot += w;
    }

    int res = tot - kruskal();
    cout << res << '\n';

    return 0;
}
```

### 繁忙的都市

题目：https://www.acwing.com/problem/content/description/1144/

Kruskal算法求最大权最小生成树。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 310, M = 8010;

int n, m;
struct Edge
{
    int a, b, w;

    bool operator< (const Edge &ct)
    {
        return w < ct.w;
    }
} E[M];

int P[N];

int find(int x)
{
    if (x != P[x]) P[x] = find(P[x]);
    return P[x];
}

int kruskal()
{
    for (int i = 1; i <= n; i++) P[i] = i;
    std::sort(E, E + m);

    int res = 0, cnt = 0;

    for (int i = 0; i < m; i++)
    {
        auto [a, b, w] = E[i];
        a = find(a), b = find(b);
        if (a != b)
        {
            P[a] = b;
            res = w;
            if (++cnt == n - 1) break;
        }
    }

    return res;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        E[i] = {a, b, w};
    }

    cout << n - 1 << ' ' << kruskal() << '\n';

    return 0;
}
```

### 联络员

题目：https://www.acwing.com/problem/content/1145/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 2010, M = 1e4 + 5;

int n, m;
struct Edge
{
    int a, b, w;

    bool operator< (const Edge &ct) const
    {
        return w < ct.w;
    }
} E[M];
int tot, cnt; // tot表示table中边的数量，cnt表示生成树中的边的数量

int P[N];

int find(int x)
{
    if (x != P[x]) P[x] = find(P[x]);
    return P[x];
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int res = 0;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) P[i] = i;
    for (int i = 0; i < m; i++)
    {
        int a, b, w, op; cin >> op >> a >> b >> w;
        if (op == 1)
        {
            a = find(a), b = find(b);
            if (a != b)
            {
                P[a] = b;
                cnt++;
            }
            res += w;
        }
        else
        {
            E[tot++] = {a, b, w};
        }
    }

    std::sort(E, E + tot);

    for (int i = 0; i < tot; i++)
    {
        auto [a, b, w] = E[i];
        a = find(a), b = find(b);
        if (a != b)
        {
            P[a] = b;
            res += w;
            if (++cnt == n - 1) break;
        }
    }

    cout << res << '\n';

    return 0;
}
```

### 连接格点

题目：https://www.acwing.com/problem/content/description/1146/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e6 + 5, M = N * 2;

int n, m, totV;
struct Edge
{
    int a, b, w;
} E[M];
int totE;

int P[N];

int find(int x)
{
    if (x != P[x]) P[x] = find(P[x]);
    return P[x];
}

void build()
{
    for (int j = 1; j <= m; j++)
    {
        int a = j, b = j;
        for (int i = 2; i <= n; i++)
        {
            b += m;
            if (find(a) != find(b))
            {
                E[totE++] = {a, b, 1};
            }
            a = b;
        }
    }

    for (int i = 1; i <= n; i++)
    {
        int a = (i - 1) * m + 1, b = a;
        for (int j = 2; j <= m; j++)
        {
            b++;
            if (find(a) != find(b))
            {
                E[totE++] = {a, b, 2};
            }
            a = b;
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    totV = n * m;
    for (int i = 1; i <= totV; i++) P[i] = i;
    int x1, y1, x2, y2;
    int cnt = 0;
    while (cin >> x1 >> y1 >> x2 >> y2)
    {
        int a = (x1 - 1) * m + y1, b = (x2 - 1) * m + y2;
        if (find(a) != find(b))
        {
            P[find(a)] = find(b);
            cnt++;
        }
    }

    build();

    int cost = 0;
    for (int i = 0; i < totE; i++)
    {
        auto [a, b, w] = E[i];
        if (find(a) != find(b))
        {
            P[find(a)] = find(b);
            cost += w;
            if (++cnt == totV - 1) break;
        }
    }

    cout << cost << '\n';
    return 0;
}
```

## 最小生成树的扩展应用

### 新的开始

题目：https://www.acwing.com/problem/content/description/1148/

本题的核心思想是，设置一个虚拟源点，该点到其他各个点的距离为建站的代价。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 310;

int n;
int G[N][N];

bool st[N];
int dist[N];

int prim()
{
    memset(dist, 0x3f, sizeof dist);
    dist[0] = 0;

    int res = 0;
    for (int i = 0; i <= n; i++)
    {
        int u = -1;
        for (int j = 0; j <= n; j++)
            if (!st[j] && (u == -1 || dist[j] < dist[u]))
                u = j;

        st[u] = true;
        res += dist[u];

        for (int v = 0; v <= n; v++)
            if (!st[v])
                dist[v] = std::min(dist[v], G[u][v]);
    }

    return res;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        int x; cin >> x;
        G[0][i] = G[i][0] = x;
    }
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            cin >> G[i][j];
    
    cout << prim() << '\n';

    return 0;
}
```

### 北极通讯网络

题目：https://www.acwing.com/problem/content/description/1147/

很直观的思路，每次都选最小边，直到连通块数量小于等于K。

```c++
#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 510, M = N * (N - 1) / 2;

int n, K;

struct Point
{
    int x, y;
} pt[N];

struct Edge
{
    int a, b;
    double d;

    bool operator< (const Edge &ct)
    {
        return d < ct.d;
    }
} E[M];
int tot;

int P[N];

int find(int x)
{
    if (x != P[x]) P[x] = find(P[x]);
    return P[x];
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> K;
    for (int i = 0; i < n; i++)
    {
        int x, y; cin >> x >> y;
        pt[i] = {x, y};
    }
    for (int i = 0; i < n; i++)
        for (int j = 0; j < i; j++)
        {
            int dx = pt[i].x - pt[j].x, dy = pt[i].y - pt[j].y;
            double d = sqrt(dx * dx + dy * dy);
            E[tot++] = {i, j, d};
        }

    std::sort(E, E + tot);

    for (int i = 0; i < n; i++) P[i] = i;

    int cnt = n;
    double res = 0;
    for (int i = 0; i < tot; i++)
    {
        if (cnt <= K) break;

        auto [a, b, d] = E[i];
        a = find(a), b = find(b);
        if (a != b)
        {
            res = d;
            P[a] = b;
            cnt--;
        }
    }

    printf("%.2lf\n", res);

    return 0;
}
```

### 走廊泼水节

题目：https://www.acwing.com/problem/content/description/348/

dijkstra每次的有效操作（即并查集的Union操作）相当于连接两个连通块，只需要在每次两个连通块被连通时，使新生成的连通块是完全子图即可。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 6010;

int n;
struct Edge
{
    int a, b, w;

    bool operator< (const Edge &ct) const
    {
        return w < ct.w;
    }
} E[N];

int P[N], cnt[N];

int find(int x)
{
    if (x != P[x]) P[x] = find(P[x]);
    return P[x];
}

void solve()
{
    cin >> n;
    for (int i = 0; i < n - 1; i ++)
    {
        int a, b, w; cin >> a >> b >> w;
        E[i] = {a, b, w};
    }

    std::sort(E, E + n - 1);
    for (int i = 1; i <= n; i++)
    {
        P[i] = i;
        cnt[i] = 1;
    }

    int res = 0;
    for (int i = 0; i < n - 1; i++)
    {
        auto [a, b, w] = E[i];
        a = find(a), b = find(b);
        res += (cnt[a] * cnt[b] - 1) * (w + 1);
        P[a] = b;
        cnt[b] += cnt[a];
    }

    cout << res << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int T; cin >> T;
    while (T--)
        solve();

    return 0;
}
```

### 秘密的牛奶运输

题目：https://www.acwing.com/problem/content/description/1150/

题解：https://www.acwing.com/solution/content/93261/

本题有一个坑点，`dfs`中的`mx1`和`mx2`必须初始化为`-INF`。因为如果所有边长度都相同，那么就不存在次短路`dist2`，这个时候就会产生错误的答案。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 510, M = 1e4 + 5;
const LL INF = 1e9 + 10;

int n, m;
struct Edge
{
    int a, b, w;
    bool inMST;

    bool operator< (const Edge &ct) const
    {
        return w < ct.w;
    }
} E[M];

int P[N];

int find(int x)
{
    if (x != P[x]) P[x] = find(P[x]);
    return P[x];
}

int H[N];
struct EdgeNode
{
    int v, w, n;
} EN[M * 2];
int idx;

void add(int a, int b, int w)
{
    EN[++idx] = {b, w, H[a]}, H[a] = idx; 
}

LL kruskal()
{
    for (int i = 1; i <= n; i++) P[i] = i;
    std::sort(E, E + m);

    LL sum = 0;
    for (int i = 0, cnt = 0; i < m; i++)
    {
        auto [a, b, w, f] = E[i];
        if (find(a) != find(b))
        {
            P[find(a)] = find(b);
            sum += w;
            E[i].inMST = true;
            add(a, b, w), add(b, a, w);

            if (++cnt == n - 1) break;
        }
    }

    return sum;
}

int dist1[N][N], dist2[N][N];

void dfs(int u, int fa, int mx1, int mx2, int d1[], int d2[])
{
    d1[u] = mx1, d2[u] = mx2;
    
    for (int p = H[u]; p; p = EN[p].n)
    {
        int v = EN[p].v, w = EN[p].w;
        if (v != fa)
        {
            int t1 = mx1, t2 = mx2;
            if (w > t1)
            {
                t2 = t1;
                t1 = w;
            }
            else if (w < t1 && w > t2)
            {
                t2 = w;
            }
            dfs(v, u, t1, t2, d1, d2);
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        E[i] = {a, b, w};
    }

    LL sum = kruskal();

    for (int i = 1; i <= n; i++) dfs(i, -1, -INF, -INF, dist1[i], dist2[i]);

    LL res = INF * N;
    for (int i = 0; i < m; i++)
        if (!E[i].inMST)
        {
            auto [a, b, w, f] = E[i];
            if (w > dist1[a][b])
            {
                res = std::min(res, sum - dist1[a][b] + w);
            }
            else
            {
                res = std::min(res, sum - dist2[a][b] + w);
            }
        }
    
    cout << res << '\n';

    return 0;
}
```

## 负环

### 虫洞

题目：https://www.acwing.com/problem/content/description/906/

题解：https://www.acwing.com/solution/content/20506/

入队次数大于等于n说明有负环；路径长度大于等于n也说明有负环，并且判断效率更高。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 510, M = 5210;

int n, m1, m2;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

bool st[N];
int dist[N], cnt[N], Q[N];

bool spfa()
{
    memset(dist, 0, sizeof dist);
    memset(cnt, 0, sizeof cnt);
    memset(st, 0, sizeof st);

    int hh = 0, tt = 0;

    for (int u = 1; u <= n; u++)
    {
        Q[tt++] = u;
        st[u] = true;
    }
    tt %= N;

    while (hh != tt)
    {
        int u = Q[hh++]; hh %= N;
        st[u] = false;

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[u] + w < dist[v])
            {
                dist[v] = dist[u] + w;
                cnt[v] = cnt[u] + 1;
                if (cnt[v] >= n) return true;
                if (!st[v])
                {
                    Q[tt++] = v; tt %= N;
                    st[v] = true;
                }
            }
        }
    }

    return false;
}

void solve()
{
    idx = 0;
    memset(H, 0, sizeof H);

    cin >> n >> m1 >> m2;
    for (int i = 0; i < m1; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w), add(b, a, w);
    }
    for (int i = 0; i < m2; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, -w);
    }

    cout << (spfa() ? "YES" : "NO") << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int T; cin >> T;
    while (T--)
        solve();

    return 0;
}
```

### 观光奶牛

题目：https://www.acwing.com/problem/content/description/363/

题解：https://www.acwing.com/solution/content/37185/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1010, M = 5010;

int n, m;
int H[N], f[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

bool st[N];
double dist[N];
int Q[N];
int cnt[N];

bool check(double mid)
{
    int hh = 0, tt = 0;
    memset(st, 0, sizeof st);
    memset(dist, 0, sizeof dist);
    memset(cnt, 0, sizeof cnt);
    
    for (int i = 1; i <= n; i++)
    {
        Q[tt++] = i;
        st[i] = true;
    }
    tt %= N;

    while (hh != tt)
    {
        int u = Q[hh++]; hh %= N;
        st[u] = false;

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[u] + f[u] - mid * w > dist[v])
            {
                dist[v] = dist[u] + f[u] - mid * w;
                cnt[v] = cnt[u] + 1;
                if (cnt[v] >= n) return true;
                if (!st[v])
                {
                    Q[tt++] = v; tt %= N;
                    st[v] = true;
                }
            }
        }
    }

    return false;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> f[i];
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w);
    }

    double l = 0, r = 1000;
    while (r - l > 1e-5)
    {
        double mid = (l + r) / 2;
        if (check(mid)) l = mid;
        else r = mid;
    }

    printf("%.2lf\n", l);
    return 0;
}
```

### 单词环

题目：https://www.acwing.com/problem/content/description/1167/

题解：https://www.acwing.com/solution/content/17712/

可以把队列换成栈，能保证不超时并且一定正确。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 26 * 26 + 10, M = 1e5 + 5;
const double eps = 1e-4;

int m;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

double dist[N];
bool st[N];
int cnt[N];
int Q[N];

bool check(double mid)
{
    memset(dist, 0, sizeof dist);
    memset(st, 0, sizeof st);
    memset(cnt, 0, sizeof cnt);
    int hh = 0, tt = 0;
    for (int i = 0; i < N - 1; i++)
    {
        Q[tt++] = i;
        st[i] = true;
    }

    int flag = 0;
    while (hh != tt)
    {
        int u = Q[hh++]; hh %= N;
        st[u] = false;

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[u] + w - mid > dist[v])
            {
                dist[v] = dist[u] + w - mid;
                cnt[v] = cnt[u] + 1;
                if (cnt[v] >= N) return true;
                if (++flag >= N * 4) return true;
                if (!st[v])
                {
                    Q[tt++] = v; tt %= N;
                    st[v] = true;
                }
            }
        }
    }

    return false;
}

void solve()
{
    idx = 0;
    memset(H, 0, sizeof H);

    for (int i = 0; i < m; i++)
    {
        char S[1010]; cin >> S;
        int w = strlen(S);
        int a = (S[0] - 'a') * 26 + (S[1] - 'a');
        int b = (S[w - 2] - 'a') * 26 + (S[w - 1] - 'a');
        add(a, b, w);
    }

    if (!check(0)) cout << "No solution" << '\n';
    else
    {
        double l = 0, r = 1000;
        while (r - l > eps)
        {
            double mid = (l + r) / 2;
            if (check(mid)) l = mid;
            else r = mid;
        }
    
        printf("%.2lf\n", l);
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    while (cin >> m, m)
        solve();

    return 0;
}
```

## 差分约束

### 糖果

题目：https://www.acwing.com/problem/content/description/1171/

题解：https://www.acwing.com/solution/content/37324/

本题在考虑边的规模时必须要考虑虚拟源点的大小。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e5 + 5, M = 3e5 + 5;

int n, m;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

int dist[N];
int stk[N], tt;
bool st[N];
int cnt[N];

bool spfa()
{
    stk[tt++] = 0;
    st[0] = true;

    while (tt > 0)
    {
        int u = stk[--tt];
        st[u] = false;

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[u] + w > dist[v])
            {
                dist[v] = dist[u] + w;
                cnt[v] = cnt[u] + 1;
                if (cnt[v] >= n + 1) return true;
                if (!st[v])
                {
                    stk[tt++] = v;
                    st[v] = true;
                }
            }
        }
    }

    return false;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int x, a, b; cin >> x >> a >> b;
        switch (x)
        {
        case 1:
            add(a, b, 0), add(b, a, 0);
            break;
        case 2:
            add(a, b, 1);
            break;
        case 3:
            add(b, a, 0);
            break;
        case 4:
            add(b, a, 1);
            break;
        case 5:
            add(a, b, 0);
            break;
        }
    }
    for (int i = 1; i <= n; i++) add(0, i, 1);

    if (spfa()) cout << -1 << '\n';
    else
    {
        LL res = 0;
        for (int i = 1; i <= n; i++) res += dist[i];
        cout << res << '\n';
    }

    return 0;
}
```

### 区间

题目：https://www.acwing.com/problem/content/description/364/

题解：https://www.acwing.com/solution/content/42920/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 5e4 + 5, M = N * 3;

int n, m;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

int dist[N];
int Q[N];
bool st[N];

void spfa()
{
    memset(dist, -0x3f, sizeof dist);
    dist[0] = 0;
    int hh = 0, tt = 0;
    Q[tt++] = 0;
    st[0] = true;

    while (hh != tt)
    {
        int u = Q[hh++]; hh %= N;
        st[u] = false;

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[u] + w > dist[v])
            {
                dist[v] = dist[u] + w;
                if (!st[v])
                {
                    Q[tt++] = v; tt %= N;
                    st[v] = true;
                }
            }
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b, c; cin >> a >> b >> c;
        a++, b++;
        n = std::max({n, a, b});
        add(a - 1, b, c);
    }
    for (int i = 1; i <= n; i++)
    {
        add(i - 1, i, 0);
        add(i, i - 1, -1);
    }

    spfa();

    cout << dist[n] << '\n';

    return 0;
}
```

### 排队布局

题目：https://www.acwing.com/problem/content/description/1172/

题解：https://www.acwing.com/solution/content/80505/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1010, M = N + 2e4;
const LL INF = 0x3f3f3f3f3f3f3f3f;

int n, ml, md;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

LL dist[N];
int Q[N];
bool st[N];
int cnt[N];

bool spfa(int to)
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    memset(st, 0, sizeof st);
    memset(cnt, 0, sizeof cnt);
    int hh = 0, tt = 0;
    for (int i = 1; i <= to; i++)
    {
        Q[tt++] = i;
        st[i] = true;
    }
    tt %= N;

    while (hh != tt)
    {
        int u = Q[hh++]; hh %= N;
        st[u] = false;

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[u] + w < dist[v])
            {
                dist[v] = dist[u] + w;
                cnt[v] = cnt[u] + 1;
                if (cnt[v] >= n) return true;
                if (!st[v])
                {
                    Q[tt++] = v; tt %= N;
                    st[v] = true;
                }
            }
        }
    }

    return false;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> ml >> md;
    for (int i = 1; i < n; i++) add(i + 1, i, 0);
    for (int i = 0; i < ml; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        if (a > b) std::swap(a, b);
        add(a, b, w);
    }
    for (int i = 0; i < md; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        if (a > b) std::swap(a, b);
        add(b, a, -w);
    }

    if (spfa(n)) cout << -1 << '\n';
    else
    {
        spfa(1);
        cout << (dist[n] != INF ? dist[n] : -2) << '\n';
    }

    return 0;
}
```

### 雇佣收银员

题目：https://www.acwing.com/problem/content/description/395/

题解：https://www.acwing.com/solution/content/63552/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 25, M = N * 3 + 10;

int sum;
int R[N];
int num[N];

int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

void build(int mid)
{
    memset(H, 0, sizeof H);
    idx = 0;
    for (int i = 1; i <= 24; i++)
    {
        add(i - 1, i, 0);
        add(i, i - 1, -num[i]);
    }
    for (int i = 1; i < 8; i++) add(16 + i, i, R[i] - mid);
    for (int i = 8; i <= 24; i++) add(i - 8, i, R[i]);
    add(24, 0, -mid), add(0, 24, mid);
}

int dist[N];
int Q[N];
bool st[N];
int cnt[N];

bool check(int mid)
{
    build(mid);
    memset(dist, -0x3f, sizeof dist);
    dist[0] = 0;
    memset(cnt, 0, sizeof cnt);
    memset(st, 0, sizeof st);
    int hh = 0, tt = 0;
    Q[tt++] = 0;
    st[0] = true;

    while (hh != tt)
    {
        int u = Q[hh++]; hh %= N;
        st[u] = false;

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[u] + w > dist[v])
            {
                dist[v] = dist[u] + w;
                cnt[v] = cnt[u] + 1;
                if (cnt[v] >= N) return false;
                if (!st[v])
                {
                    Q[tt++] = v; tt %= N;
                    st[v] = true;
                }
            }
        }
    }

    return true;
}

void solve()
{
    for (int i = 1; i <= 24; i++) cin >> R[i];
    cin >> sum;
    memset(num, 0, sizeof num);
    for (int i = 0; i < sum; i++)
    {
        int x; cin >> x;
        num[x + 1]++;
    }
    int l = 0, r = sum; // 也可以改为枚举
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    if (!check(l)) cout << "No Solution" << '\n';
    else cout << l << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int T; cin >> T;
    while (T--)
        solve();

    return 0;
}
```

## 最近公共祖先

### 祖孙询问

题目：https://www.acwing.com/problem/content/description/1174/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 4e4 + 5, M = N * 2;

int n, m;
int root;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M];
int idx;

void add(int a, int b)
{
    E[++idx] = {b, H[a]}, H[a] = idx;
}

bool st[N];
int Q[N], hh, tt;
int fa[N][17];
int depth[N];

void bfs()
{
    st[root] = true;
    depth[root] = 1; // 关键，如果没有这个会出错
    Q[tt++] = root;

    while (hh != tt)
    {
        int u = Q[hh++];

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v;

            if (!st[v])
            {
                fa[v][0] = u;
                for (int i = 1; i <= 16; i++)
                {
                    fa[v][i] = fa[fa[v][i - 1]][i - 1];
                }

                st[v] = true;
                depth[v] = depth[u] + 1;
                Q[tt++] = v;
            }
        }
    }
}

int LCA(int a, int b)
{
    if (depth[a] < depth[b]) std::swap(a, b);

    for (int i = 16; i >= 0; i--)
        if (depth[fa[a][i]] >= depth[b])
            a = fa[a][i];

    if (a == b) return a;

    for (int i = 16; i >= 0; i--)
        if (fa[a][i] != fa[b][i])
        {
            a = fa[a][i];
            b = fa[b][i];
        }

    return fa[a][0];
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    for (int i = 0; i < n; i++)
    {
        int a, b; cin >> a >> b;
        if (b == -1) root = a;
        else 
        {
            add(a, b), add(b, a);
        }
    }

    bfs();

    cin >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        int c = LCA(a, b);
        if (c == a) cout << 1 << '\n';
        else if (c == b) cout << 2 << '\n';
        else cout << 0 << '\n';
    }

    return 0;
}
```

### 距离

题目：https://www.acwing.com/problem/content/description/1173/

题解：https://www.acwing.com/solution/content/42924/

```c++
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <iostream>
#include <algorithm>
#include <vector>

using LL = long long;
using std::cin, std::cout;
using PII = std::pair<int, int>;

const int N = 1e4 + 5, M = N * 2;

int n, m;
int root;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

std::vector<PII> query[N];
int dist[N];

void dfs(int u, int fa)
{
    for (int p = H[u]; p; p = E[p].n)
    {
        int v = E[p].v, w = E[p].w;
        if (v != fa)
        {
            dist[v] = dist[u] + w;
            dfs(v, u);
        }
    }
}

int st[N];
int P[N];
int res[M];

int find(int x)
{
    if (x != P[x]) P[x] = find(P[x]);
    return P[x];
}

void Tarjan(int u)
{
    st[u] = 1;
    
    for (int p = H[u]; p; p = E[p].n)
    {
        int v = E[p].v;
        if (st[v] == 0)
        {
            Tarjan(v);
            P[v] = u;
        }
    }

    for (auto [v, id] : query[u])
        if (st[v] == 2)
        {
            int anc = find(v);
            res[id] = dist[v] + dist[u] - dist[anc] * 2; 
        }

    st[u] = 2;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < n - 1; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w), add(b, a, w);
    }
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        if (a != b)
        {
            query[a].push_back({b, i});
            query[b].push_back({a, i});
        }
    }

    srand(time(nullptr));
    root = rand() % n + 1;
    dfs(root, -1);

    for (int i = 1; i <= n; i++) P[i] = i;
    Tarjan(root);

    for (int i = 0; i < m; i++) cout << res[i] << '\n';

    return 0;
}
```

### 次小生成树

题目：https://www.acwing.com/problem/content/description/358/

题解：https://www.acwing.com/solution/content/64164/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e5 + 5, M = 3e5 + 5;
const LL INF = 1e12;

int n, m;
struct Edge
{
    int a, b, w;
    bool isMST;

    bool operator< (const Edge &ct) const
    {
        return w < ct.w;
    }
} edge[M];

int H[N];
struct EdgeNode
{
    int v, w, n;
} E[N * 2];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

int P[N];

int find(int x)
{
    if (x != P[x]) P[x] = find(P[x]);
    return P[x];
}

LL kruskal()
{
    for (int i = 1; i <= n; i++) P[i] = i;
    std::sort(edge, edge + m);

    LL sum = 0;
    for (int i = 0, cnt = 0; i < m; i++)
    {
        auto [a, b, w, f] = edge[i];
        if (find(a) != find(b))
        {
            P[find(a)] = find(b);
            sum += w;
            edge[i].isMST = true;
            if (++cnt == n - 1) break;
        }
    }

    return sum;
}

void build()
{
    for (int i = 0, cnt = 0; i < m; i++)
    {
        auto [a, b, w, f] = edge[i];
        if (f)
        {
            add(a, b, w), add(b, a, w);
            if (++cnt == n - 1) return;
        }
    }
}

int Q[N], hh, tt;
bool st[N];
int depth[N];
int fa[N][17];
int d1[N][17], d2[N][17];

void bfs(int root)
{
    memset(d2, -1, sizeof d2);

    st[root] = true;
    depth[root] = 1;
    Q[tt++] = root;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (!st[v])
            {
                st[v] = true;

                depth[v] = depth[u] + 1;
                fa[v][0] = u;
                d1[v][0] = w;
                for (int i = 1; i <= 16; i++)
                {
                    int mid = fa[v][i - 1];
                    fa[v][i] = fa[mid][i - 1];
                    d1[v][i] = std::max(d1[v][i - 1], d1[mid][i - 1]);
                    for (int t : {d1[v][i - 1], d1[mid][i - 1], 
                                  d2[v][i - 1], d2[mid][i - 1]})
                    {
                        if (t != d1[v][i])
                            d2[v][i] = std::max(d2[v][i], t);
                    }
                }

                Q[tt++] = v;
            }
        }
    }
}

int LCA(int a, int b, int w)
{
    static int D[N * 2];
    int cnt = 0;

    if (depth[a] < depth[b]) std::swap(a, b);
    for (int i = 16; i >= 0; i--)
        if (depth[fa[a][i]] >= depth[b])
        {
            D[cnt++] = d1[a][i], D[cnt++] = d2[a][i];
            a = fa[a][i];
        }

    if (a != b)
    {
        for (int i = 16; i >= 0; i--)
            if (fa[a][i] != fa[b][i])
            {
                D[cnt++] = d1[a][i], D[cnt++] = d2[a][i];
                D[cnt++] = d1[b][i], D[cnt++] = d2[b][i];
                a = fa[a][i], b = fa[b][i];
            }
        D[cnt++] = d1[a][0], D[cnt++] = d2[a][0];
        D[cnt++] = d1[b][0], D[cnt++] = d2[b][0];
    }

    int w1 = *std::max_element(D, D + cnt);
    if (w1 < w) return w1;
    else
    {
        int w2 = -1;
        for (int i = 0; i < cnt; i++)
            if (D[i] != w1)
                w2 = std::max(w2, D[i]);
        return w2;
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        edge[i] = {a, b, w};
    }

    LL sum = kruskal();

    build();
    int root = 1;
    bfs(root);

    LL res = INF;
    for (int i = 0; i < m; i++)
    {
        auto [a, b, w, f] = edge[i];
        if (!f && a != b)
        {
            int t = LCA(a, b, w);
            if (t != -1)
            {
                res = std::min(res, sum - t + w);
            }
        }
    }

    cout << res << '\n';

    return 0;
}
```

### 闇の連鎖

题目：https://www.acwing.com/problem/content/description/354/

题解：https://www.acwing.com/solution/content/24653/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e5 + 5, M = 2e5 + 5;

int n, m;
int root;
int H[N];
struct EdgeNode
{
    int v, n;
} E[N * 2];
int idx;

void add(int a, int b)
{
    E[++idx] = {b, H[a]}, H[a] = idx;
}

int Q[N], hh, tt;
bool st[N];
int depth[N];
int fa[N][15];

void bfs()
{
    st[root] = true;
    depth[root] = 1;
    Q[tt++] = root;
    
    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            if (!st[v])
            {
                st[v] = true;
                depth[v] = depth[u] + 1;
                fa[v][0] = u;
                for (int i = 1; i <= 14; i++)
                {
                    fa[v][i] = fa[fa[v][i - 1]][i - 1];
                }
                Q[tt++] = v;
            }
        }
    }
}

int LCA(int a, int b)
{
    if (depth[a] < depth[b]) std::swap(a, b);
    for (int i = 14; i >= 0; i--)
        if (depth[fa[a][i]] >= depth[b])
            a = fa[a][i];

    if (a == b) return a;

    for (int i = 14; i >= 0; i--)
        if (fa[a][i] != fa[b][i])
        {
            a = fa[a][i];
            b = fa[b][i];
        }

    return fa[a][0];
}

int disc[N];  // 树上差分

int res;

int dfs(int u, int pa)
{
    int sum = disc[u];
    for (int p = H[u]; p; p = E[p].n)
    {
        int v = E[p].v;
        if (v != pa)
        {
            int ret = dfs(v, u);
            if (ret == 0) res += m;
            else if (ret == 1) res++;
            sum += ret;
        }
    }

    return sum;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < n - 1; i++)
    {
        int a, b; cin >> a >> b;
        add(a, b), add(b, a);
    }
    root = 1;
    bfs();
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        int p = LCA(a, b);
        disc[a]++, disc[b]++, disc[p] -= 2;
    }

    dfs(root, -1);

    cout << res << '\n';
    return 0;
}
```

## 有向图的强连通分量

### 受欢迎的牛

题目：https://www.acwing.com/problem/content/description/1176/

题解：https://www.acwing.com/solution/content/20678/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e4 + 5, M = 5e4 + 5;

int n, m;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M];
int idx;

void add(int a, int b)
{
    E[++idx] = {b, H[a]}, H[a] = idx;
}

int low[N], dfn[N], ts;
int stk[N], top;
bool inStk[N];
int id[N], size[N], cnt;

void Tarjan(int u)
{
    low[u] = dfn[u] = ++ts;
    stk[++top] = u;
    inStk[u] = true;

    for (int p = H[u]; p; p = E[p].n)
    {
        int v = E[p].v;
        if (dfn[v] == 0)
        {
            Tarjan(v);
            low[u] = std::min(low[u], low[v]);
        }
        else if (inStk[v])
        {
            low[u] = std::min(low[u], dfn[v]);
        }
    }

    if (low[u] == dfn[u])
    {
        int x = -1;
        cnt++;
        while (x != u)
        {
            x = stk[top--];
            inStk[x] = false;
            size[cnt]++;
            id[x] = cnt;
        }
    }
}

int dout[N];

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        add(a, b);
    }

    for (int u = 1; u <= n; u++)
        if (dfn[u] == 0)
            Tarjan(u);

    for (int u = 1; u <= n; u++)
    {
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            int a = id[u], b = id[v];
            if (a != b) dout[a]++;
        }
    }

    int res = 0;
    for (int i = 1, tmp = 0; i <= cnt; i++)
        if (dout[i] == 0)
        {
            if (++tmp > 1)
            {
                res = 0;
                break;
            }
            res = size[i];
        }

    cout << res << '\n';

    return 0;
}
```

### 学校网络

题目：https://www.acwing.com/problem/content/description/369/

题解：https://www.acwing.com/solution/content/4663/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 110, M = 1e4 + 5;

int n;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M];
int idx;

void add(int a, int b)
{
    E[++idx] = {b, H[a]}, H[a] = idx;
}

int dfn[N], low[N], ts;
int stk[N], top;
bool inStk[N];
int id[N], cnt;

void Tarjan(int u)
{
    stk[++top] = u;
    inStk[u] = true;
    low[u] = dfn[u] = ++ts;

    for (int p = H[u]; p; p = E[p].n)
    {
        int v = E[p].v;
        if (dfn[v] == 0)
        {
            Tarjan(v);
            low[u] = std::min(low[u], low[v]);
        }
        else if (inStk[v])
        {
            low[u] = std::min(low[u], dfn[v]);
        }
    }

    if (dfn[u] == low[u])
    {
        int x = -1;
        cnt++;
        while (x != u)
        {
            x = stk[top--];
            inStk[x] = false;
            id[x] = cnt;
        }
    }
}

int din[N], dout[N];

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    for (int a = 1; a <= n; a++)
    {
        int b;
        while (cin >> b, b)
        {
            add(a, b);
        }
    }

    for (int u = 1; u <= n; u++)
        if (dfn[u] == 0)
            Tarjan(u);

    for (int u = 1; u <= n; u++)
    {
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            int a = id[u], b = id[v];
            if (a != b) dout[a]++, din[b]++;
        }
    }

    int p = 0, q = 0;
    for (int i = 1; i <= cnt; i++)
    {
        if (din[i] == 0) p++;
        if (dout[i] == 0) q++;
    }

    cout << p << '\n';
    cout << (cnt == 1 ? 0 : std::max(p, q)) << '\n';

    return 0;
}
```

### 最大半连通子图

题目：https://www.acwing.com/problem/content/description/1177/

题解：https://www.acwing.com/solution/content/24796/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <unordered_set>

using LL = long long;
using std::cin, std::cout;

const int N = 1e5 + 5, M = 1e6 + 5;

int n, m;
int MOD;
int H1[N], H2[N];
struct EdgeNode
{
    int v, n;
} E[M * 2];
int idx;

void add(int H[], int a, int b)
{
    E[++idx] = {b, H[a]}, H[a] = idx;
}

int dfn[N], low[N], ts;
int stk[N], top;
bool inStk[N];
int id[N], cnt;
int size[N];

void Tarjan(int u)
{
    dfn[u] = low[u] = ++ts;
    stk[++top] = u;
    inStk[u] = true;

    for (int p = H1[u]; p; p = E[p].n)
    {
        int v = E[p].v;
        if (dfn[v] == 0)
        {
            Tarjan(v);
            low[u] = std::min(low[u], low[v]);
        }
        else if (inStk[v])
        {
            low[u] = std::min(low[u], dfn[v]);
        }
    }

    if (dfn[u] == low[u])
    {
        cnt++;
        int x = -1;
        while (x != u)
        {
            x = stk[top--];
            inStk[x] = false;
            id[x] = cnt;
            size[cnt]++;
        }
    }
}

int f[N], g[N];

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m >> MOD;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        add(H1, a, b);
    }

    for (int u = 1; u <= n; u++)
        if (dfn[u] == 0)
            Tarjan(u);

    std::unordered_set<LL> hs;
    for (int u = 1; u <= n; u++)
    {
        int a = id[u];
        for (int p = H1[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            int b = id[v];
            if (a != b)
            {
                LL code = (LL(a) << 32) + b;
                if (!hs.count(code))
                {
                    add(H2, a, b);
                    hs.insert(code);
                }
            }
        }
    }

    for (int u = cnt; u >= 1; u--)
    {
        if (f[u] == 0)
        {
            f[u] = size[u];
            g[u] = 1;
        }

        for (int p = H2[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            if (f[u] + size[v] > f[v])
            {
                f[v] = f[u] + size[v];
                g[v] = g[u];
            }
            else if (f[u] + size[v] == f[v])
            {
                g[v] = (g[u] + g[v]) % MOD;
            }
        }
    }

    int mxf = 0, res = 0;
    for (int i = 1; i <= cnt; i++)
    {
        if (f[i] > mxf)
        {
            mxf = f[i];
            res = g[i];
        }
        else if (f[i] == mxf)
        {
            res = (res + g[i]) % MOD;
        }
    }

    cout << mxf << '\n' << res << '\n';

    return 0;
}
```

### 银河

题目：https://www.acwing.com/problem/content/description/370/

题解：https://www.acwing.com/solution/content/24811/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e5 + 5, M = 6e5 + 5;

int n, m;
int H1[N], H2[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx;

void add(int H[], int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

int dfn[N], low[N], ts;
int stk[N], top;
bool inStk[N];
int id[N], cnt;
int size[N];

void Tarjan(int u)
{
    dfn[u] = low[u] = ++ts;
    stk[++top] = u;
    inStk[u] = true;

    for (int p = H1[u]; p; p = E[p].n)
    {
        int v = E[p].v;
        if (dfn[v] == 0)
        {
            Tarjan(v);
            low[u] = std::min(low[u], low[v]);
        }
        else if (inStk[v])
        {
            low[u] = std::min(low[u], dfn[v]);
        }
    }

    if (dfn[u] == low[u])
    {
        cnt++;
        int x = -1;
        while (x != u)
        {
            x = stk[top--];
            inStk[x] = false;
            id[x] = cnt;
            size[cnt]++;
        }
    }
}

int dist[N];

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b, t; cin >> t >> a >> b;
        switch (t)
        {
        case 1:
            add(H1, a, b, 0), add(H1, b, a, 0);
            break;
        case 2:
            add(H1, a, b, 1);
            break;
        case 3:
            add(H1, b, a, 0);
            break;
        case 4:
            add(H1, b, a, 1);
            break;
        case 5:
            add(H1, a, b, 0);
            break;
        }
    }
    for (int i = 1; i <= n; i++) add(H1, 0, i, 1);

    for (int i = 0; i <= n; i++)
        if (dfn[i] == 0)
            Tarjan(i);

    for (int u = 0; u <= n; u++)
    {
        int a = id[u];
        for (int p = H1[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            int b = id[v];
            if (a == b)
            {
                if (w > 0)
                {
                    cout << -1 << '\n';
                    return 0;
                }
            }
            else
            {
                add(H2, a, b, w);
            }
        }
    }

    for (int u = cnt; u >= 1; u--)
    {
        for (int p = H2[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            dist[v] = std::max(dist[v], dist[u] + w);
        }
    }

    LL res = 0;
    for (int i = 1; i <= cnt; i++) res += size[i] * dist[i];

    cout << res << '\n';

    return 0;
}
```

## 无向图的双连通分量

### 冗余路径

题目：https://www.acwing.com/problem/content/description/397/

题解：https://www.acwing.com/solution/content/65355/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 5010, M = 2e4 + 5;

int n, m;
int H[N];
struct EdgeNode
{
    int v, n;
    bool isBridge;
} E[M];
int idx = 1;

void add(int a, int b)
{
    E[++idx] = {b, H[a]}, H[a] = idx;
}

int low[N], dfn[N], ts;
int stk[N], top;
int id[N], cntDcc;

void Tarjan(int u, int inEdge)
{
    stk[++top] = u;
    low[u] = dfn[u] = ++ts;

    for (int p = H[u]; p; p = E[p].n)
    {
        int v = E[p].v;
        if (dfn[v] == 0)
        {
            Tarjan(v, p);
            low[u] = std::min(low[u], low[v]);

            if (low[v] > dfn[u])
            {
                E[p].isBridge = true;
                E[p ^ 1].isBridge = true;
            }
        }
        else if (p != (inEdge ^ 1)) // 此处的括号不能少
        {
            low[u] = std::min(low[u], dfn[v]);
        }
    }

    if (dfn[u] == low[u])
    {
        cntDcc++;
        int x = -1;
        while (x != u)
        {
            x = stk[top--];
            id[x] = cntDcc;
        }
    }
}

int deg[N];

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        add(a, b), add(b, a);
    }

    Tarjan(1, -1);

    for (int i = 2; i <= idx; i++)
        if (E[i].isBridge)
            deg[id[E[i].v]]++;
    
    int cnt = 0;
    for (int i = 1; i <= cntDcc; i++)
        if (deg[i] == 1)
            cnt++;

    cout << (cnt + 1) / 2 << '\n';
    return 0;
}
```



### 电力

题目：https://www.acwing.com/problem/content/1185/

题解：https://www.acwing.com/solution/content/20702/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e4 + 5, M = 3e4 + 5;

int n, m;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M];
int idx;

void add(int a, int b)
{
    E[++idx] = {b, H[a]}, H[a] = idx;
}

int root, mx;
int low[N], dfn[N], ts;

void Tarjan(int u)
{
    low[u] = dfn[u] = ++ts;

    int cnt = 0;
    for (int p = H[u]; p; p = E[p].n)
    {
        int v = E[p].v;
        if (dfn[v] == 0)
        {
            Tarjan(v);
            low[u] = std::min(low[u], low[v]);

            if (dfn[u] <= low[v])
            {
                cnt++;
            }
        }
        else
        {
            low[u] = std::min(low[u], dfn[v]);
        }
    }

    if (u != root) cnt++;
    mx = std::max(mx, cnt);
}

void init()
{
    idx = 0;
    memset(H, 0, sizeof H);
    mx = ts = 0;
    memset(low, 0, sizeof low);
    memset(dfn, 0, sizeof dfn);
}

void solve()
{
    init();
    
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        add(a, b), add(b, a);
    }

    int cnt = 0;
    for (root = 0; root < n; root++)
        if (dfn[root] == 0)
        {
            cnt++;
            Tarjan(root);
        }

    cout << mx + cnt - 1 << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    while (cin >> n >> m, n || m)
        solve();

    return 0;
}
```

### 矿场搭建

题目：https://www.acwing.com/problem/content/description/398/

题解：https://www.acwing.com/solution/content/152028/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>

using ULL = unsigned long long;
using std::cin, std::cout;

const int N = 1010;

int n, m;
int H[N];
struct EdgeNode
{
    int v, n;
} E[N];
int idx;

void add(int a, int b)
{
    E[++idx] = {b, H[a]}, H[a] = idx;
}

int root;
int low[N], dfn[N], ts;
int stk[N], top;
int cntDcc;
bool cut[N];
std::vector<int> dcc[N];

void Tarjan(int u)
{
    stk[++top] = u;
    low[u] = dfn[u] = ++ts;

    int flag = 0;
    for (int p = H[u]; p; p = E[p].n)
    {
        int v = E[p].v;
        if (dfn[v] == 0)
        {
            Tarjan(v);
            low[u] = std::min(low[u], low[v]);

            if (dfn[u] <= low[v])
            {
                flag++;
                cntDcc++;
                if (u != root || flag > 1) cut[u] = true;
                int x = -1;
                while (x != v)
                {
                    x = stk[top--];
                    dcc[cntDcc].push_back(x);
                }
                dcc[cntDcc].push_back(u);
            }
        }
        else
        {
            low[u] = std::min(low[u], dfn[v]);
        }
    }
}

void init()
{
    idx = n = 0;
    memset(H, 0, sizeof H);

    for (int i = 1; i <= cntDcc; i++) dcc[i].clear();
    ts = top = cntDcc = 0;
    memset(low, 0, sizeof low);
    memset(dfn, 0, sizeof dfn);
    memset(cut, 0, sizeof cut);
}

int T;

void solve()
{
    init();

    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        add(a, b), add(b, a);
        n = std::max({n, a, b});
    }

    int res1 = 0;
    for (root = 1; root <= n; root++)
    {
        if (!H[root]) res1++;
        else
        {
            if (dfn[root] == 0)
                Tarjan(root);
        }
    }

    ULL res2 = 1;
    for (int i = 1; i <= cntDcc; i++)
    {
        int cnt = 0;
        for (int v : dcc[i])
            if (cut[v])
                cnt++;

        if (cnt == 0)
        {
            res1 += 2;
            res2 *= dcc[i].size() * (dcc[i].size() - 1) / 2;
        }
        else if (cnt == 1)
        {
            res1++;
            res2 *= dcc[i].size() - 1;
        }
    }

    printf("Case %d: %d %llu\n", ++T, res1, res2);
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    while (cin >> m, m)
        solve();

    return 0;
}
```

## 二分图

### 关押罪犯

题目：https://www.acwing.com/problem/content/description/259/

题解：https://www.acwing.com/solution/content/3042/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 2e4 + 5, M = 2e5 + 5;

int n, m;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

int color[N];

bool dfs(int u, int c, int lim)
{
    color[u] = c;
    for (int p = H[u]; p; p = E[p].n)
    {
        int v = E[p].v, w = E[p].w;
        if (w > lim)
        {
            if (color[v] == 0)
            {
                if (!dfs(v, -c, lim)) return false;
            }
            else if (color[v] == c) return false;
        }
    }

    return true;
}

bool check(int mid)
{
    memset(color, 0, sizeof color);

    for (int i = 1; i <= n; i++)
        if (color[i] == 0)
            if (!dfs(i, 1, mid))
                return false;

    return true;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w), add(b, a, w);
    }

    int l = 1, r = 1e9;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }

    int res = l;
    if (l == 1 && check(1)) res--;
    cout << res << '\n';

    return 0;
}
```

### 棋盘覆盖

题目：https://www.acwing.com/problem/content/description/374/

题解：https://www.acwing.com/solution/content/25013/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using PII = std::pair<int, int>;
using std::cin, std::cout;

const int N = 110;

int n, m;
bool G[N][N];

int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
bool st[N][N];
PII match[N][N];

bool dfs(int px, int py)
{
    for (int i = 0; i < 4; i++)
    {
        int x = px + dx[i], y = py + dy[i];
        if (x >= 1 && x <= n && y >= 1 && y <= n)
        {
            if (!st[x][y] && !G[x][y])
            {
                st[x][y] = true;
                auto [a, b] = match[x][y];
                if (a == 0 || dfs(a, b))
                {
                    match[x][y] = {px, py};
                    return true;
                }
            }
        }
    }

    return false;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        G[a][b] = true;
    }

    int res = 0;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            if ((i + j) % 2 && !G[i][j])
            {
                memset(st, 0, sizeof st);
                if (dfs(i, j)) res++;
            }

    cout << res << '\n';

    return 0;
}
```

### 机器任务

题目：https://www.acwing.com/problem/content/378/

题解：https://www.acwing.com/solution/content/43149/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 110, M = 1010;

int n, m, K;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M];
int idx;

void add(int a, int b)
{
    E[++idx] = {b, H[a]}, H[a] = idx;
}

bool st[N];
int match[N];

bool dfs(int u)
{
    for (int p = H[u]; p; p = E[p].n)
    {
        int v = E[p].v;
        if (!st[v])
        {
            st[v] = true;
            if (match[v] == 0 || dfs(match[v]))
            {
                match[v] = u;
                return true;
            }
        }
    }

    return false;
}

void solve()
{
    idx = 0;
    memset(H, 0, sizeof H);
    memset(match, 0, sizeof match);

    for (int i = 0; i < K; i++)
    {
        int t, a, b; cin >> t >> a >> b;
        if (a && b) add(a, b);
    }

    int res = 0;
    for (int i = 1; i <= n; i++)
    {
        memset(st, 0, sizeof st);
        if (dfs(i)) res++;
    }

    cout << res << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    while (cin >> n, n)
    {
        cin >> m >> K;
        solve();
    }

    return 0;
}
```

### 骑士放置

题目：https://www.acwing.com/problem/content/description/380/

最大独立集=删除最少点和连接它们的边，使得剩下的点互不相连

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using PII = std::pair<int, int>;
using std::cin, std::cout;

const int N = 110;

int n, m;
bool G[N][N];

bool st[N][N];
PII match[N][N];
int dx[8] = {-2, -1, 1, 2, 2, 1, -1, -2};
int dy[8] = {1, 2, 2, 1, -1, -2, -2, -1};

bool dfs(int px, int py)
{
    for (int i = 0; i < 8; i++)
    {
        int x = px + dx[i], y = py + dy[i];
        if (x >= 1 && x <= n && y >= 1 && y <= m)
            if (!G[x][y] && !st[x][y])
            {
                st[x][y] = true;
                auto [a, b] = match[x][y];
                if (a == 0 || dfs(a, b))
                {
                    match[x][y] = {px, py};
                    return true;
                }
            }
    }    

    return false;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int t; cin >> n >> m >> t;
    for (int i = 0; i < t; i++)
    {
        int a, b; cin >> a >> b;
        G[a][b] = true;
    }

    int res = n * m - t;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            if ((i + j) % 2 && !G[i][j])
            {
                memset(st, 0, sizeof st);
                res -= dfs(i, j);
            }
    
    cout << res << '\n';

    return 0;
}
```

### 捉迷藏

题目：https://www.acwing.com/problem/content/381/

题解：https://www.acwing.com/solution/content/15162/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 210;

int n, m;
bool G[N][N];

bool st[N];
int match[N];

bool dfs(int u)
{
    for (int v = 1; v <= n; v++)
        if (G[u][v] && !st[v])
        {
            st[v] = true;
            if (match[v] == 0 || dfs(match[v]))
            {
                match[v] = u;
                return true;
            }
        }

    return false;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        G[a][b] = true;
    }

    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                if (!G[i][j])
                    G[i][j] = G[i][k] && G[k][j];

    int res = n;
    for (int i = 1; i <= n; i++)
    {
        memset(st, 0, sizeof st);
        if (dfs(i)) res--;
    }

    cout << res << '\n';

    return 0;
}
```

## 欧拉回路和欧拉路径

### 铲雪车

题目：https://www.acwing.com/problem/content/description/1125/

题解：https://www.acwing.com/solution/content/4877/

```c++
#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int x1, y1, x2, y2;
    cin >> x1 >> y1;
    double sum{0};
    while (cin >> x1 >> y1 >> x2 >> y2)
    {
        double dx = x1 - x2, dy = y1 - y2;
        sum += sqrt(dx * dx + dy * dy);
    }

    int res = round(sum * 2 / 1000 / 20 * 60);
    printf("%d:%02d\n", res / 60, res % 60);

    return 0;
}
```

### 欧拉回路

题目：https://www.acwing.com/problem/content/description/1186/

题解：https://www.acwing.com/solution/content/53434/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e5 + 5, M = 2e5 + 5;

int type, n, m;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M * 2];
int idx;

void add(int a, int b)
{
    E[++idx] = {b, H[a]}, H[a] = idx;
}

int din[N], dout[N];
int res[M], cnt;
bool st[M * 2];

void dfs(int u)
{
    while (H[u])
    {
        int p = H[u];
        if (st[p])
        {
            H[u] = E[p].n;
            continue;
        }
        
        int v = E[p].v;
        H[u] = E[p].n;
        if (type == 1)
        {
            st[p ^ 1] = true;
        }

        dfs(v);

        if (type == 1)
        {
            res[++cnt] = p / 2;
            if (p % 2) res[cnt] = -res[cnt];
        }
        else
        {
            res[++cnt] = p - 1;
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    idx = 1;
    cin >> type >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        dout[a]++, din[b]++;
        add(a, b);
        if (type == 1) add(b, a);
    }

    if (type == 1)
    {
        for (int i = 1; i <= n; i++)
            if ((din[i] + dout[i]) % 2)
            {
                cout << "NO" << '\n';
                return 0;
            }
    }
    else
    {
        for (int i = 1; i <= n; i++)
            if (din[i] != dout[i])
            {
                cout << "NO" << '\n';
                return 0;
            }
    }

    dfs(E[2].v);

    if (cnt < m)
    {
        cout << "NO" << '\n';
        return 0;
    }

    cout << "YES" << '\n';
    for (int i = cnt; i >= 1; i--) cout << res[i] << ' ';
    cout << '\n';

    return 0;
}
```



### 骑马修栅栏

题目：https://www.acwing.com/problem/content/description/1126/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 510, M = 2100;

int mn = N, mx, m;
int G[N][N];
int deg[N];
int res[N], cnt;

void dfs(int u)
{
    for (int v = mn; v <= mx; v++)
        if (G[u][v])
        {
            G[u][v]--, G[v][u]--;
            dfs(v);
        }

    res[++cnt] = u; 
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        mx = std::max({mx, a, b});
        mn = std::min({mn, a, b});
        G[a][b]++, G[b][a]++;
        deg[a]++, deg[b]++;
    }

    int start = mn;
    for (int i = start; i <= mx; i++)
        if (deg[i] % 2)
        {
            start = i;
            break;
        }

    dfs(start);
    
    for (int i = cnt; i >= 1; i--) cout << res[i] << '\n';

    return 0;
}
```

### 单词游戏

题目：https://www.acwing.com/problem/content/description/1187/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

int m;
int din[26], dout[26];
bool st[26];
int P[26];

int find(int x)
{
    if (x != P[x]) P[x] = find(P[x]);
    return P[x];
}

void solve()
{
    memset(din, 0, sizeof din);
    memset(dout, 0, sizeof dout);
    memset(st, 0, sizeof st);
    for (int i = 0; i < 26; i++) P[i] = i;
    
    cin >> m;
    for (int i = 0; i < m; i++)
    {
        std::string word; cin >> word;
        int a = word.front() - 'a', b = word.back() - 'a';
        dout[a]++, din[b]++;
        st[a] = st[b] = true;
        P[find(a)] = find(b);
    }

    int root = -1;
    for (int i = 0; i < 26; i++)
        if (st[i])
        {
            root = find(i);
            break;
        }
    for (int i = 0; i < 26; i++)
        if (st[i] && find(i) != root)
        {
            cout << "The door cannot be opened." << '\n';
            return;
        }

    int start = 0, end = 0;
    for (int i = 0; i < 26; i++)
        if (din[i] != dout[i])
        {
            if (dout[i] == din[i] + 1) start++;
            else if (dout[i] + 1 == din[i]) end++;
            else
            {
                cout << "The door cannot be opened." << '\n';
                return;
            }
        }
    
    if (start == end && start <= 1)
    {
        cout << "Ordering is possible." << '\n';
    }
    else
    {
        cout << "The door cannot be opened." << '\n';
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int T; cin >> T;
    while (T--)
        solve();

    return 0;
}
```

## 拓扑排序

### 家谱树

题目：https://www.acwing.com/problem/content/description/1193/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 110;

int n;
int H[N];
struct EdgeNode
{
    int v, n;
} E[N * N];
int idx;

void add(int a, int b)
{
    E[++idx] = {b, H[a]}, H[a] = idx;
}

int deg[N];
int Q[N], hh, tt;

void topSort()
{
    for (int i = 1; i <= n; i++)
        if (deg[i] == 0)
            Q[tt++] = i;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            if (--deg[v] == 0)
            {
                Q[tt++] = v;
            }
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        int child;
        while (cin >> child, child)
        {
            deg[child]++;
            add(i, child);
        }
    }

    topSort();

    for (int i = 0; i < tt; i++) cout << Q[i] << ' ';
    cout << '\n';

    return 0;
}
```

### 奖金

题目：https://www.acwing.com/problem/content/description/1194/

可以用差分约束做，这里用了动态规划的思想。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e4 + 5, M = 2e4 + 5;

int n, m;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M];
int idx;

void add(int a, int b)
{
    E[++idx] = {b, H[a]}, H[a] = idx;
}

int deg[N];
int Q[N], hh, tt;
int price[N], res;

bool topSort()
{
    for (int i = 1; i <= n; i++)
        if (deg[i] == 0)
        {
            Q[tt++] = i;
            price[i] = 100;
            res += 100;
        }

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            price[v] = std::max(price[v], price[u] + 1);
            if (--deg[v] == 0)
            {
                Q[tt++] = v;
                res += price[v];
            }
        }
    }

    return tt == n;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        add(b, a);
        deg[a]++;
    }

    if (topSort()) cout << res << '\n';
    else cout << "Poor Xed" << '\n';

    return 0;
}
```

### 可达性统计

题目：https://www.acwing.com/problem/content/description/166/

拓扑排序+状态压缩DP

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <bitset>

using LL = long long;
using std::cin, std::cout;

const int N = 3e4 + 5;

int n, m;
int H[N];
struct EdgeNode
{
    int v, n;
} E[N];
int idx;

void add(int a, int b)
{
    E[++idx] = {b, H[a]}, H[a] = idx;
}

int deg[N];
int Q[N], hh, tt;

void topSort()
{
    for (int i = 1; i <= n; i++)
        if (deg[i] == 0)
            Q[tt++] = i;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            if (--deg[v] == 0)
            {
                Q[tt++] = v;
            }
        }
    }
}

std::bitset<N> f[N];

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        add(a, b);
        deg[b]++;
    }

    topSort();

    for (int i = tt - 1; i >= 0; i--)
    {
        int u = Q[i];
        f[u][u] = 1;
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            f[u] |= f[v];
        }
    }

    for (int i = 1; i <= n; i++) cout << f[i].count() << '\n';

    return 0;
}
```

### 车站分级

题目：https://www.acwing.com/problem/content/description/458/

题解：https://www.acwing.com/solution/content/8537/

拓扑排序优化差分约束

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 2010, M = 1e6 + 5;

int n, m;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

bool st[N];
int deg[N];
int Q[N], hh, tt;

void topSort()
{
    for (int i = 1; i <= m + n; i++)
        if (deg[i] == 0)
            Q[tt++] = i;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (--deg[v] == 0)
            {
                Q[tt++] = v;
            }
        }
    }
}

int dist[N];

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= m; i++)
    {
        memset(st, 0, sizeof st);
        int cnt, start, end;
        cin >> cnt >> start;
        for (int j = 0; j < cnt - 2; j++)
        {
            int x; cin >> x;
            st[x] = true;
        }
        cin >> end;
        st[start] = st[end] = true;

        int mn = i + n;
        for (int j = start; j <= end; j++)
        {
            if (st[j])
            {
                add(j, mn, 0);
                deg[mn]++;
            }
            else
            {
                add(mn, j, 1);
                deg[j]++;
            }
        }
    }

    topSort();

    for (int i = 1; i <= n; i++) dist[i] = 1;  // 这里不用n+m的原因很简单，因为新加虚拟点不可能是拓扑图的终点
    for (int i = tt - 1; i >= 0; i--)
    {
        int u = Q[i];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            dist[u] = std::max(dist[u], dist[v] + w);
        }
    }

    int res = *std::max_element(dist + 1, dist + 1 + n);  // 同理
    cout << res << '\n';

    return 0;
}
```

