# 数学

## 筛质数

### 哥德巴赫猜想

题目：https://www.acwing.com/problem/content/description/1294/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e6 + 5;

bool st[N];
int prime[N], cnt;

auto init = []()
{
    for (int i = 2; i < N; i++)
    {
        if (!st[i])
        {
            prime[cnt++] = i;
        }
        for (int j = 0; LL(prime[j]) * i < N; j++)
        {
            st[prime[j] * i] = true;
            if (i % prime[j] == 0) break;
        }
    }
    return 0;
}();

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int n;
    while (cin >> n, n)
    {
        int res = -1;
        for (int i = 1; prime[i] <= n / 2; i++)
            if (!st[n - prime[i]])
            {
                res = prime[i];
                break;
            }
        if (res != -1) printf("%d = %d + %d\n", n, res, n - res);
        else puts("Goldbach's conjecture is wrong.");
    }

    return 0;
}
```

### 夏洛克和他的女朋友

题目：https://www.acwing.com/problem/content/description/1295/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e5 + 5;

bool st[N];
int prime[N], cnt;

auto init = []()
{
    for (int i = 2; i < N; i++)
    {
        if (!st[i]) prime[cnt++] = i;

        for (int j = 0; LL(prime[j]) * i < N; j++)
        {
            st[prime[j] * i] = true;
            if (i % prime[j] == 0) break;
        }
    }
    return 0;
}();

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int n; cin >> n;
    cout << (n >= 3 ? 2 : 1) << '\n';
    for (int i = 2; i <= n + 1; i++) cout << (!st[i] ? 1 : 2) << ' ';
    cout << '\n';

    return 0;
}
```

### 质数距离

题目：https://www.acwing.com/problem/content/description/198/

题解：https://www.acwing.com/solution/content/45722/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 5e4, M = 1e6 + 5;

bool st[M];
int prime[N], cnt;

auto init = []()
{
    for (int i = 2; i < N; i++)
    {
        if (!st[i]) prime[cnt++] = i;
        for (int j = 0; LL(prime[j]) * i < N; j++)
        {
            st[prime[j] * i] = true;
            if (i % prime[j] == 0) break;
        }
    }
    return 0;
}();

int l, r;

void solve()
{
    memset(st, 0, sizeof st);

    for (int i = 0; i < cnt; i++)
    {
        int p = prime[i];
        if (LL(p) * p > r) break;
        for (int j = r / p * p; j >= l && j > p; j -= p)  // 顺序可能会导致越界
        {
            st[j - l] = true;
        }
    }

    int difMin = M, c1, c2;
    int difMax = 0, d1, d2;
    int cur = -1, pre = -1;
    for (int i = r; i >= l && i > 1; i--)  // 顺序可能会导致越界
        if (!st[i - l])
        {
            if (cur == -1)
            {
                cur = pre = i;
            }
            else
            {
                cur = i;
                if (pre - cur <= difMin)
                {
                    c1 = cur, c2 = pre;
                    difMin = pre - cur;
                }
                if (pre - cur >= difMax)
                {
                    d1 = cur, d2 = pre;
                    difMax = pre - cur;
                }
                pre = cur;
            }
        }
    
    if (difMax > 0)
    {
        printf("%d,%d are closest, %d,%d are most distant.\n", 
               c1, c2, d1, d2);
    }
    else puts("There are no adjacent primes.");
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    while (cin >> l >> r)
        solve();

    return 0;
}
```

## 分解质因数

### 阶乘分解

题目：https://www.acwing.com/problem/content/description/199/

勒让德定理

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e6 + 5;

bool st[N];
int prime[N], cnt;

auto init = []
{
    for (int i = 2; i < N; i++)
    {
        if (!st[i]) prime[cnt++] = i;

        for (int j = 0; LL(prime[j]) * i < N; j++)
        {
            st[prime[j] * i] = true;
            if (i % prime[j] == 0) break;
        }
    }
    return 0;
}();

int Legendre(int n, int p)
{
    int res = 0;
    while (n >= p)
    {
        res += n / p;
        n /= p;
    }
    return res;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int n; cin >> n;
    for (int i = 0; i < cnt && prime[i] <= n; i++)
    {
        int p = prime[i];
        cout << p << ' ' << Legendre(n, p) << '\n';
    }

    return 0;
}
```

## 快速幂

### 序列的第k个数

题目：https://www.acwing.com/problem/content/description/1291/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int MOD = 200907;

int a1, a2, a3, K, ak;

int fp(int a, int b, int p)
{
    int res = 1;
    while (b)
    {
        if (b & 1) res = LL(res) * a % p;
        a = LL(a) * a % p;
        b >>= 1;
    }
    return res;
}

void solve()
{
    cin >> a1 >> a2 >> a3 >> K;
    if (a2 - a1 == a3 - a2)
    {
        ak = (a1 + LL(K - 1) * (a2 - a1)) % MOD;
    }
    else
    {
        ak = LL(a1) * fp(a2 / a1, K - 1, MOD) % MOD;
    }
    cout << ak << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int T; cin >> T;
    while (T--)
        solve();

    return 0;
}
```

### 越狱

题目：https://www.acwing.com/problem/content/description/1292/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int MOD = 100003;

int fp(LL a, LL b, int p)
{
    LL res = 1;
    while (b)
    {
        if (b & 1) res = res * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return res;
}

int mod(int a, int m)
{
    return (a % m + m) % m;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    LL n, m; cin >> m >> n;
    int res = fp(m, n, MOD) - LL(m) * fp(m - 1, n - 1, MOD) % MOD;
    cout << mod(res, MOD) << '\n';

    return 0;
}
```

## 约数个数

### 轻拍牛头

题目：https://www.acwing.com/problem/content/description/1293/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e6 + 5;

int n;
int A[N];
int cnt[N], sum[N];

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    int mx = 0, mn = N;
    for (int i = 0; i < n; i++)
    {
        cin >> A[i];
        cnt[A[i]]++;
        mx = std::max(mx, A[i]);
        mn = std::min(mn, A[i]);
    }

    for (int i = mn; i <= mx; i++)
        if (cnt[i])
            for (int j = i; j <= mx; j += i)
                sum[j] += cnt[i];

    for (int i = 0; i < n; i++) cout << sum[A[i]] - 1 << '\n';

    return 0;
}
```

### 樱花

题目：https://www.acwing.com/problem/content/description/1296/

题解：https://www.acwing.com/solution/content/47739/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e6 + 5, MOD = 1e9 + 7;

bool st[N];
int prime[N], cnt;

auto init = []
{
    for (int i = 2; i < N; i++)
    {
        if (!st[i]) prime[cnt++] = i;
        for (int j = 0; LL(prime[j]) * i < N; j++)
        {
            st[prime[j] * i] = true;
            if (i % prime[j] == 0) break;
        }
    }
    return 0;
}();

int Legendre(int n, int p)
{
    int res = 0;
    while (n >= p)
    {
        res += n / p;
        n /= p;
    }
    return res;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int n; cin >> n;
    int res = 1;
    for (int i = 0; i < cnt && prime[i] <= n; i++)
    {
        int c = Legendre(n, prime[i]);
        res = LL(res) * (c * 2 + 1) % MOD;
    }

    cout << res << '\n';
    return 0;
}
```

### 反素数

题目：https://www.acwing.com/problem/content/description/200/

题解：https://www.acwing.com/solution/content/47849/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

int n;
int mx, res;
int prime[9] = {2, 3, 5, 7, 11, 13, 17, 19, 23};

void dfs(int u, int last, int prod, int cnt)
{
    if (cnt > mx || (cnt == mx && prod < res))
    {
        res = prod;
        mx = cnt;
    }
    if (u == 9) return;

    for (int i = 1; i <= last; i++)
        if (LL(prod) * prime[u] <= n)
        {
            prod *= prime[u];
            dfs(u + 1, i, prod, cnt * (i + 1));
        }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    dfs(0, 30, 1, 1);
    cout << res << '\n';

    return 0;
}
```

### Hankson的趣味题

题目：https://www.acwing.com/problem/content/description/202/

题解：https://www.acwing.com/solution/content/3101/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>

using LL = long long;
using std::cin, std::cout;
using PII = std::pair<int, int>;

const int N = 45000;

bool st[N];
int prime[N], cnt;

auto init = []
{
    for (int i = 2; i < N; i++)
    {
        if (!st[i]) prime[cnt++] = i;
        for (int j = 0; LL(prime[j]) * i < N; j++)
        {
            st[prime[j] * i] = true;
            if (i % prime[j] == 0) break;
        }
    }
    return 0;
}();

int a0, a1, b0, b1;
PII fac[N];  // b1的质因数分解
int cntf;
int divisor[N], cntd;  // b1的所有约数

void getFac(int n)
{
    for (int i = 0; LL(prime[i]) * prime[i] <= n; i++)
    {
        int p = prime[i];
        if (n % p == 0)
        {
            int c = 0;
            while (n % p == 0)
            {
                n /= p;
                c++;
            }
            fac[cntf++] = {p, c};
        }
    }
    if (n > 1) fac[cntf++] = {n, 1};
}

void dfs(int u, int prod)
{
    if (u == cntf)
    {
        divisor[cntd++] = prod;
        return;
    }

    auto [p, c] = fac[u];
    for (int i = 0; i <= c; i++)
    {
        dfs(u + 1, prod);
        prod *= p;
    }
}

int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}

LL lcm(int a, int b)
{
    return LL(a / gcd(a, b)) * b;
}

void solve()
{
    cin >> a0 >> a1 >> b0 >> b1;

    // 分解 b1
    cntf = 0;
    getFac(b1);

    // 求b1的所有约数
    cntd = 0;
    dfs(0, 1);

    int res = 0;
    for (int i = 0; i < cntd; i++)
    {
        int x = divisor[i];
        if (gcd(x, a0) == a1 && lcm(x, b0) == b1)
        {
            res++;
        }
    }
    cout << res << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int t; cin >> t;
    while (t--)
        solve();

    return 0;
}
```

## 欧拉函数

### 可见的点

题目：https://www.acwing.com/problem/content/description/203/

题解：https://www.acwing.com/solution/content/25745/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1010;

bool st[N];
int prime[N], cnt;
int phi[N], ps[N];

auto init = []
{
    phi[1] = 1;
    for (int i = 2; i < N; i++)
    {
        if (!st[i])
        {
            prime[cnt++] = i;
            phi[i] = i - 1;
        }
        for (int j = 0; LL(prime[j]) * i < N; j++)
        {
            st[prime[j] * i] = true;
            if (i % prime[j] == 0)
            {
                phi[prime[j] * i] = prime[j] * phi[i];
                break;
            }
            else
            {
                phi[prime[j] * i] = (prime[j] - 1) * phi[i];
            }
        }
    }

    for (int i = 1; i < N; i++) ps[i] = ps[i - 1] + phi[i];
    return 0;
}();

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int T; cin >> T;
    for (int i = 1; i <= T; i++)
    {
        int n; cin >> n;
        printf("%d %d %d\n", i, n, ps[n] * 2 + 1);
    }

    return 0;
}
```

### 最大公约数

题目：https://www.acwing.com/problem/content/description/222/

题解：https://www.acwing.com/solution/content/25752/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e7 + 5;

bool st[N];
int prime[N], cnt;
int phi[N];
LL ps[N];

auto init = []
{
    phi[1] = 1;
    for (int i = 2; i < N; i++)
    {
        if (!st[i])
        {
            prime[cnt++] = i;
            phi[i] = i - 1;
        }

        for (int j = 0; LL(prime[j]) * i < N; j++)
        {
            st[prime[j] * i] = true;
            if (i % prime[j] == 0)
            {
                phi[prime[j] * i] = prime[j] * phi[i];
                break;
            }
            else
            {
                phi[prime[j] * i] = (prime[j] - 1) * phi[i];
            }
        }
    }

    for (int i = 1; i < N; i++) ps[i] = ps[i - 1] + phi[i];
    return 0;
}();

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int n; cin >> n;
    LL res = 0;
    for (int i = 0; i < cnt && prime[i] <= n; i++)
    {
        int p = prime[i];
        res += ps[n / p] * 2 - 1;
    }

    cout << res << '\n';

    return 0;
}
```

## 同余

### 同余方程

题目：https://www.acwing.com/problem/content/205/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

int exgcd(int a, int b, int &x, int &y)
{
    if (b == 0)
    {
        x = 1, y = 0;
        return a;
    }

    int d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int a, b; cin >> a >> b;
    int x, y;
    exgcd(a, b, x, y);
    cout << (LL(x % b) + b) % b << '\n';

    return 0;
}
```

### 青蛙的约会

题目：https://www.acwing.com/problem/content/description/224/

1. 从数学上来说，最大公约数是正数。但在这里`exgcd(a, b, x, y)`有可能会返回负数，此时的`xa + yb`也是负数。
2. `b / d * x`在某些测试数据上会超过int的范围。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

int exgcd(int a, int b, int &x, int &y)
{
    if (b == 0)
    {
        x = 1, y = 0;
        return a;
    }

    int d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int x, y, m, n, L; cin >> x >> y >> m >> n >> L;
    int a = n - m, b = x - y;
    int d = exgcd(a, L, x, y);
    if (b % d)
    {
        cout << "Impossible" << '\n';
    }
    else
    {
        LL t = LL(b / d) * x;
        m = std::abs(L / d);
        cout << (t % m + m) % m << '\n';
    }
    return 0;
}
```

### 最幸运的数字

题目：https://www.acwing.com/problem/content/description/204/

题解：https://www.acwing.com/solution/content/47979/

```c++
#include <cstdio>
#include <cstring>
#include <climits>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

int L, T;

int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}

LL phi(LL n)
{
    LL res = n;
    for (LL p = 2; p <= n / p; p++)
        if (n % p == 0)
        {
            while (n % p == 0) n /= p;
            res = res / p * (p - 1);
        }
    if (n > 1) res = res / n * (n - 1);
    return res;
}

LL sm(LL a, LL b, LL m)
{
    LL res = 0;
    while (b)
    {
        if (b & 1) res = (res + a) % m;
        a = (a + a) % m;
        b >>= 1;
    }
    return res;
}

LL fp(LL a, LL b, LL m)
{
    LL res = 1;
    while (b)
    {
        if (b & 1) res = sm(res, a, m);
        a = sm(a, a, m);
        b >>= 1;
    }
    return res;
}

void solve()
{
    int d = gcd(L, 8);
    LL m = LL(L / d) * 9;
    LL x = phi(m);

    LL res = LONG_LONG_MAX;
    if (m % 2 == 0 || m % 5 == 0)
    {
        res = 0;
    }
    else
    {
        for (LL i = 1; i <= x / i; i++)
            if (x % i == 0)
            {
                LL j = x / i;
                if (fp(10, i, m) == 1) res = std::min(res, i);
                if (fp(10, j, m) == 1) res = std::min(res, j);
            }
    }

    printf("Case %d: %lld\n", ++T, res);
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    while (cin >> L, L)
        solve();

    return 0;
}
```

### 曹冲养猪

题目：https://www.acwing.com/problem/content/description/1300/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

LL exgcd(LL a, LL b, LL &x, LL &y)
{
    if (b == 0)
    {
        x = 1, y = 0;
        return a;
    }

    LL d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}

LL mod(LL a, LL m)
{
    return (a % m + m) % m;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int n; cin >> n;
    LL a1, m1; cin >> m1 >> a1;
    while ((n--) > 1)
    {
        LL a2, m2; cin >> m2 >> a2;
        LL x, y;
        LL d = exgcd(m1, m2, x, y);
        LL t = mod((a2 - a1) / d * x, m2);
        a1 += t * m1;
        m1 *= m2;
        a1 %= m1;
    }

    cout << a1 << '\n';

    return 0;
}
```

## 矩阵乘法

### 斐波那契前 n 项和

题目：https://www.acwing.com/problem/content/description/1305/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

int n, m;

void mul(int C[3][3], int A[3][3], int B[3][3])
{
    static int tmp[3][3];
    std::memset(tmp, 0, sizeof tmp);

    for (int i = 0; i < 3; i++)
        for (int j = 0; j < 3; j++)
            for (int k = 0; k < 3; k++)
                tmp[i][j] = (tmp[i][j] + LL(A[i][k]) * B[k][j]) % m;

    std::memcpy(C, tmp, sizeof tmp);
}

void mul(int C[3], int A[3][3], int B[3])
{
    static int tmp[3];
    std::memset(tmp, 0, sizeof tmp);

    for (int i = 0; i < 3; i++)
        for (int k = 0; k < 3; k++)
            tmp[i] = (tmp[i] + LL(A[i][k]) * B[k]) % m;

    std::memcpy(C, tmp, sizeof tmp);
}


int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    int A[3][3] = {{0, 1, 0}, {1, 1, 0}, {1, 1, 1}};
    int C[3][3] = {{1, 0, 1}, {0, 1, 0}, {0, 0, 1}};
    int start[3] = {0, 1, 1}, res[3];
    int b = n - 1;
    while (b)
    {
        if (b & 1) mul(C, C, A);
        mul(A, A, A);
        b >>= 1;
    }
    mul(res, C, start);
    cout << res[2] << '\n';

    return 0;
}
```

### 佳佳的斐波那契

题目：https://www.acwing.com/problem/content/1306/

题解：https://www.acwing.com/solution/content/48039/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 4;

int n, m;

void mul(int C[N][N], int A[N][N], int B[N][N])
{
    static int tmp[N][N];
    std::memset(tmp, 0, sizeof tmp);

    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
            for (int k = 0; k < N; k++)
                tmp[i][j] = (tmp[i][j] + LL(A[i][k]) * B[k][j] % m) % m;
    
    std::memcpy(C, tmp, sizeof tmp);
}

void mul(int C[N], int A[N][N], int B[N])
{
    static int tmp[N];
    std::memset(tmp, 0, sizeof tmp);

    for (int i = 0; i < N; i++)
        for (int k = 0; k < N; k++)
            tmp[i] = (tmp[i] + LL(A[i][k]) * B[k] % m) % m;

    std::memcpy(C, tmp, sizeof tmp);
}

int mod(LL a, int m)
{
    return (a % m + m) % m;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int A[4][4] = {{0, 1, 0, 0}, {1, 1, 0, 0}, {1, 1, 1, 0}, {1, 1, 1, 1}};
    int C[4][4] = {{1, 0, 0, 0}, {0, 1, 0, 0}, {0, 0, 1, 0}, {0, 0, 0, 1}};
    int res[4]{};
    int start[4] = {0, 1, 1, 1};

    cin >> n >> m;
    int b = n - 1;
    while (b)
    {
        if (b & 1) mul(C, C, A);
        mul(A, A, A);
        b >>= 1;
    }
    mul(res, C, start);
    cout << mod((LL(n) + 1) * res[2] - res[3], m) << '\n';

    return 0;
}
```



### GT考试

题目：https://www.acwing.com/problem/content/description/1307/

题解：https://www.acwing.com/solution/content/46059/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 25;

int n, m, MOD;
std::string X;
int pi[N];
int A[N][N];
int start[N]{1}, C[N];

void mul(int C[N][N], int A[N][N], int B[N][N])
{
    static int tmp[N][N];
    std::memset(tmp, 0, sizeof tmp);

    for (int i = 0; i < m; i++)
        for (int j = 0; j < m; j++)
            for (int k = 0; k < m; k++)
                tmp[i][j] = (tmp[i][j] + A[i][k] * B[k][j]) % MOD;

    std::memcpy(C, tmp, sizeof tmp);
}

void mul(int C[N], int A[N][N], int B[N])
{
    static int tmp[N];
    std::memset(tmp, 0, sizeof tmp);

    for (int i = 0; i < m; i++)
        for (int k = 0; k < m; k++)
            tmp[i] = (tmp[i] + A[i][k] * B[k]) % MOD;

    std::memcpy(C, tmp, sizeof tmp);
}

void fp(int C[N][N], int A[N][N], int b)
{
    static int tmp[N][N];
    std::memset(tmp, 0, sizeof tmp);
    for (int i = 0; i < m; i++) tmp[i][i] = 1;

    while (b)
    {
        if (b & 1) mul(tmp, tmp, A);
        mul(A, A, A);
        b >>= 1;
    }

    std::memcpy(C, tmp, sizeof tmp);
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m >> MOD;
    cin >> X;
    X.insert(X.begin(), ' ');

    for (int i = 2, j = 0; i <= m; i++)
    {
        while (j && X[i] != X[j + 1]) j = pi[j];
        if (X[i] == X[j + 1]) j++;
        pi[i] = j;
    }

    for (int j = 0; j < m; j++)
    {
        for (char c = '0'; c <= '9'; c++)
        {
            int k = j;
            while (k && c != X[k + 1]) k = pi[k];
            if (c == X[k + 1]) k++;
            if (k < m) A[k][j]++;
        }
    }

    fp(A, A, n);
    mul(C, A, start);
    int res = 0;
    for (int i = 0; i < m; i++) res = (res + C[i]) % MOD;
    cout << res << '\n';

    return 0;
}
```

## 组合计数

### 牡牛和牝牛

题目：https://www.acwing.com/problem/content/description/1309/

题解：https://www.acwing.com/solution/content/48077/

实际上$f(i)$表示的是，最后一个是1的位置是$i$的方案数，这才能保证$f(i)$和$f(i - k - 1)$​之前的不重复。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e5 + 5, MOD = 5000011;

int n, K;
int f[N], ps[N];

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    ps[0] = f[0] = 1;

    cin >> n >> K;
    for (int i = 1; i <= n; i++)
    {
        f[i] = ps[std::max(i - K - 1, 0)];
        ps[i] = (ps[i - 1] + f[i]) % MOD;
    }

    cout << ps[n] << '\n';

    return 0;
}
```

### 方程的解

题目：https://www.acwing.com/problem/content/1310/

题解：https://www.acwing.com/solution/content/48085/

这里用了勒让德定理来算组合数。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>

using LL = long long;
using std::cin, std::cout;
using std::vector;

const int N = 1010, MOD = 1000;

int K, x;
bool st[N];
int prime[N], cnt;
int C[N];

auto init = []
{
    for (int i = 2; i < N; i++)
    {
        if (!st[i]) prime[cnt++] = i;
        for (int j = 0; prime[j] * i < N; j++)
        {
            st[prime[j] * i] = true;
            if (i % prime[j] == 0) break;
        }
    }
    return 0;
}();

int Legendre(int n, int p)
{
    int res = 0;
    while (n >= p)
    {
        res += n / p;
        n /= p;
    }
    return res;
}

int fp(int a, int b, int m)
{
    int res = 1;
    a %= m;
    while (b)
    {
        if (b & 1) res = res * a % m;
        a = a * a % m;
        b >>= 1;
    }
    return res;
}

vector<int> mul(vector<int> &A, int b)
{
    vector<int> C;
    int t = 0;
    for (int a : A)
    {
        t += a * b;
        C.push_back(t % 10);
        t /= 10;
    }
    while (t)
    {
        C.push_back(t % 10);
        t /= 10;
    }
    return C;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> K >> x;
    
    int n = fp(x, x, MOD) - 1, m = K - 1;
    for (int i = 0; i < cnt && prime[i] <= n; i++)
    {
        int p = prime[i];
        C[i] = Legendre(n, p) - Legendre(n - m, p) - Legendre(m, p);
    }

    vector<int> res{1};
    for (int i = 0; i < cnt && prime[i] <= n; i++)
        for (int j = 0; j < C[i]; j++)
            res = mul(res, prime[i]);

    for (auto it = res.rbegin(); it != res.rend(); it++) cout << *it;
    cout << '\n';
    
    return 0;
}
```

### 车的放置

题目：https://www.acwing.com/problem/content/description/1311/

题解：https://www.acwing.com/solution/content/17627/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 2010, MOD = 100003;

int fac[N], inv[N];

int fp(int a, int b, int p)
{
	int res = 1;
	while (b)
	{
		if (b & 1) res = LL(res) * a % p;
		a = LL(a) * a % p;
		b >>= 1;
	}
	return res;
}

auto init = []
	{
		fac[0] = inv[0] = 1;
		for (int i = 1; i < N; i++)
		{
			fac[i] = fac[i - 1] * i % MOD;
			inv[i] = fp(fac[i], MOD - 2, MOD);
		}
		return 0;
	}();

int C(int n, int m)
{
	if (n < m) return 0;
	return LL(fac[n]) * inv[m] * inv[n - m] % MOD;
}

int A(int n, int m)
{
	if (n < m) return 0;
	return LL(fac[n]) * inv[n - m] % MOD;
}

int main()
{
	std::ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);

	int a, b, c, d, K; cin >> a >> b >> c >> d >> K;
	int res = 0;
	for (int i = 0; i <= K; i++)
	{
		int t = LL(C(b, i)) * A(a, i) % MOD;
		t = LL(t) * C(d, K - i) * A(a + c - i, K - i) % MOD;
		res = (res + t) % MOD;
	}

	cout << res << '\n';

	return 0;
}
```

### 数三角形

题目：https://www.acwing.com/problem/content/description/1312/

题解：https://www.luogu.com.cn/article/iju3tmkt

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

LL C(int a, int b = 3)
{
    LL res = 1;
    for (int i = 0; i < b; i++) res *= (a - i);
    for (int i = 1; i <= b; i++) res /= i;
    return res;
}

int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int n, m; cin >> m >> n;

    LL res = C((m + 1) * (n + 1));
    res -= C(m + 1) * (n + 1);
    res -= C(n + 1) * (m + 1);

    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
        {
            res -= 2 * (gcd(i, j) - 1) * (n - i + 1) * (m - j + 1);
        }

    cout << res << '\n';

    return 0;
}
```

### 序列统计

题目：https://www.acwing.com/problem/content/description/1314/

题解：https://www.acwing.com/solution/content/8867/

本题要注意，不能把`fp(a, b)`写成`fp(a, b, p)`，不然会超时。可能是因为p是常量的情况下，可以进行一些优化。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int MOD = 1e6 + 3;

int fp(int a, int b)
{
    int res = 1;
    while (b)
    {
        if (b & 1) res = LL(res) * a % MOD;
        a = LL(a) * a % MOD;
        b >>= 1;
    }
    return res;
}

int C(int a, int b)
{
    int res = 1, inv = 1;
    for (int i = 1; i <= b; i++)
    {
        res = LL(res) * (a - i + 1) % MOD;
        inv = LL(inv) * i % MOD;
    }
    inv = fp(inv, MOD - 2);
    res = LL(res) * inv % MOD;
    return res;
}

int Lucas(int a, int b)
{
    if (a < MOD && b < MOD) return C(a, b);
    return LL(C(a % MOD, b % MOD)) * Lucas(a / MOD, b / MOD) % MOD;
}

void solve()
{
    int n, l, r; cin >> n >> l >> r;
    int m = r - l;
    int res = Lucas(m + n + 1, m + 1) - 1;
    cout << (res + MOD) % MOD << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int t; cin >> t;
    while (t--)
        solve();

    return 0;
}
```

### 网格

题目：https://www.acwing.com/problem/content/description/1317/

题解：

https://www.acwing.com/solution/content/46130/

https://www.acwing.com/solution/content/260891/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>

using LL = long long;
using std::cin, std::cout;
using std::vector;

const int N = 1e4 + 5;

bool st[N];
int prime[N], cnt;

auto init = []
    {
        for (int i = 2; i < N; i++)
        {
            if (!st[i])
            {
                prime[cnt++] = i;
            }
            for (int j = 0; prime[j] * i < N; j++)
            {
                st[prime[j] * i] = true;
                if (i % prime[j] == 0) break;
            }
        }
        return 0;
    }();

int C[N];

int Legendre(int n, int p)
{
    int res = 0;
    while (n >= p)
    {
        res += n / p;
        n /= p;
    }
    return res;
}

vector<int> mul(vector<int>& A, int b)
{
    vector<int> C;
    int t = 0;
    for (int a : A)
    {
        t += a * b;
        C.push_back(t % 10);
        t /= 10;
    }
    while (t)
    {
        C.push_back(t % 10);
        t /= 10;
    }
    return C;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int n, m; cin >> n >> m;
    for (int i = 0; i < cnt && prime[i] <= n + m; i++)
    {
        int p = prime[i];
        C[i] = Legendre(n + m, p) - Legendre(m, p) - Legendre(n + 1, p);
    }

    vector<int> res{ 1 };
    for (int i = 0; i < cnt && prime[i] <= n + m; i++)
        for (int j = 0; j < C[i]; j++)
            res = mul(res, prime[i]);
    res = mul(res, n + 1 - m);

    for (int i = res.size() - 1; i >= 0; i--) cout << res[i];
    cout << '\n';

    return 0;
}
```

### 有趣的数列

题目：https://www.acwing.com/problem/content/description/1318/

题解：https://www.acwing.com/solution/content/133856/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 2e6 + 5;

bool st[N];
int prime[N], cnt;

auto init = []
    {
        for (int i = 2; i < N; i++)
        {
            if (!st[i])
            {
                prime[cnt++] = i;
            }
            for (int j = 0; LL(prime[j]) * i < N; j++)
            {
                st[prime[j] * i] = true;
                if (i % prime[j] == 0) break;
            }
        }
        return 0;
    }();


int Legendre(int n, int p)
{
    int res = 0;
    while (n >= p)
    {
        res += n / p;
        n /= p;
    }
    return res;
}

int fp(int a, int b, int p)
{
    int res = 1;
    while (b)
    {
        if (b & 1) res = LL(res) * a % p;
        a = LL(a) * a % p;
        b >>= 1;
    }
    return res;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int n, m; cin >> n >> m;
    int res = 1;
    for (int i = 0; i < cnt && prime[i] <= n * 2; i++)
    {
        int p = prime[i];
        int c = Legendre(n * 2, p) - Legendre(n, p) - Legendre(n + 1, p);
        res = LL(res) * fp(p, c, m) % m;
    }

    cout << res << '\n';

    return 0;
}
```

## 高斯消元

### 球形空间产生器

题目：https://www.acwing.com/problem/content/description/209/

题解：https://www.acwing.com/solution/content/48342/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 15;
const double eps = 1e-5;

int n;
double A[N][N], B[N][N];

int Gauss(int n, double A[N][N])
{
    int r = 0, c = 0;
    for (; c < n; c++)
    {
        int t = r;
        for (int i = r + 1; i < n; i++)
            if (std::abs(A[i][c]) > std::abs(A[t][c]))
                t = i;

        if (std::abs(A[t][c]) < eps) continue;

        for (int j = c; j <= n; j++) std::swap(A[r][j], A[t][j]);
        for (int j = n; j >= c; j--) A[r][j] /= A[r][c];

        for (int i = r + 1; i < n; i++)
            if (std::abs(A[i][c]) > eps)
                for (int j = n; j >= c; j--) 
                    A[i][j] -= A[i][c] * A[r][j];

        r++;
    }

    for (int i = n - 1; i >= 1; i--)  // i必须从n-1开始倒序遍历，而不能从1开始正序遍历
        for (int j = 0; j < i; j++)
            A[j][n] -= A[i][n] * A[j][i];

    return 0;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    for (int i = 0; i < n + 1; i++)
        for (int j = 0; j < n; j++) 
            cin >> A[i][j];
    
    for (int i = 1; i < n + 1; i++)
        for (int j = 0; j < n; j++)
        {
            B[i - 1][j] = (A[i][j] - A[0][j]) * 2;
            B[i - 1][n] += A[i][j] * A[i][j] - A[0][j] * A[0][j];
        }

    Gauss(n, B);

    for (int i = 0; i < n; i++) printf("%.3lf ", B[i][n]);
    puts("");

    return 0;
}
```

### 开关问题

题目：https://www.acwing.com/problem/content/description/210/

题解：https://www.acwing.com/solution/content/157080/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 35;

int n;
int A[N];

int Gauss()
{
    int r = 0, c = 0;
    for (; c < n; c++)
    {
        int t = r;
        for (int i = r; i < n; i++)
            if (A[i] >> c & 1)
            {
                t = i;
                break;
            }

        if ((A[t] >> c & 1) == 0) continue;

        std::swap(A[r], A[t]);

        for (int i = r + 1; i < n; i++)
            if (A[i] >> c & 1)
            {
                A[i] ^= A[r];
            }

        r++;
    }

    for (int i = r; i < n; i++)
        if (A[i])
            return -1;

    return 1 << (n - r);
}

void solve()
{
    cin >> n;
    for (int i = 0; i < n; i++) A[i] = 1 << i;
    for (int i = 0; i < n; i++)
    {
        int t; cin >> t;
        A[i] ^= t << (n + 1);
    }
    for (int i = 0; i < n; i++)
    {
        int t; cin >> t;
        A[i] ^= t << (n + 1);
    }
    int a, b;
    while (cin >> a >> b, a || b)
    {
        A[b - 1] |= 1 << (a - 1);  // 这里必须使用`|=`，不能使用`^=`，可能是因为有重复的输入
    }

    int res = Gauss();
    if (res == -1) cout << "Oh,it's impossible~!!" << '\n';
    else cout << res << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int t; cin >> t;
    while (t--)
        solve();

    return 0;
}
```

## 容斥原理

### Devu和鲜花

题目：https://www.acwing.com/problem/content/description/216/

题解：https://www.acwing.com/solution/content/13666/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 25, MOD = 1e9 + 7;

int n;
LL m, A[N];

int fp(int a, int b)
{
	int res = 1;
	while (b)
	{
		if (b & 1) res = LL(res) * a % MOD;
		a = LL(a) * a % MOD;
		b >>= 1;
	}
	return res;
}

int C(int a, int b)
{
	if (a < b) return 0;

	int res = 1, inv = 1;
	for (int i = a, j = 1; j <= b; j++, i--)
	{
		res = LL(res) * i % MOD;
		inv = LL(inv) * j % MOD;
	}
	res = LL(res) * fp(inv, MOD - 2) % MOD;
	return res;
}

int Lucas(LL a, int b)
{
	if (a < b) return 0;  // 不可以省略
	if (a < MOD && b < MOD) return C(a, b);
	return LL(C(a % MOD, b % MOD)) * Lucas(a / MOD, b / MOD) % MOD;
}

int mod(LL a, int m)
{
	return (a % m + m) % m;
}

int main()
{
	std::ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);

	cin >> n >> m;
	for (int i = 0; i < n; i++) cin >> A[i];

	int res = 0;
	for (int i = 0; i < (1 << n); i++)
	{
		LL t = 0;
		int cnt = 0;
		for (int j = 0; j < n; j++)
			if (i >> j & 1)
			{
				t += A[j] + 1;
				cnt++;
			}

		if (cnt % 2) res = mod(res - Lucas(m + n - 1 - t, n - 1), MOD);
		else res = (res + Lucas(m + n - 1 - t, n - 1)) % MOD;

	}

	cout << res << '\n';

	return 0;
}
```

### 破译密码

题目：https://www.acwing.com/problem/content/description/217/

题解：https://www.acwing.com/solution/content/17858/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <bitset>

using std::cin, std::cout;
using LL = long long;

const int N = 5e4 + 10;

std::bitset<N> st;
int prime[N], cnt;
int mobius[N], ps[N];

void sieve(int n)
{
    mobius[1] = 1;
    for (int i = 2; i <= n; i++)
    {
        if (!st[i])
        {
            mobius[i] = -1;
            prime[cnt++] = i;
        }
        for (int j = 0; LL(prime[j]) * i <= n; j++)
        {
            int com = prime[j] * i;
            st[com] = true;
            if (i % prime[j] == 0)
            {
                mobius[com] = 0;
                break;
            }
            mobius[com] = -1 * mobius[i];
        }
    }

    for (int i = 1; i <= n; i++) ps[i] = ps[i - 1] + mobius[i];
}

void solve()
{
    int a, b, d; cin >> a >> b >> d;
    a /= d, b /= d;
    int n = std::min(a, b);

    LL res = 0;
    for (int l = 1, r = 1; l <= n; l = r + 1)
    {
        r = std::min({n, a / (a / l), b / (b / l)});
        res += LL(ps[r] - ps[l - 1]) * (a / l) * (b / l);
    }
    cout << res << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    sieve(N - 1);

    int T; cin >> T;
    while (T--)
        solve();

    return 0;
}
```

## 概率与数学期望

### 绿豆蛙的归宿

题目：https://www.acwing.com/problem/content/description/219/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

const int N = 1e5 + 10, M = 2e5 + 10;

int n, m;
int H[N], idx;
struct EdgeNode
{
    int v, w, n;
} E[M];

void addE(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
}

double f[N];
int out[N];

double DFS(int u)
{
    if (f[u] > 0) return f[u];

    double res = 0;
    for (int p = H[u]; p; p = E[p].n)
    {
        int v = E[p].v, w = E[p].w;
        res += (DFS(v) + w) / out[u];
    }
    return res;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b, c; cin >> a >> b >> c;
        addE(a, b, c);
        out[a]++;
    }

    printf("%.2lf\n", DFS(1));

    return 0;
}
```

### 扑克牌

题目：https://www.acwing.com/problem/content/description/220/

题解：https://www.acwing.com/solution/content/162833/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

const int N = 15;
const double INF = 54 * 54 + 100;

int A, B, C, D;
double f[N][N][N][N][5][5];

double DFS(int a, int b, int c, int d, int x, int y)
{
    double &v = f[a][b][c][d][x][y];
    if (v >= 0) return v;

    int as = a + (x == 1) + (y == 1);
    int bs = b + (x == 2) + (y == 2);
    int cs = c + (x == 3) + (y == 3);
    int ds = d + (x == 4) + (y == 4);

    if (as >= A && bs >= B && cs >= C && ds >= D) return v = 0;

    int sum = as + bs + cs + ds;
    if (sum == 54) return v = INF;

    v = 1;
    if (a < 13) v += double(13 - a) / (54 - sum) * DFS(a + 1, b, c, d, x, y);
    if (v > 54) return v = INF;
    if (b < 13) v += double(13 - b) / (54 - sum) * DFS(a, b + 1, c, d, x, y);
    if (v > 54) return v = INF;
    if (c < 13) v += double(13 - c) / (54 - sum) * DFS(a, b, c + 1, d, x, y);
    if (v > 54) return v = INF;
    if (d < 13) v += double(13 - d) / (54 - sum) * DFS(a, b, c, d + 1, x, y);
    if (v > 54) return v = INF;

    if (x == 0)
    {
        double t = INF;
        for (int i = 1; i <= 4; i++) t = std::min(t, DFS(a, b, c, d, i, y));
        v += 1 / double(54 - sum) * t;
        if (v > 54) return v = INF;
    }
    if (y == 0)
    {
        double t = INF;
        for (int i = 1; i <= 4; i++) t = std::min(t, DFS(a, b, c, d, x, i));
        v += 1 / double(54 - sum) * t;
        if (v > 54) return v = INF;
    }

    return v;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    memset(f, -1, sizeof f);

    cin >> A >> B >> C >> D;

    double res = DFS(0, 0, 0, 0, 0, 0);
    if (res > 54) res = -1;

    printf("%.3lf\n", res);

    return 0;
}
```

## 博弈论

### 移棋子游戏

题目：https://www.acwing.com/problem/content/description/1321/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <unordered_set>

using std::cin, std::cout;
using LL = long long;

const int N = 2010, M = 6010;

int n, m, k;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M]; int idx;

void addE(int a, int b)
{
    E[++idx] = {b, H[a]}, H[a] = idx;
}

int f[N];

int SG(int x)
{
    if (f[x] >= 0) return f[x];

    std::unordered_set<int> hs;
    for (int p = H[x]; p; p = E[p].n)
    {
        int v = E[p].v;
        hs.insert(SG(v));
    }

    for (int i = 0; ; i++)
        if (hs.count(i) == 0)
            return f[x] = i;

    return -1;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m >> k;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        addE(a, b);
    }

    int res = 0;
    memset(f, -1, sizeof f);
    for (int i = 0; i < k; i++)
    {
        int x; cin >> x;
        res ^= SG(x);
    }

    cout << (res ? "win" : "lose") << '\n';

    return 0;
}
```

### 取石子

题目：https://www.acwing.com/problem/content/description/1323/

题解：

[y总的做法](https://www.acwing.com/solution/content/26214/)，在证明上似乎有疏漏。

[分类讨论](https://www.acwing.com/solution/content/76900/)，这个做法很高明。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

void solve()
{
    int n; cin >> n;
    int cnt = 0, op = 0;
    for (int i = 0; i < n; i++)
    {
        int a; cin >> a;
        if (a == 1) cnt++;
        else op += a + 1;
    }
    if (op > 0) op -= 1;

    if (cnt == n || (cnt == n - 1 && op == 2))
    {
        cout << (cnt % 3 ? "YES" : "NO") << '\n';
    }
    else
    {
        cout << (cnt % 2 || op % 2 ? "YES" : "NO") << '\n';
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int T; cin >> T;
    while (T--)
        solve();

    return 0;
}
```

### 取石子游戏

题目：https://www.acwing.com/problem/content/description/1324/

题解：https://www.acwing.com/solution/content/26286/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

const int N = 1010;

int n, A[N];
int L[N][N], R[N][N];

void solve()
{
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> A[i];

    for (int len = 1; len <= n; len++)
        for (int i = 1; i + len - 1 <= n; i++)
        {
            int j = i + len - 1;
            if (len == 1)
            {
                L[i][j] = R[i][j] = A[i];
            }
            else
            {
                int x = A[j];
                int l = L[i][j - 1], r = R[i][j - 1];

                if (r == x) L[i][j] = 0;
                else if ((x < l && x < r) ||
                         (x > l && x > r)) L[i][j] = x;
                else if (l > r) L[i][j] = x - 1;
                else L[i][j] = x + 1;

                x = A[i];
                l = L[i + 1][j], r = R[i + 1][j];
                if (l == x) R[i][j] = 0;
                else if ((x < l && x < r) ||
                         (x > l && x > r)) R[i][j] = x;
                else if (r > l) R[i][j] = x - 1;
                else R[i][j] = x + 1;
            }
        }

    if (n == 1) cout << 1 << '\n';
    else cout << int(A[1] != L[2][n]) << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int T; cin >> T;
    while (T--)
        solve();

    return 0;
}
```

