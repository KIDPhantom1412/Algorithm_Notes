# 高级数据结构

## 并查集

### 格子游戏

题目：https://www.acwing.com/problem/content/description/1252/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 4e4 + 10;

int n, m;
int P[N];

int Find(int x)
{
    if (x != P[x]) P[x] = Find(P[x]);
    return P[x];
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;

    for (int i = 1; i <= n * n; i++) P[i] = i;

    for (int i = 1; i <= m; i++)
    {
        int x, y; cin >> x >> y;
        char d; cin >> d;
        int a = (x - 1) * n + y;
        int b = d == 'D' ? a + n : a + 1;
        a = Find(a), b = Find(b);
        if (a == b)
        {
            cout << i << '\n';
            return 0;
        }
        P[a] = b;
    }

    cout << "draw" << '\n';

    return 0;
}
```

### 搭配购买

题目：https://www.acwing.com/problem/content/description/1254/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e4 + 10;

int n, m, vol;
int V[N], W[N];
int P[N];

void InitUFS()
{
    for (int i = 1; i <= n; i++) P[i] = i;
}

int Find(int x)
{
    if (x != P[x]) P[x] = Find(P[x]);
    return P[x];
}

int f[N];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m >> vol;
    InitUFS();
    for (int i = 1; i <= n; i++) cin >> V[i] >> W[i];
    for (int i = 1; i <= m; i++)
    {
        int a, b; cin >> a >> b;
        a = Find(a), b = Find(b);
        if (a != b)
        {
            V[a] += V[b];
            W[a] += W[b];
            P[b] = a;
        }
    }

    for (int i = 1; i <= n; i++)
        if (i == P[i])
            for (int j = vol; j >= V[i]; j--)
                f[j] = max(f[j], f[j - V[i]] + W[i]);

    cout << f[vol] << '\n';

    return 0;
}
```

### 程序自动分析

题目：https://www.acwing.com/problem/content/description/239/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <unordered_map>

using namespace std;

const int N = 1e5 + 10;

int n, m;
struct Node
{
    int a, b;
} Q[N]; int cnt;

int P[N * 2];

int Find(int x)
{
    if (x != P[x]) P[x] = Find(P[x]);
    return P[x];
}

unordered_map<int, int> S;

int Get(int x)
{
    if (S.count(x)) return S[x];
    else return S[x] = ++n;
}

void Init()
{
    n = cnt = 0;
    for (int i = 1; i <= m * 2; i++) P[i] = i;
    S.clear();
}

void Solve()
{
    cin >> m;

    Init();

    for (int i = 1; i <= m; i++)
    {
        int a, b, c; cin >> a >> b >> c;
        a = Get(a), b = Get(b);
        if (c == 1)
        {
            a = Find(a), b = Find(b);
            P[a] = b;
        }
        else Q[++cnt] = {a, b};
    }

    for (int i = 1; i <= cnt; i++)
    {
        int a = Q[i].a, b = Q[i].b;
        a = Find(a), b = Find(b);
        if (a == b)
        {
            cout << "NO" << '\n';
            return;
        }
    }

    cout << "YES" << '\n';
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    
    int t; cin >> t;
    while (t--) Solve();

    return 0;
}
```

### 银河英雄传说

题目：https://www.acwing.com/problem/content/description/240/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 3e4 + 10;

int m;
int P[N], cnt[N], dist[N];

int Find(int x)
{
    if (x != P[x])
    {
        int root = Find(P[x]);
        dist[x] += dist[P[x]];
        P[x] = root;
    }

    return P[x];
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    for (int i = 1; i < N; i++)
    {
        P[i] = i;
        cnt[i] = 1;
    }

    cin >> m;
    while (m--)
    {
        char op; cin >> op;
        int a, b; cin >> a >> b;
        if (op == 'M')
        {
            a = Find(a), b = Find(b);
            if (a != b)
            {
                P[a] = b;
                dist[a] = cnt[b];
                cnt[b] += cnt[a];
            }
        }
        else
        {
            int pa = Find(a), pb = Find(b);
            if (pa == pb) 
            {
                if (a == b) cout << 0 << '\n';
                else cout << std::abs(dist[a] - dist[b]) - 1 << '\n';
            }
            else cout << -1 << '\n';
        }
    }

    return 0;
}
```

### 奇偶游戏

题目：https://www.acwing.com/problem/content/description/241/

题解：https://www.acwing.com/solution/content/29308/

**带权并查集：**

模2加（异或）系统中的负元是自身，所以加和减是等价的。这里用$dist[x] = 1$表示$x$和父节点的奇偶性是不同的，用$dist[x] = 0$表示$x$和父节点的奇偶性是相同的。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <unordered_map>

using namespace std;

const int N = 1e4 + 10;

int n, m;
int P[N], dist[N];

void InitUFS()
{
    for (int i = 0; i < N; i++) P[i] = i;
}

int Find(int x)
{
    if (x != P[x])
    {
        int root = Find(P[x]);
        dist[x] = dist[x] ^ dist[P[x]];
        P[x] = root;
    }
    return P[x];
}

unordered_map<int, int> S;

int Get(int x)
{
    if (S.count(x)) return S[x];
    else return S[x] = ++n;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    InitUFS();

    cin >> n >> m;
    n = 0;

    for (int i = 1; i <= m; i++)
    {
        int a, b; cin >> a >> b;
        a = Get(a - 1), b = Get(b);
        int pa = Find(a), pb = Find(b);
        string type; cin >> type;
        if (type.size() == 3)
        {
            if (pa == pb)
            {
                if (dist[a] ^ dist[b] == 0)
                {
                    cout << i - 1 << '\n';
                    return 0;
                }
            }
            else
            {
                dist[pa] = dist[a] ^ dist[b] ^ 1;
                P[pa] = pb;
            }
        }
        else
        {
            if (pa == pb)
            {
                if (dist[a] ^ dist[b] == 1)
                {
                    cout << i - 1 << '\n';
                    return 0;
                }
            }
            else
            {
                dist[pa] = dist[a] ^ dist[b];
                P[pa] = pb;
            }
        }
    }

    cout << m << '\n';

    return 0;
}
```

**扩域：**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <unordered_map>

using namespace std;

const int N = 1e4 + 10;

int n, m;
int P[N * 2];

void InitUFS()
{
    for (int i = 0; i < N * 2; i++) P[i] = i;
}

int Find(int x)
{
    if (x != P[x]) P[x] = Find(P[x]);
    return P[x];
}

unordered_map<int, int> S;

int Get(int x)
{
    if (!S.count(x))
    {
        S[x] = n;
        n += 2;
    }
    return S[x];
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    InitUFS();

    cin >> n >> m;
    n = 0;

    for (int i = 1; i <= m; i++)
    {
        int a, b; cin >> a >> b;
        a = Get(a - 1), b = Get(b);
        string type; cin >> type;
        if (type[0] == 'o')
        {
            if (Find(a) == Find(b))
            {
                cout << i - 1 << '\n';
                return 0;
            }
            else
            {
                P[Find(a)] = Find(b + 1);
                P[Find(a + 1)] = Find(b);
            }
        }
        else
        {
            if (Find(a) == Find(b + 1))
            {
                cout << i - 1 << '\n';
                return 0;
            }
            else
            {
                P[Find(a)] = Find(b);
                P[Find(a + 1)] = Find(b + 1);
            }
        }
    }

    cout << m << '\n';
    return 0;
}
```

## 树状数组

### 楼兰图腾

题目：https://www.acwing.com/problem/content/description/243/

题解：https://www.acwing.com/solution/content/13818/

注意评论区说的优化方法，因为数据$y$是$1$到$n$的一个排列，所以当求出小于$y_i$的左侧的点的个数时，右侧点的个数也能直接算出。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

const int N = 2e5 + 10;

int n;
int tr[N];

int lowbit(int x)
{
    return x & -x;
}

void update(int x, int d)
{
    for (int i = x; i <= n; i += lowbit(i))
        tr[i] += d;
}

int sum(int x)
{
    int res = 0;
    for (int i = x; i >= 1; i -= lowbit(i))
        res += tr[i];
    return res;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;

    LL resA = 0, resV = 0;
    for (int i = 1; i <= n; i++)
    {
        int h; cin >> h;
        int ll = sum(h - 1), lr = h - 1 - ll;
        resA += LL(ll) * lr;
        int hl = sum(n) - sum(h), hr = n - h - hl;
        resV += LL(hl) * hr;
        update(h, 1);
    }

    cout << resV << ' ' << resA << '\n';

    return 0;
}
```

### 一个简单的整数问题

题目：https://www.acwing.com/problem/content/description/248/

**差分+树状数组：**

本题并不会爆int；还有本解法中采用了快速初始化树状数组的方法，但性能相比`update`没有提升，所以不建议使用。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

const int N = 1e5 + 10;

int n, m;
int A[N];
int tr[N];

void update(int x, int d)
{
    for (int i = x; i <= n; i += i & -i)
        tr[i] += d;
}

int sum(int x)
{
    int res = 0;
    for (int i = x; i >= 1; i -= i & -i)
        res += tr[i];
    return res;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> A[i];
    for (int i = 1; i <= n; i++) // update(i, A[i] - A[i - 1])
    {
        tr[i] = A[i] - A[i - 1];
        int l = i - (i & -i) + 1;
        for (int j = i - 1; j >= l; j -= j & -j)
            tr[i] += tr[j];
    }
    for (int i = 0; i < m; i++)
    {
        char op; cin >> op;
        if (op == 'Q')
        {
            int x; cin >> x;
            cout << sum(x) << '\n';
        }
        else
        {
            int l, r, d; cin >> l >> r >> d;
            update(l, d), update(r + 1, -d);
        }
    }

    return 0;
}
```

### 一个简单的整数问题2

题目：https://www.acwing.com/problem/content/description/244/

题解：https://www.acwing.com/solution/content/44886/

这里用重载的方法封装了区间和上的树状数组。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

const int N = 1e5 + 10;

int n, m;
int A[N];

LL tr_d[N], tr_id[N];

void update(LL tr[], int x, LL d)
{
    for (int i = x; i <= n; i += i & -i)
        tr[i] += d;
}

LL sum(LL tr[], int x)
{
    LL res = 0;
    for (int i = x; i >= 1; i -= i & -i)
        res += tr[i];
    return res;
}

void update(int l, int r, LL d)
{
    update(tr_d, l, d), update(tr_d, r + 1, -d);
    update(tr_id, l, l * d), update(tr_id, r + 1, (r + 1) * -d);
}

LL sum(int x)
{
    return (x + 1) * sum(tr_d, x) - sum(tr_id, x);
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> A[i];
    for (int i = 1; i <= n; i++)
    {
        LL d = A[i] - A[i - 1];
        update(tr_d, i, d);
        update(tr_id, i, i * d);
    }

    for (int i = 0; i < m; i++)
    {
        char op; cin >> op;
        if (op == 'Q')
        {
            int l, r; cin >> l >> r;
            cout << sum(r) - sum(l - 1) << '\n';
        }
        else
        {
            int l, r, d; cin >> l >> r >> d;
            update(l, r, d);
        }
    }

    return 0;
}
```

### 谜一样的牛

题目：https://www.acwing.com/problem/content/description/245/

题解：https://www.acwing.com/solution/content/3449/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

const int N = 1e5 + 10;

int n, A[N];
int H[N];

int tr[N];

void update(int x, int d)
{
    for (int i = x; i <= n; i += i & -i)
        tr[i] += d;
}

int sum(int x)
{
    int res = 0;
    for (int i = x; i >= 1; i -= i & -i)
        res += tr[i];
    return res;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    for (int i = 2; i <= n; i++) cin >> A[i];
    for (int i = 1; i <= n; i++) update(i, 1);

    for (int i = n; i >= 1; i--)
    {
        int l = 1, r = n;
        while (l < r)
        {
            int mid = l + r >> 1;
            if (sum(mid) >= A[i] + 1) r = mid;
            else l = mid + 1;
        }
        H[i] = l;
        update(l, -1);
    }

    for (int i = 1; i <= n; i++) cout << H[i] << '\n'; 

    return 0;
}
```

## 线段树

### 最大数

题目：https://www.acwing.com/problem/content/description/1277/

题解：https://www.acwing.com/solution/content/61919/

线段树维护区间的最大值。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

const int N = 2e5 + 10;

int n, m, p;

struct STNode
{
    int l, r;
    int v;
} tr[N * 4];

void pushup(int u)
{
    tr[u].v = std::max(tr[u * 2].v, tr[u * 2 + 1].v);
}

void build(int u, int l, int r)
{
    tr[u] = {l, r};
    if (l != r)
    {
        int mid = l + r >> 1;
        build(u * 2, l, mid), build(u * 2 + 1, mid + 1, r);
    }
}

void update(int u, int x, int d)
{
    if (tr[u].l == x && tr[u].r == x) tr[u].v += d;
    else
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if (x <= mid) update(u * 2, x, d);
        else update(u * 2 + 1, x, d);
        pushup(u);
    }
}

int query(int u, int l, int r)
{
    if (tr[u].l >= l && tr[u].r <= r) return tr[u].v;

    int mid = tr[u].l + tr[u].r >> 1;
    int lv = 0, rv = 0;
    if (l <= mid) lv = query(u * 2, l, r);
    if (r > mid) rv = query(u * 2 + 1, l ,r);
    return std::max(lv, rv);
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> m >> p;

    build(1, 1, m);

    int a = 0;
    for (int i = 0; i < m; i++)
    {
        char op; cin >> op;
        if (op == 'Q')
        {
            int l; cin >> l;
            a = query(1, n - l + 1, n);
            cout << a << '\n';
        }
        else
        {
            int t; cin >> t;
            update(1, ++n, (LL(t) + a) % p);
        }
    }

    return 0;
}
```

### 你能回答这些问题吗

题目：https://www.acwing.com/problem/content/description/246/

题解：https://www.acwing.com/solution/content/110854/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using std::max;
using LL = long long;

const int N = 5e5 + 10;

int n, m;
int A[N];

struct STNode
{
    int l, r;
    int mx, lmx, rmx, s;
} tr[N * 4];

void pushup(STNode &u, STNode &l, STNode &r)
{
    u.mx = max({l.mx, r.mx, l.rmx + r.lmx});
    u.lmx = max(l.lmx, l.s + r.lmx);
    u.rmx = max(l.rmx + r.s, r.rmx);
    u.s = l.s + r.s;
}

void pushup(int u)
{
    pushup(tr[u], tr[u * 2], tr[u * 2 + 1]);
}

void build(int u, int l, int r)
{
    if (l == r) tr[u] = {l, r, A[l], A[l], A[l], A[l]};
    else
    {
        tr[u].l = l, tr[u].r = r;
        int mid = l + r >> 1;
        build(u * 2, l, mid), build(u * 2 + 1, mid + 1, r);
        pushup(u);
    }
}

void update(int u, int x, int v)
{
    if (tr[u].l == x && tr[u].r == x)
    {
        tr[u] = {x, x, v, v, v, v};
    }
    else
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if (x <= mid) update(u * 2, x, v);
        else update(u * 2 + 1, x, v);
        pushup(u);
    }
}

STNode query(int u, int l, int r)
{
    if (tr[u].l >= l && tr[u].r <= r) return tr[u];
    else
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if (r <= mid) return query(u * 2, l, r);
        else if (l > mid) return query(u * 2 + 1, l, r);
        else
        {
            STNode ln = query(u * 2, l, r);
            STNode rn = query(u * 2 + 1, l, r);
            STNode res;
            pushup(res, ln, rn);
            return res;
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> A[i];
    build(1, 1, n);

    for (int i = 0; i < m; i++)
    {
        int op, x, y; cin >> op >> x >> y;
        if (op == 1)
        {
            if (x > y) std::swap(x, y);
            auto res = query(1, x, y);
            cout << res.mx << '\n';
        }
        else update(1, x, y);
    }

    return 0;
}
```

### 区间最大公约数

题目：https://www.acwing.com/problem/content/description/247/

题解：https://www.acwing.com/solution/content/42739/

该题有两个细节：一是，`build(1, 1, n + 1)`要为了`update(1, r + 1, -d)`多开一位，这一点和树状数组是不同的。二是，查询时要考虑到`l == r`的特殊情况。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

const int N = 5e5 + 10;

int n, m;
LL A[N];
struct STNode
{
    int l, r;
    LL v, s;
} tr[N * 4];

LL GCD(LL a, LL b)
{
    return b ? GCD(b, a % b) : a;
}

void pushup(STNode &u, STNode &l, STNode &r)
{
    u.v = GCD(l.v, r.v);
    u.s = l.s + r.s;
}

void pushup(int u)
{
    pushup(tr[u], tr[u * 2], tr[u * 2 + 1]);
}

void build(int u, int l, int r)
{
    if (l == r)
    {
        LL d = A[l] - A[l - 1];
        tr[u] = {l, r, d, d};
    }
    else
    {
        tr[u] = {l, r};
        int mid = l + r >> 1;
        build(u * 2, l, mid), build(u * 2 + 1, mid + 1, r);
        pushup(u);
    }
}

void update(int u, int x, LL d)
{
    if (tr[u].l == x && tr[u].r == x)
    {
        tr[u].v += d;
        tr[u].s += d;
    }
    else
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if (x <= mid) update(u * 2, x, d);
        else update(u * 2 + 1, x, d);
        pushup(u);
    }
}

STNode query(int u, int l, int r)
{
    if (tr[u].l >= l && tr[u].r <= r) return tr[u];
    else
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if      (r <= mid) return query(u * 2, l, r);
        else if (l > mid) return query(u * 2 + 1, l, r);
        else
        {
            STNode L = query(u * 2, l, r);
            STNode R = query(u * 2 + 1, l, r);
            STNode res;
            pushup(res, L, R);
            return res;
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> A[i];

    build(1, 1, n + 1);

    for (int i = 0; i < m; i++)
    {
        char op; cin >> op;
        int l, r; cin >> l >> r;
        if (op == 'C')
        {
            LL d; cin >> d;
            update(1, l, d), update(1, r + 1, -d);
        }
        else
        {
            STNode tri = query(1, 1, l);
            if (l == r) cout << tri.s << '\n';
            else
            {
                STNode dif = query(1, l + 1, r);
                cout << std::abs(GCD(tri.s, dif.v)) << '\n';
            }
        }
    }

    return 0;
}
```

### 一个简单的整数问题2

题目：https://www.acwing.com/problem/content/description/244/

关于lazy-tag线段树，题解中没什么太好的讲解。去看《算法竞赛》即可。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

const int N = 1e5 + 10;

int n, m;
int A[N];
struct STNode
{
    int l, r;
    LL s, t;
} tr[N * 4];

void pushUp(int u)
{
    tr[u].s = tr[u * 2].s + tr[u * 2 + 1].s;
}

void pushDown(int u)
{
    if (tr[u].t)
    {
        STNode &L = tr[u * 2], &R = tr[u * 2 + 1];
        L.s += (L.r - L.l + 1) * tr[u].t, L.t += tr[u].t;
        R.s += (R.r - R.l + 1) * tr[u].t, R.t += tr[u].t;
        tr[u].t = 0;
    }
}

void build(int u, int l, int r)
{
    if (l == r)
    {
        tr[u] = {l, r, A[l], 0};
    }
    else
    {
        tr[u] = {l, r};
        int mid = l + r >> 1;
        build(u * 2, l, mid), build(u * 2 + 1, mid + 1, r);
        pushUp(u);
    }
}

void update(int u, int l, int r, LL d)
{
    if (tr[u].l >= l && tr[u].r <= r)
    {
        tr[u].t += d;
        tr[u].s += (tr[u].r - tr[u].l + 1) * d;
    }
    else
    {
        pushDown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid) update(u * 2, l, r, d);
        if (r > mid) update(u * 2 + 1, l, r, d);
        pushUp(u);
    }
}

LL query(int u, int l, int r)
{
    if (tr[u].l >= l && tr[u].r <= r)
    {
        return tr[u].s;
    }
    else
    {
        pushDown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        LL ls = 0, rs = 0;
        if (l <= mid) ls = query(u * 2, l, r);
        if (r > mid) rs = query(u * 2 + 1, l, r);
        return ls + rs;
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> A[i];
    build(1, 1, n);
    for (int i = 0; i < m; i++)
    {
        char op; cin >> op;
        int l, r; cin >> l >> r;
        if (op == 'C')
        {
            int d; cin >> d;
            update(1, l, r, d);
        }
        else
        {
            cout << query(1, l, r) << '\n';
        }
    }

    return 0;
}
```



### 亚特兰蒂斯

题目：https://www.acwing.com/problem/content/description/249/

题解：https://www.acwing.com/solution/content/135911/

这是一个扫描线问题，叫做矩阵面积和。

本题的线段树和普通线段树不同：

1. 我们按所有的y轴上出现的值分割成一个个最小的片段，用y离散化之后的片段左端点的下标代表这个片段，这是线段树的`l, r`所代表的含义，`l`到`r`的线段表示`l`到`r`的片段，故线段对应的长度为`ys[r + 1] - ys[l]`；
2. 扫描线所遇到的某个矩形的第一个边，就将这个边所对应的所有线段的cnt+1，如果是该矩形的第二个边就-1；并且cnt是不往子节点更新的，会在第一次`tr[u].l >= l && tr[u].r <= r`的时候更新cnt；
3. 虽然涉及到区间修改，但不需要pushDown；因为一条边所对应的若干线段的是固定的，因此不管是cnt+1还是cnt-1，矩阵的两条边对应的都是固定若干线段；
4. len表示以自己为根节点的树上所有的扫描线的长度（不含重复的线段）；更新的时候总是自底向上更新，如果cnt>0则说明该线段对应的片段都在当前扫描线中，否则应该等于子节点的长度和。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>

using std::cin, std::cout;
using std::vector;
using LL = long long;

const int N = 1e4 + 10;

int T;
int n;

struct ScanLine
{
    double x, y1, y2;
    int w;

    bool operator<(const ScanLine &ct)
    {
        return x < ct.x;
    }
} SL[N * 2];

vector<double> ys;

int find(double y)
{
    return std::lower_bound(ys.begin(), ys.end(), y) - ys.begin();
}

struct STNode
{
    int l, r;
    int cnt;
    double len;
} tr[N * 8];

void pushUp(int u)
{
    STNode &L = tr[u * 2], &R = tr[u * 2 + 1];
    if (tr[u].cnt) tr[u].len = ys[tr[u].r + 1] - ys[tr[u].l];
    else tr[u].len = L.len + R.len;
}

void build(int u, int l, int r)
{
    if (l == r) tr[u] = {l, r, 0, 0};
    else
    {
        tr[u] = {l, r, 0, 0};
        int mid = l + r >> 1;
        build(u * 2, l, mid), build(u * 2 + 1, mid + 1, r);
    }
}

void update(int u, int l, int r, int d)
{
    if (tr[u].l >= l && tr[u].r <= r)
    {
        tr[u].cnt += d;
        if (tr[u].l == tr[u].r)
        {
            if (tr[u].cnt) tr[u].len = ys[tr[u].r + 1] - ys[tr[u].l];
            else tr[u].len = 0;
        }
        else pushUp(u);
    }
    else
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid) update(u * 2, l, r, d);
        if (r > mid) update(u * 2 + 1, l, r, d);
        pushUp(u);
    }
}

void solve()
{
    ys.clear();

    for (int i = 0; i < n; i++)
    {
        double x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;
        SL[i * 2] = {x1, y1, y2, 1};
        SL[i * 2 + 1] = {x2, y1, y2, -1};
        ys.push_back(y1), ys.push_back(y2);
    }

    std::sort(SL, SL + 2 * n);
    std::sort(ys.begin(), ys.end());
    ys.erase(std::unique(ys.begin(), ys.end()), ys.end());

    build(1, 0, ys.size() - 2);

    update(1, find(SL[0].y1), find(SL[0].y2) - 1, 1);
    double res = 0;
    for (int i = 1; i < n * 2; i++)
    {
        double x1 = SL[i - 1].x;
        auto [x2, y1, y2, w] = SL[i];
        res += (x2 - x1) * tr[1].len;
        update(1, find(y1), find(y2) - 1, w);
    }
    printf("Test case #%d\n", ++T);
    printf("Total explored area: %.2lf\n\n", res);
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    while (cin >> n, n)
        solve();

    return 0;
}
```

### 维护序列

题目：https://www.acwing.com/problem/content/description/1279/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;
using LL = long long;

const int N = 1e5 + 10;

int n, p, m;
int A[N];
struct STNode
{
    int l, r;
    int sum;
    int mul, add;
} tr[N * 4];

void PushUp(int u)
{
    tr[u].sum = (tr[u * 2].sum + tr[u * 2 + 1].sum) % p;
}

void Calc(STNode& cur, int mul, int add)
{
    cur.sum = (LL(cur.sum) * mul % p + LL(cur.r - cur.l + 1) * add) % p;
    cur.mul = (LL(cur.mul) * mul) % p;
    cur.add = (LL(cur.add) * mul % p + add) % p;
}

void PushDown(int u)
{
    // if (tr[u].mul > 1 || tr[u].add > 0) // 这是错误的写法，因为mul可能为0
    if (tr[u].mul != 1 || tr[u].add != 0)
    {
        STNode &L = tr[u * 2], &R = tr[u * 2 + 1];
        Calc(L, tr[u].mul, tr[u].add);
        Calc(R, tr[u].mul, tr[u].add);
        tr[u].mul = 1, tr[u].add = 0;
    }
}

void Build(int u, int l, int r)
{
    if (l == r) tr[u] = {l, r, A[l], 1, 0};
    else
    {
        tr[u] = {l, r, 0, 1, 0};
        int mid = l + r >> 1;
        Build(u * 2, l, mid);
        Build(u * 2 + 1, mid + 1, r);
        PushUp(u);
    }
}

void Update(int u, int l, int r, int mul, int add)
{
    if (tr[u].l >= l && tr[u].r <= r)
    {
        Calc(tr[u], mul, add);
    }
    else
    {
        PushDown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid) Update(u * 2, l, r, mul, add);
        if (r > mid) Update(u * 2 + 1, l, r, mul, add);
        PushUp(u);
    }
}

int Query(int u, int l, int r)
{
    if (tr[u].l >= l && tr[u].r <= r) return tr[u].sum;

    PushDown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    int sum = 0;
    if (l <= mid) sum = Query(u * 2, l, r);
    if (r > mid) sum = (sum + Query(u * 2 + 1, l, r)) % p;
    return sum;
}


int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> p;
    for (int i = 1; i <= n; i++) cin >> A[i];
    Build(1, 1, n);

    cin >> m;
    while (m--)
    {
        int t, l, r; cin >> t >> l >> r;
        if (t == 1)
        {
            int c; cin >> c;
            Update(1, l, r, c, 0);
        }
        else if (t == 2)
        {
            int c; cin >> c;
            Update(1, l, r, 1, c);
        }
        else cout << Query(1, l, r) << '\n';
    }

    return 0;
}
```

## 可持久化数据结构

### 最大异或和

题目：https://www.acwing.com/problem/content/description/258/

题解：https://www.acwing.com/solution/content/51419/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 6e5 + 10, M = N * 24;

int n, m;
int ps[N];

int trie[M][2], idx;
int root[N];
int latest[M];

void Insert(int i, int k, int p, int q)
{
    if (k < 0)
    {
        latest[q] = i;
        return;
    }

    int b = ps[i] >> k & 1;
    trie[q][b ^ 1] = trie[p][b ^ 1];
    trie[q][b] = ++idx;
    Insert(i, k - 1, trie[p][b], trie[q][b]);
    latest[q] = max(latest[trie[q][0]], latest[trie[q][1]]);
}

int Query(int val, int l, int r)
{
    int p = root[r];
    for (int i = 23; i >= 0; i--)
    {
        int b = val >> i & 1;
        if (trie[p][b ^ 1] && latest[trie[p][b ^ 1]] >= l)
            p = trie[p][b ^ 1];
        else p = trie[p][b];
    }

    return val ^ ps[latest[p]];
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;

    root[0] = ++idx; // 前缀和的要求
    Insert(0, 23, 0, root[0]);

    for (int i = 1; i <= n; i++)
    {
        cin >> ps[i];
        ps[i] ^= ps[i - 1];
        root[i] = ++idx;
        Insert(i, 23, root[i - 1], root[i]);
    }

    while (m--)
    {
        char op; cin >> op;
        if (op == 'A')
        {
            cin >> ps[++n];
            ps[n] ^= ps[n - 1];
            root[n] = ++idx;
            Insert(n, 23, root[n - 1], root[n]);
        }
        else
        {
            int l, r, x; cin >> l >> r >> x;
            cout << Query(x ^ ps[n], l - 1, r - 1) << '\n';
        }
    }
    
    return 0;
}
```

### 第K小数

题目：https://www.acwing.com/problem/content/description/257/

题解：https://www.acwing.com/solution/content/72023/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int N = 1e5 + 10;

int n, m;
int A[N];
vector<int> nums;

int Disc(int x)
{
    return lower_bound(nums.begin(), nums.end(), x) - nums.begin();
}

struct STNode
{
    int l, r;
    int cnt;
} tr[N * 4 + N * 17];
int root[N], idx;

int Build(int l, int r)
{
    int p = ++idx;
    if (l != r)
    {
        int mid = l + r >> 1;
        tr[p].l = Build(l, mid);
        tr[p].r = Build(mid + 1, r);
    }
    return p;
}

int Insert(int x, int l, int r, int p)
{
    int q = ++idx;
    tr[q] = tr[p];
    if (l == r) tr[q].cnt++;
    else
    {
        int mid = l + r >> 1;
        if (x <= mid) tr[q].l = Insert(x, l, mid, tr[p].l);
        else tr[q].r = Insert(x, mid + 1, r, tr[p].r);
        tr[q].cnt = tr[tr[q].l].cnt + tr[tr[q].r].cnt;
    }
    return q;
}

int Query(int p, int q, int l, int r, int k)
{
    if (l == r) return nums[l];

    int mid = l + r >> 1;
    int cnt = tr[tr[q].l].cnt - tr[tr[p].l].cnt;
    if (k <= cnt) return Query(tr[p].l, tr[q].l, l, mid, k);
    else return Query(tr[p].r, tr[q].r, mid + 1, r, k - cnt);
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        cin >> A[i];
        nums.push_back(A[i]);
    }
    sort(nums.begin(), nums.end());
    nums.erase(unique(nums.begin(), nums.end()), nums.end());

    root[0] = Build(1, n);

    for (int i = 1; i <= n; i++)
        root[i] = Insert(Disc(A[i]), 0, nums.size() - 1, root[i - 1]);

    while (m--)
    {
        int l, r, k; cin >> l >> r >> k;
        cout << Query(root[l - 1], root[r], 0, nums.size() - 1, k) << '\n';
    }

    return 0;
}
```

## 平衡树

### 普通平衡树

题目：https://www.acwing.com/problem/content/description/255/

```c++
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10, INF = 1e8;

struct TreapNode
{
    int ls, rs;
    int key, pri;
    int cnt, size;
} tr[N];
int idx;

void PushUp(int u)
{
    tr[u].size = tr[tr[u].ls].size + tr[tr[u].rs].size + tr[u].cnt;
}

void RotateL(int &p)
{
    int q = tr[p].rs;
    tr[p].rs = tr[q].ls, tr[q].ls = p;
    PushUp(p), PushUp(q);
    p = q;
}

void RotateR(int &p)
{
    int q = tr[p].ls;
    tr[p].ls = tr[q].rs, tr[q].rs = p;
    PushUp(p), PushUp(q);
    p = q;
}

void Ins(int &u, int x)
{
    if (u == 0)
    {
        u = ++idx;
        tr[u] = {0, 0, x, rand(), 1, 1};
        return;
    }

    if (x > tr[u].key)
    {
        Ins(tr[u].rs, x);
        if (tr[tr[u].rs].pri > tr[u].pri) RotateL(u); 
    }
    else if (x < tr[u].key)
    {
        Ins(tr[u].ls, x);
        if (tr[tr[u].ls].pri > tr[u].pri) RotateR(u);
    }
    else tr[u].cnt++;

    PushUp(u);
}

void Del(int& u, int x)
{
    if (u == 0) return;

    if (x < tr[u].key) Del(tr[u].ls, x);
    else if (x > tr[u].key) Del(tr[u].rs, x);
    else
    {
        if (tr[u].cnt > 1) tr[u].cnt--;
        else
        {
            if (tr[u].ls && tr[u].rs)
            {
                if (tr[tr[u].ls].pri > tr[tr[u].rs].pri)
                {
                    RotateR(u);
                    Del(tr[u].rs, x);
                }
                else
                {
                    RotateL(u);
                    Del(tr[u].ls, x);
                }
            }
            else if (tr[u].ls || tr[u].rs) u = tr[u].ls + tr[u].rs;
            else u = 0;
        }
    }

    PushUp(u);
}

int Rank(int u, int x)
{
    if (u == 0) return -INF;

    if (x > tr[u].key) 
        return tr[tr[u].ls].size + tr[u].cnt + Rank(tr[u].rs, x); 
    else if (x < tr[u].key)
        return Rank(tr[u].ls, x);
    else return tr[tr[u].ls].size + 1;
}

int Kth(int u, int k)
{
    if (u == 0) return -INF;

    if (k <= tr[tr[u].ls].size) 
        return Kth(tr[u].ls, k);
    else if (k > tr[tr[u].ls].size + tr[u].cnt) 
        return Kth(tr[u].rs, k - tr[tr[u].ls].size - tr[u].cnt);
    else return tr[u].key;
}

int Pre(int u, int x)
{
    if (u == 0) return -INF;

    if (x <= tr[u].key)
        return Pre(tr[u].ls, x);
    else return max(tr[u].key, Pre(tr[u].rs, x));
}

int Nxt(int u, int x)
{
    if (u == 0) return INF;

    if (x >= tr[u].key)
        return Nxt(tr[u].rs, x);
    else return min(tr[u].key, Nxt(tr[u].ls, x));
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    srand(time(0));

    int root = 0;
    int m; cin >> m;
    while (m--)
    {
        int opt, x; cin >> opt >> x;
        switch(opt)
        {
        case 1: Ins(root, x); break;
        case 2: Del(root, x); break;
        case 3: cout << Rank(root, x) << '\n'; break;
        case 4: cout << Kth(root, x) << '\n'; break;
        case 5: cout << Pre(root, x) << '\n'; break;
        case 6: cout << Nxt(root, x) << '\n'; break;
        }
    }

    return 0;
}
```

### 营业额统计

题目：https://www.acwing.com/problem/content/description/267/

```c++
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <iostream>
#include <algorithm>

using namespace std;
using LL = long long;

const int N = 4e4 + 10, INF = 1e9;

struct TreapNode
{
    int ls, rs;
    int key, pri;
} tr[N];
int idx;

void RotateL(int &p)
{
    int q = tr[p].rs;
    tr[p].rs = tr[q].ls, tr[q].ls = p;
    p = q;
}

void RotateR(int &p)
{
    int q = tr[p].ls;
    tr[p].ls = tr[q].rs, tr[q].rs = p;
    p = q;
}

void Ins(int &u, int x)
{
    if (u == 0)
    {
        u = ++idx;
        tr[u] = {0, 0, x, rand()};
        return;
    }

    if (x < tr[u].key)
    {
        Ins(tr[u].ls, x);
        if (tr[tr[u].ls].pri > tr[u].pri)
            RotateR(u);
    }
    else if (x > tr[u].key)
    {
        Ins(tr[u].rs, x);
        if (tr[tr[u].rs].pri > tr[u].pri)
            RotateL(u);
    }
}

int Pre(int u, int x)
{
    if (u == 0) return -INF;

    if (x < tr[u].key) 
        return Pre(tr[u].ls, x);
    else if (x > tr[u].key) 
        return max(tr[u].key, Pre(tr[u].rs, x));
    else return x;
}

int Nxt(int u, int x)
{
    if (u == 0) return INF;

    if (x > tr[u].key) 
        return Nxt(tr[u].rs, x);
    else if (x < tr[u].key)
        return min(tr[u].key, Nxt(tr[u].ls, x));
    else return x;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    srand(time(0));

    int root = 0;
    int n; cin >> n;
    LL res; cin >> res;
    Ins(root, res);
    for (int i = 2; i <= n; i++)
    {
        int x; cin >> x;
        res += min(x - Pre(root, x), Nxt(root, x) - x);
        Ins(root, x);
    }

    cout << res << '\n';
    return 0;
}
```

## AC自动机

### 搜索关键词

题目：https://www.acwing.com/problem/content/1284/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout;
using LL = long long;

const int M = 5e5 + 10;

int n, m;
std::string str;

struct TrieNode
{
    int son[26];
    int cnt;
} trie[M]; int idx;

void insert(std::string& word)
{
    int p = 0;
    for (char c : word)
    {
        int u = c - 'a';
        if (!trie[p].son[u]) trie[p].son[u] = ++idx;
        p = trie[p].son[u];
    }
    trie[p].cnt++;
}

int next[M];
int Q[M], hh, tt;

void getNext()
{
    memset(next, 0, sizeof next);

    tt = -1, hh = 0;
    for (int i = 0; i < 26; i++)
        if (trie[0].son[i])
            Q[++tt] = trie[0].son[i];

    while (hh <= tt)
    {
        int p = Q[hh++];

        for (int i = 0; i < 26; i++)
        {
            int q = trie[p].son[i];
            if (!q)
            {
                trie[p].son[i] = trie[next[p]].son[i];
            }
            else
            {
                next[q] = trie[next[p]].son[i];
                Q[++tt] = q;
            }
        }
    }
}

void solve()
{
    idx = 0;
    memset(trie, 0, sizeof trie);

    cin >> n;
    for (int i = 0; i < n; i++)
    {
        std::string word; cin >> word;
        insert(word);
    }

    getNext();

    cin >> str;
    LL res = 0;
    int p = 0;
    for (char c : str)
    {
        int u = c - 'a';
        p = trie[p].son[u];
        
        int q = p;
        while (q && trie[q].cnt != -1)
        {
            res += trie[q].cnt;
            trie[q].cnt = -1;
            q = next[q];
        }
    }

    cout << res << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int T = 1; cin >> T;
    while (T--)
        solve();

    return 0;
}
```

### 单词

题目：https://www.acwing.com/problem/content/description/1287/

题解：https://www.acwing.com/solution/content/6932/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using std::cin, std::cout, std::string;

const int N = 1e6 + 10;

int n;
int trie[N][26], idx;
int word[N], f[N];
string str;

void insert(int i)
{
    int p = 0;
    for (char c : str)
    {
        int u = c - 'a';
        if (!trie[p][u]) trie[p][u] = ++idx;
        p = trie[p][u];
        f[p]++;
    }
    word[i] = p;
}

int next[N];
int Q[N], hh, tt;

void build()
{
    tt = -1, hh = 0;
    for (int i = 0; i < 26; i++)
        if (trie[0][i])
            Q[++tt] = trie[0][i];

    while (hh <= tt)
    {
        int p = Q[hh++];
        for (int i = 0; i < 26; i++)
        {
            int q = trie[p][i];
            if (!q) trie[p][i] = trie[next[p]][i];
            else
            {
                next[q] = trie[next[p]][i];
                Q[++tt] = q;
            }
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> str;
        insert(i);
    }

    build();

    for (int i = idx - 1; i >= 0; i--) f[next[Q[i]]] += f[Q[i]];

    for (int i = 1; i <= n; i++) cout << f[word[i]] << '\n';

    return 0;
}
```

