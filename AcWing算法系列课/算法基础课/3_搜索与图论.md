# 搜索与图论

## 搜索

### DFS

#### 模板题：排列数字

[排列数字](https://www.acwing.com/problem/content/844/)

```c++
#include <iostream>

using namespace std;

const int N = 10;

int n;
int path[N]; // 递归路径
bool st[N]; // 状态数组，记录是否访问过

void dfs(int u) // 第u个数字已经排好
{
	if (u == n)
	{
		for (int i = 1; i <= n; i++) printf("%d ", path[i]);
		puts("");
		return;
	}

	for (int i = 1; i <= n; i++)
	{
		if (!st[i]) // 进入dfs(u + 1)
		{
			path[u + 1] = i; // 排好第u+1个数字
			st[i] = true;
			dfs(u + 1);
			st[i] = false; // 恢复现场
		}
	}
}

int main()
{
	scanf("%d", &n);
	dfs(0);
	return 0;
}
```

#### 模板题：n-皇后问题

[n-皇后问题](https://www.acwing.com/problem/content/845/)

**按行数搜索：**

```c++
#include <iostream>

using namespace std;

const int N = 10, M = 20;

int n;
char g[N][N];
bool col[N], dg[M], bdg[M]; // dg和bdg表示对角线和反对角线的状态

void init()
{
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++) g[i][j] = '.';
}

void dfs(int u) // 排好了第u行
{
    if (u == n)
    {
        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= n; j++) printf("%c", g[i][j]);
            puts("");
        }
        puts("");
        return;
    }

    for (int i = 1; i <= n; i++)
    {
        if (!col[i] && !dg[u + i] && !bdg[u + 1 + n - i])
        {
            col[i] = dg[u + i] = bdg[u + 1 + n - i] = true;
            g[u + 1][i] = 'Q';
            dfs(u + 1);
            g[u + 1][i] = '.';
            col[i] = dg[u + i] = bdg[u + 1 + n - i] = false;
        }
    }
}

int main()
{
    scanf("%d", &n);
    init();
    dfs(0);
    return 0;
}
```

**按坐标搜索：**

```c++
#include <iostream>

using namespace std;

const int N = 10, M = 20;

int n;
char g[N][N]; // 棋盘状况，棋子位于[0, n-1]
bool row[N], col[N], dg[M], bdg[M]; // 对角线从[0, 2*n-3]

void init()
{
	for (int i = 0; i < n; i++)
		for (int j = 0; j < n; j++) g[i][j] = '.';
}

void dfs(int x, int y, int s) // 接下来决定(x, y)上放不放皇后，已经排好了s个皇后
{
	if (y == n) y = 0, x++;

	if (x == n)
	{
		if (s == n)
		{
			for (int i = 0; i < n; i++) puts(g[i]);
			puts("");
		}
		return;
	}

	dfs(x, y + 1, s); // 不放

	if (!row[x] && !col[y] && !dg[x + y] && !bdg[n + x - y - 1])
	{
		row[x] = col[y] = dg[x + y] = bdg[n + x - y - 1] = true;
		g[x][y] = 'Q';
		dfs(x, y + 1, s + 1);
		g[x][y] = '.';
		row[x] = col[y] = dg[x + y] = bdg[n + x - y - 1] = false;
	}
}

int main()
{
	scanf("%d", &n);
	init();
	dfs(0, 0, 0);
	return 0;
}
```

1. 按坐标搜索比按行数搜索慢得多。恐怕是因为`dfs`传的参数过多，递归深度更深，并且剪枝的判断也更多。

### BFS

#### 模板题：走迷宫

[走迷宫](https://www.acwing.com/problem/content/846/)

```c++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 110;

typedef pair<int, int> PII;

int n, m;
int g[N][N], d[N][N]; // g用来存图，d存距离
PII q[N * N]; int hh, tt = -1; // 队列

void init()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++) scanf("%d", &g[i][j]);
    memset(d, -1, sizeof d);
}

void bfs()
{
    int dx[4] = { -1, 1, 0, 0 }, dy[4] = { 0, 0, -1, 1 };
    q[++tt] = { 1, 1 }; d[1][1] = 0;

    while (hh <= tt)
    {
        int px = q[hh].first, py = q[hh].second;
        hh++;
        for (int i = 0; i < 4; i++)
        {
            int x = px + dx[i], y = py + dy[i];
            if (x >= 1 && x <= n && y >= 1 && y <= m && d[x][y] == -1 && g[x][y] == 0)
            {
                d[x][y] = d[px][py] + 1;
                q[++tt] = { x, y };
            }
        }
    }
}


int main()
{
    init();
    bfs();
    printf("%d\n", d[n][m]);
    return 0;
}
```

#### 习题：八数码

[八数码](https://www.acwing.com/problem/content/description/847/)

```c++
#include <iostream>
#include <unordered_map>
#include <queue>
using namespace std;

string start;

int bfs()
{
	string end = "12345678x";
	if (start == end) return 0;

	queue<string> q; q.push(start);
	unordered_map<string, int> d; d[start] = 0;

	int dx[] = { -1, 1, 0, 0 }, dy[] = { 0, 0, -1, 1 };
	while (q.size())
	{
		string state = q.front(); q.pop();

		int dist = d[state];
		int pre = state.find('x');
		int px = pre / 3, py = pre % 3;
		for (int i = 0; i < 4; i++) // 遍历四个方向
		{
			int x = px + dx[i], y = py + dy[i];
			if (x >= 0 && x < 3 && y >= 0 && y < 3)
			{
				int cur = 3 * x + y;
				swap(state[pre], state[cur]);
				if (!d.count(state))
				{
					if (state == end) return dist + 1;
					d[state] = dist + 1;
					q.push(state); // 拷贝，而不是传引用
				}
				swap(state[pre], state[cur]); // 为下一个方向的判断复原
			}
		}
	}
	return -1;
}

int main()
{
	for (int i = 0; i < 9; i++)
	{
		char ch; cin >> ch; // 比scanf("%s")快
		start += ch; // 原地操作，效率尚可
	}

	printf("%d\n", bfs());
	return 0;
}
```

1. 相比于[yxc的代码](https://www.acwing.com/activity/content/code/content/48146/)优化了检测终点的距离，可以节省大量的时间。
2. 对于读入前后带有空格的单个字符，`cin`的效率比`scanf("%s")`更快。

## 图的遍历

### 树与图的深度优先遍历

时间复杂度为$O(n+m)$，$n$表示点数，$m$表示边数

#### 模板题：树的重心

[树的重心](https://www.acwing.com/problem/content/848/)

```c++
#include <iostream>

using namespace std;

const int N = 1e5 + 10;

int n, ans = N;
int h[N], e[2 * N], ne[2 * N], idx = 1;
bool st[N];

void add(int a, int b)
{
	e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

int dfs(int x)
{
	st[x] = true;
	int ma = 0, cnt = 1;
	for (int p = h[x]; p; p = ne[p])
	{
		int ver = e[p];
		if (!st[ver])
		{
			int tmp = dfs(ver);
			cnt += tmp;
			ma = max(ma, tmp);
		}
	}
	ma = max(ma, n - cnt);
	ans = min(ans, ma);
	return cnt;
}

int main()
{
	scanf("%d", &n);
	for (int i = 1; i < n; i++)
	{
		int a, b; scanf("%d%d", &a, &b);
		add(a, b), add(b, a);
	}
	dfs(1);
	printf("%d\n", ans);
	return 0;
}
```

### 树与图的广度优先遍历

时间复杂度为$O(n+m)$，$n$表示点数，$m$表示边数

#### 模板题：图中点的层次

[图中点的层次](https://www.acwing.com/problem/content/849/)

```c++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 1e5 + 10;

int n, m;
int h[N], e[N], ne[N], idx = 1;
int d[N];
int q[N], hh, tt = -1;

void add(int a, int b)
{
	e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

int bfs()
{
	q[++tt] = 1; d[1] = 0;

	while (hh <= tt)
	{
		int par = q[hh++];
		for (int ptr = h[par]; ptr; ptr = ne[ptr])
		{
			int ver = e[ptr];
			if (d[ver] == -1)
			{
				d[ver] = d[par] + 1;
				q[++tt] = ver;
			}
		}
	}
	return d[n];
}

int main()
{
	scanf("%d%d", &n, &m);
	memset(d, -1, 4 * n + 10);
	for (int i = 0; i < m; i++)
	{
		int a, b; scanf("%d%d", &a, &b);
		add(a, b);
	}
	printf("%d", bfs());
}
```

## 拓扑排序

时间复杂度为$O(n+m)$，$n$表示点数，$m$表示边数

**模板题：**

[有向图的拓扑序列](https://www.acwing.com/problem/content/850/)

```c++
#include <iostream>

using namespace std;

const int N = 1e5 + 10;

int n, m;
int in[N];
int H[N];
struct ListNode
{
   int v, n;
} L[N]; int idx = 1;

void add(int a, int b)
{
   L[idx].v = b, L[idx].n = H[a], H[a] = idx++;
}

int Q[N], hh, tt;
bool topsort()
{
   hh = 0, tt = -1;
   for (int i = 1; i <= n; i++)
      if (in[i] == 0) Q[++tt] = i;

   while (hh <= tt)
   {
      int cur = Q[hh++];

      for (int p = H[cur]; p; p = L[p].n)
      {
         int v = L[p].v;
         if (--in[v] == 0) Q[++tt] = v;
      }
   }

   return tt == n - 1;
}

int main()
{
   scanf("%d%d", &n, &m);
   for (int i = 1; i <= m; i++)
   {
      int a, b; scanf("%d%d", &a, &b);
      add(a, b);
      in[b]++;
   }

   if (topsort())
   {
      for (int i = 0; i <= tt; i++) printf("%d ", Q[i]);
      puts("");
   }
   else puts("-1");

   return 0;
}
```

## 最短路

### Dijkstra

#### 朴素Dijkstra

时间复杂度为$O(n^2+m)$，$n$表示点数，$m$表示边数

**模板题：Dijkstra求最短路 I**

题目：[Dijkstra求最短路 I](https://www.acwing.com/problem/content/851/)

题解：https://www.acwing.com/solution/content/38318/

```c++
#include <cstring>
#include <iostream>

using namespace std;

const int N = 510, M = 1e5 + 10, INF = 0x3f3f3f3f;

int n, m;
int H[N];
struct ListNode
{
    int v, w, n;
} L[M]; int idx = 1;

void add(int a, int b, int w)
{
    L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

int dist[N];
bool st[N];
void dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    for (int i = 1; i <= n; i++)
    {
        int cur = -1;
        for (int j = 1; j <= n; j++)
            if (!st[j] && (cur == -1 || dist[j] < dist[cur]))
                cur = j;
        st[cur] = true;

        for (int p = H[cur]; p; p = L[p].n)
        {
            int v = L[p].v, w = L[p].w;
            dist[v] = min(dist[v], dist[cur] + w);
        }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++)
    {
        int a, b, w; scanf("%d%d%d", &a, &b, &w);
        add(a, b, w);
    }

    dijkstra();

    if (dist[n] == INF) puts("-1");
    else printf("%d\n", dist[n]);

    return 0;
}
```

#### 堆优化版dijkstra

时间复杂度为$O(m \log_2 n)$，$n$表示点数，$m$表示边数

**模板题：Dijkstra求最短路 II**

题目：[Dijkstra求最短路 II](https://www.acwing.com/problem/content/852/)

```c++
#include <iostream>
#include <queue>
#include <cstring>

using namespace std;

const int N = 15e4 + 10, INF = 0x3f3f3f3f;

int n, m;
int H[N];
struct ListNode
{
    int v, w, n;
} L[N]; int idx = 1;

void add(int a, int b, int w)
{
    L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

bool st[N];
int dist[N];
struct node 
{
    int d, v;

    bool operator> (const node& ct) const { return d > ct.d; }
};
void dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<node, vector<node>, greater<node>> heap;
    heap.push({ 0, 1 });
    while (!heap.empty())
    {
        auto cur = heap.top(); heap.pop();

        if (st[cur.v]) continue;
        else st[cur.v] = true;

        for (int p = H[cur.v]; p; p = L[p].n)
        {
            int v = L[p].v, w = L[p].w;
            if (dist[cur.v] + w < dist[v])
            {
                dist[v] = dist[cur.v] + w;
                heap.push({ dist[v], v });
            }
        }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++)
    {
        int a, b, w; scanf("%d%d%d", &a, &b, &w);
        add(a, b, w);
    }

    dijkstra();

    if (dist[n] == INF) puts("-1");
    else printf("%d\n", dist[n]);

    return 0;
}
```

### bellman-ford

时间复杂度$O(nm)$，$n$表示点数，$m$表示边数

#### 模板题：有边数限制的最短路

题目：[有边数限制的最短路](https://www.acwing.com/problem/content/855/)

题解：https://www.acwing.com/solution/content/14088/

```c++
#include <iostream>
#include <cstring>

using namespace std;

const int N = 510, M = 1e4 + 10;
const int INF = 0x3f3f3f3f;

int n, m, k;
struct edge
{
	int x, y, z;
}edges[M];
int d[N], last[N];

void bellman_ford()
{
	memset(d, 0x3f, sizeof d);
	d[1] = 0;
	for (int i = 0; i < k; i++) // 寻找最短路时，k应为n
	{
		memcpy(last, d, sizeof d);
		for (int j = 0; j < m; j++)
		{
			auto e = edges[j];
			d[e.y] = min(d[e.y], last[e.x] + e.z);
		}
	}
}

int main()
{
	scanf("%d%d%d", &n, &m, &k);
	for (int i = 0; i < m; i++)
	{
		int x, y, z; scanf("%d%d%d", &x, &y, &z);
		edges[i] = { x, y, z };
	}
	bellman_ford();
	if (d[n] > INF / 2) puts("impossible");
	else printf("%d", d[n]);
	return 0;
}
```

1. 在迭代过程中，可能会更新`d[n] = min(d[n], last[i] + z)`，如果`last[i] = INF`和`z < 0`，则可能出现`d[n] < INF`的情况。但在理论上`d[n]`依然是正无穷。
1. bf算法在各方面都不如spfa，但题中的应用却只有bf算法才能胜任。

### spfa

时间复杂度平均情况下$O(m)$，最坏情况下$O(nm)$，$n$表示点数，$m$表示边数

#### spfa求最短路

**模板题：**

题目：[spfa求最短路](https://www.acwing.com/problem/content/853/)

题解：https://www.acwing.com/solution/content/105508/

```c++
#include <cstring>
#include <iostream>

using namespace std;

const int N = 1e5 + 10, INF = 0x3f3f3f3f;

int n, m;
int H[N];
struct ListNode
{
    int v, w, n;
} L[N]; int idx = 1;

void add(int a, int b, int w)
{
    L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

int dist[N];
bool st[N];
int Q[N], hh, tt;

void spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    st[1] = true;
    hh = 0, tt = -1;
    Q[++tt] = 1;

    while (hh <= tt)
    {
        int cur = Q[hh++];
        st[cur] = false;
        for (int p = H[cur]; p; p = L[p].n)
        {
            int v = L[p].v, w = L[p].w;
            if (dist[cur] + w < dist[v])
            {
                dist[v] = dist[cur] + w;
                if (!st[v])
                {
                    st[v] = true;
                    Q[++tt] = v;
                }
            }
        }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++)
    {
        int a, b, w; scanf("%d%d%d", &a, &b, &w);
        add(a, b, w);
    }

    spfa();

    if (dist[n] == INF) puts("impossible");
    else printf("%d\n", dist[n]);

    return 0;
}
```

#### spfa判断负环

**模板题：**

题目：[spfa判断负环](https://www.acwing.com/problem/content/854/)

```c++
#include <iostream>
#include <queue>

using namespace std;

const int N = 2010, M = 1e4 + 10;

int n, m;
int H[N];
struct ListNode
{
    int v, w, n;
} L[M]; int idx = 1;

void add(int a, int b, int w)
{
    L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

int dist[N], cnt[N];
bool st[N];
bool spfa()
{
    queue<int> q;

    for (int i = 1; i <= n; i++)
    {
        st[i] = true;
        q.push(i);
    }

    while (!q.empty())
    {
        int cur = q.front(); q.pop();
        st[cur] = false;

        for (int p = H[cur]; p; p = L[p].n)
        {
            int v = L[p].v, w = L[p].w;
            if (dist[cur] + w < dist[v])
            {
                dist[v] = dist[cur] + w;
                cnt[v] = cnt[cur] + 1;
                if (cnt[v] >= n) return true;
                if (!st[v])
                {
                    st[v] = true;
                    q.push(v);
                }
            }
        }
    }

    return false;
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++)
    {
        int a, b, w; scanf("%d%d%d", &a, &b, &w);
        add(a, b, w);
    }

    if (spfa()) puts("Yes");
    else puts("No");

    return 0;
}
```

### floyd

时间复杂度$O(n^3)$，$n$表示点数

**模板题：**

题目：[Floyd求最短路](https://www.acwing.com/problem/content/856/)

```c++
#include <iostream>

using namespace std;

const int N = 210, INF = 1e9;

int n, m, k;
int d[N][N];

void floyd()
{
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <=n; j++)
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}

int main()
{
    scanf("%d%d%d", &n, &m, &k);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            d[i][j] = i == j ? 0 : INF; // 忽略自环
    while (m--)
    {
        int x, y, z; scanf("%d%d%d", &x, &y, &z);
        d[x][y] = min(d[x][y], z); // 选取多条边中最小的
    }
    floyd();
    while (k--)
    {
        int x, y; scanf("%d%d", &x, &y);
        if (d[x][y] > INF / 2) puts("impossible");
        else printf("%d\n", d[x][y]);
    }
    return 0;
}
```

**在线Floyd：**

题目：https://www.luogu.com.cn/problem/B3647

每加入一条边都计算当前已知边的所构成图的最短路，AcWing的数据会超时，这里用洛谷。时间复杂度为$O(mn^2)$

```c++
#include <cstring>
#include <iostream>

using namespace std;

const int N = 110, INF = 0x3f3f3f3f;

int n, m;
int D[N][N];

void Floyd(int a, int b, int w)
{
    for (int i = 1; i <= n; i++)
    {
        D[i][b] = min(D[i][b], D[i][a] + D[a][b]);
        D[a][i] = min(D[a][i], D[a][b] + D[b][i]);
    }

    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            D[i][j] = min(D[i][j], D[i][a] + D[a][b] + D[b][j]);
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(D, 0x3f, sizeof D);
    for (int i = 1; i <= n; i++) D[i][i] = 0;
    while (m--)
    {
        int a, b, w; scanf("%d%d%d", &a, &b, &w);
        D[b][a] = D[a][b] = min(D[a][b], w);
        Floyd(a, b, w), Floyd(b, a, w);
    }

    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++) 
            printf("%d ", D[i][j]);
        puts("");
    }

    return 0;
}
```



## 最小生成树

### Prim

时间复杂度$O(n^2 + m)$，$n$表示点数，$m$表示边数。

**模板题：**

[Prim算法求最小生成树](https://www.acwing.com/problem/content/860/)

```c++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 510, INF = 0x3f3f3f3f;

int n, m;
int g[N][N], d[N];
bool st[N];

int prim()
{
	memset(d, 0x3f, sizeof d);
	d[1] = 0; // 最小生成树的第一个点
	int res = 0;
	for (int i = 0; i < n; i++)
	{
		int t = -1;
		for (int j = 1; j <= n; j++)
			if (!st[j] && (t == -1 || d[j] < d[t])) t = j;
		if (d[t] == INF) return INF;
		st[t] = true;
		res += d[t];
		for (int j = 1; j <= n; j++)
			if (!st[j]) d[j] = min(d[j], g[t][j]);
	}
	return res;
}

int main()
{
	scanf("%d%d", &n, &m);
	memset(g, 0x3f, sizeof g);
	while (m--)
	{
		int u, v, w; scanf("%d%d%d", &u, &v, &w);
		g[u][v] = g[v][u] = min(g[u][v], w);
	}

	int res = prim();
	if (res != INF) printf("%d\n", res);
	else puts("impossible");
	return 0;
}
```

1. 和Dijkstra算法类似，主要区别在于数组`d`的含义不同。在Prim算法中，数组`d`表示集合到其他点的距离。

**链式前向星：**

```c++
#include <cstring>
#include <iostream>

using namespace std;

const int N = 510, M = 2e5 + 10, INF = 0x3f3f3f3f;

int n, m;
int H[N];
struct ListNode
{
    int v, w, n;
} L[M]; int idx = 1;

void Add(int a, int b, int w)
{
    L[idx].v = b, L[idx].w = w, L[idx].n = H[a], H[a] = idx++;
}

bool st[N];
int D[N];
int Prim()
{
    memset(D, 0x3f, sizeof D);
    D[1] = 0;

    int res = 0;
    for (int i = 1; i <= n; i++)
    {
        int cur = -1;
        for (int j = 1; j <= n; j++)
            if (!st[j] && (cur == -1 || D[j] < D[cur]))
                cur = j;
        
        if (D[cur] == INF) return INF;

        st[cur] = true;
        res += D[cur];

        for (int p = H[cur]; p; p = L[p].n)
        {
            int v = L[p].v, w = L[p].w;
            if (!st[v] && w < D[v]) 
                D[v] = w;
        }
    }

    return res;
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++)
    {
        int a, b, w; scanf("%d%d%d", &a, &b, &w);
        Add(a, b, w), Add(b, a, w);
    }

    int res = Prim();

    if (res == INF) puts("impossible");
    else printf("%d\n", res);

    return 0;
}
```



### Kruskal

时间复杂度$O(m\log_2m)$，$n$表示点数，$m$表示边数。

**模板题：**

[Kruskal算法求最小生成树](https://www.acwing.com/problem/content/861/)

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10, M = 2e5 + 10, INF = 0x3f3f3f3f;

int n, m;
struct Edge
{
    int a, b, w;
    bool operator< (const Edge& ct) const
    {
        return w < ct.w;
    }
} E[M];

int P[N];
int Find(int x)
{
    if (x != P[x]) P[x] = Find(P[x]);
    return P[x];
}

void Merge(int a, int b)
{
    a = Find(a), b = Find(b);
    P[a] = b;
}

int Kruskal()
{
    sort(E + 1, E + 1 + m);
    for (int i = 1; i <= n; i++) P[i] = i;

    int res = 0, cnt = 0;
    for (int i = 1; i <= m; i++)
    {
        int a = E[i].a, b = E[i].b, w = E[i].w;
        a = Find(a), b = Find(b);
        if (a != b)
        {
            res += w;
            Merge(a, b);
            if (++cnt == n - 1) return res;
        }
    }

    return INF;
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++)
        scanf("%d%d%d", &E[i].a, &E[i].b, &E[i].w);

    int res = Kruskal();

    if (res == INF) puts("impossible");
    else printf("%d\n", res);
    
    return 0;
}
```

1. Kruskal算法适用于稀疏图，Prim算法适用于稠密图。

## 二分图

### 染色法

时间复杂度$O(n + m)$，$n$表示点数，$m$表示边数。

**模板题：**

[染色法判定二分图](https://www.acwing.com/problem/content/862/)

题解：https://www.acwing.com/solution/content/105874/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10, M = 2e5 + 10;

int n, m;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M]; int idx;

void InitG()
{
    idx = 1;
}

void Add(int a, int b)
{
    E[idx] = {b, H[a]}, H[a] = idx++;
}

int color[N];
int Q[N], hh, tt;

bool BFS(int start)
{
    hh = 0, tt = - 1;
    Q[++tt] = start;
    color[start] = 1;

    while (hh <= tt)
    {
        int u = Q[hh++];
        int c = color[u];

        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            if (color[v])
            {
                if (color[v] == c) return false;
            }
            else
            {
                color[v] = -c;
                Q[++tt] = v;
            }
        }
    }

    return true;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    InitG();

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        Add(a, b), Add(b, a);
    }

    bool res = true;
    for (int i = 1; i <= n; i++)
        if (!color[i])
            if (!BFS(i))
            {
                res = false;
                break;
            }

    cout << (res ? "Yes" : "No") << endl;

    return 0;
}
```

### 匈牙利算法

时间复杂度$O(nm)$，$n$表示点数，$m$表示边数。

[二分图的最大匹配](https://www.acwing.com/problem/content/863/)

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 510, M = 2e5 + 10;

int n1, n2, m;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M]; int idx;

void InitG()
{
    idx = 1;
}

void Add(int a, int b)
{
    E[idx] = {b, H[a]}, H[a] = idx++;
}

bool st[N];   // 表示单次分配过程中是否被预定
int match[N]; // 由右边点集映射左边点集的已经完成的分配

bool Find(int u)
{
    for (int p = H[u]; p; p = E[p].n)
    {
        int v = E[p].v;
        if (!st[v])
        {
            st[v] = true;
            if (match[v] == 0 || Find(match[v]))
            {
                match[v] = u;
                return true;
            }
        }
    }

    return false;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    InitG();

    cin >> n1 >> n2 >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        Add(a, b);
    }

    int res = 0;
    for (int i = 1; i <= n1; i++)
    {
        memset(st, 0, sizeof st);
        res += Find(i);
    }

    cout << res << '\n';

    return 0;
}
```

