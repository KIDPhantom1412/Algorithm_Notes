# 数据结构

## Splay

### Splay

题目：https://www.acwing.com/problem/content/2439/

题解：https://www.acwing.com/solution/content/140676/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e5 + 5;

int n, m;

struct Node
{
    int s[2], p, v;
    int cnt, flag;

    void init(int _v, int _p)
    {
        v = _p, p = _p;
        cnt = 1;
    }
} tr[N];
int root, idx;

void pushup(int u)
{
    tr[u].cnt = tr[tr[u].s[0]].cnt + tr[tr[u].s[1]].cnt + 1;
}

void pushdown(int u)
{
    if (tr[u].flag)
    {
        std::swap(tr[u].s[0], tr[u].s[1]);
        tr[tr[u].s[0]].flag ^= 1;
        tr[tr[u].s[1]].flag ^= 1;
        tr[u].flag = 0;
    }
}

void rotate(int x)
{
    int y = tr[x].p, z = tr[y].p;
    int k = tr[y].s[1] == x;

    tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;
    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
    tr[x].s[k ^ 1] = y, tr[y].p = x;

    pushup(y), pushup(x);
}

void splay(int x, int k)
{
    while (tr[x].p != k)
    {
        int y = tr[x].p, z = tr[y].p;
        if (z != k)
        {
            if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
            else rotate(y);
        }
        rotate(x);
    }
    if (k == 0) root = x;
}

void insert(int v)
{
    int u = root, p = 0;
    while (u)
    {
        p = u;
        u = tr[u].s[v > tr[u].v];
    }
    u = ++idx;
    if (p) tr[p].s[v > tr[p].v] = u;
    tr[u].init(v, p);
    splay(u, 0);
}

int getK(int k)
{
    int u = root;
    while (true)
    {
        pushdown(u);
        if (tr[tr[u].s[0]].cnt >= k) u = tr[u].s[0];
        else if (tr[tr[u].s[0]].cnt + 1 == k) return u;
        else
        {
            k -= tr[tr[u].s[0]].cnt + 1;
            u = tr[u].s[1];
        }
    }
    return -1;
}

void print(int u)
{
    pushdown(u);
    if (tr[u].s[0]) print(tr[u].s[0]);
    if (tr[u].v >= 1 && tr[u].v <= n) cout << tr[u].v << ' ';
    if (tr[u].s[1]) print(tr[u].s[1]);
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    
    cin >> n >> m;
    for (int i = 0; i <= n + 1; i++) insert(i);
    for (int i = 0; i < m; i++)
    {
        int l, r; cin >> l >> r;
        l++, r++;
        l = getK(l - 1), r = getK(r + 1);
        splay(l, 0), splay(r, l);
        tr[tr[r].s[0]].flag ^= 1;
    }
    
    print(root);

    return 0;
}
```

### 郁闷的出纳员

题目：https://www.acwing.com/problem/content/952/

题解：https://www.acwing.com/solution/content/140833/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e5 + 5, INF = 1e8 + 5;

int n, mn, delta;

struct Node
{
    int s[2], p, v;
    int cnt;

    void init(int _v, int _p)
    {
        v = _v, p = _p;
        cnt = 1;
    }
} tr[N];
int root, idx;

void pushup(int u)
{
    tr[u].cnt = tr[tr[u].s[0]].cnt + tr[tr[u].s[1]].cnt + 1;
}

void rotate(int x)
{
    int y = tr[x].p, z = tr[y].p;
    int k = tr[y].s[1] == x;

    tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;
    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
    tr[x].s[k ^ 1] = y, tr[y].p = x;
    pushup(y), pushup(x);  // 顺序不可以颠倒
}

void splay(int x, int k)
{
    while (tr[x].p != k)
    {
        int y = tr[x].p, z = tr[y].p;
        if (z != k)
        {
            if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
            else rotate(y);
        }
        rotate(x);
    }
    if (k == 0) root = x;
}

int insert(int v)
{
    int p = 0, u = root;
    while (u)
    {
        p = u;
        u = tr[u].s[v > tr[u].v];
    }
    u = ++idx;
    if (p) tr[p].s[v > tr[p].v] = u;
    tr[u].init(v, p);
    splay(u, 0);

    return u;
}

int get(int v)
{
    int u = root, res = -1;
    while (u)
    {
        if (tr[u].v >= v) res = u, u = tr[u].s[0];
        else u = tr[u].s[1];
    }
    return res;
}

int getK(int k)
{
    int u = root;
    while (u)
    {
        if (tr[tr[u].s[0]].cnt >= k) u = tr[u].s[0];
        else if (tr[tr[u].s[0]].cnt + 1 == k) return u;
        else
        {
            k -= tr[tr[u].s[0]].cnt + 1;
            u = tr[u].s[1];
        }
    }

    return -1;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int L = insert(-INF), R = insert(INF);

    cin >> n >> mn;
    int tot = 0;
    for (int i = 0; i < n; i++)
    {
        char op[2];
        int k;
        cin >> op >> k;
        if (op[0] == 'I')
        {
            if (k >= mn)
            {
                k -= delta;
                insert(k);
                tot++;
            }
        }
        else if (op[0] == 'A')
        {
            delta += k;
        }
        else if (op[0] == 'S')
        {
            delta -= k;
            R = get(mn - delta);
            splay(R, 0), splay(L, R);
            tr[L].s[1] = 0;
            pushup(L), pushup(R);
        }
        else if (op[0] == 'F')
        {
            if (k > tr[root].cnt - 2) cout << -1 << '\n';
            else
            {
                int u = getK(tr[root].cnt - k);
                cout << tr[u].v + delta << '\n';
            }
        }
    }

    cout << tot - (tr[root].cnt - 2) << '\n';

    return 0;
}
```

### 永无乡

题目：https://www.acwing.com/problem/content/description/1065/

题解：

https://www.acwing.com/solution/content/142368/

https://www.acwing.com/solution/content/283270/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e5 + 5, M = 17 * N;

int n, m;
struct Node
{
    int s[2], p, v, id;
    int cnt;

    void init(int _p, int _v, int _id)
    {
        p = _p, v = _v, id = _id;
        cnt = 1;
    }
} tr[M];
int root[N], idx;

int P[N];

int find(int x)
{
    if (x != P[x]) P[x] = find(P[x]);
    return P[x];
}

void pushup(int x)
{
    tr[x].cnt = tr[tr[x].s[0]].cnt + tr[tr[x].s[1]].cnt + 1;
}

void rotate(int x)
{
    int y = tr[x].p, z = tr[y].p;
    int k = tr[y].s[1] == x;

    tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;
    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
    tr[x].s[k ^ 1] = y, tr[y].p = x;
    pushup(y), pushup(x);
}

void splay(int& root, int x, int k)
{
    while (tr[x].p != k)
    {
        int y = tr[x].p, z = tr[y].p;
        if (z != k)
        {
            if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
            else rotate(y);
        }
        rotate(x);
    }
    if (k == 0) root = x;
}

void insert(int& root, int v, int id)
{
    int p = 0, u = root;
    while (u)
    {
        p = u;
        u = tr[u].s[v > tr[u].v];
    }
    u = ++idx;
    if (p) tr[p].s[v > tr[p].v] = u;
    tr[u].init(p, v, id);
    splay(root, u, 0);
}

void merge(int& root, int x)  // 把x子树合并到root
{
    if (tr[x].s[0]) merge(root, tr[x].s[0]);
    if (tr[x].s[1]) merge(root, tr[x].s[1]);

    insert(root, tr[x].v, tr[x].id);
}

int getK(int u, int k)
{
    while (u)
    {
        int left = tr[tr[u].s[0]].cnt;
        if (left >= k) u = tr[u].s[0];
        else if (left + 1 == k) return u;
        else
        {
            k -= left + 1;
            u = tr[u].s[1];
        }
    }
    return -1;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        P[i] = root[i] = i;
        int v; cin >> v;
        tr[i].init(0, v, i);
    }
    idx = n;

    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        a = find(a), b = find(b);
        if (a != b)
        {
            if (tr[root[a]].cnt > tr[root[b]].cnt) std::swap(a, b);
            merge(root[b], root[a]);
            P[a] = b;
        }
    }

    int q; cin >> q;
    while (q--)
    {
        char op[2]; cin >> op;
        int a, b; cin >> a >> b;
        if (op[0] == 'B')
        {
            a = find(a), b = find(b);
            if (a != b)
            {
                if (tr[root[a]].cnt > tr[root[b]].cnt) std::swap(a, b);
                merge(root[b], root[a]);
                P[a] = b;
            }
        }
        else
        {
            a = root[find(a)];
            if (tr[a].cnt >= b)
            {
                int u = getK(a, b);
                cout << tr[u].id << '\n';
            }
            else cout << -1 << '\n';
        }
    }

    return 0;
}
```

### 维护数列

题目：https://www.acwing.com/problem/content/description/957/

题解：https://www.acwing.com/solution/content/143117/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 5e5 + 5, INF = 1e8;

int n, m;
struct Node
{
	int s[2], p, v, cnt;
	int sum, ms, ls, rs;
	bool rev, same;

	void init(int _v, int _p)
	{
		s[0] = s[1] = 0;
		v = _v, p = _p;
		cnt = 1;
		ms = sum = v;
		ls = rs = std::max(v, 0);
		rev = same = false;
	}
} tr[N];
int root;
int empty[N], top;  // 垃圾回收

void gc(int x)
{
	if (tr[x].s[0]) gc(tr[x].s[0]);
	if (tr[x].s[1]) gc(tr[x].s[1]);
	empty[++top] = x;
}

void pushup(int x)
{
	auto& u = tr[x], & l = tr[u.s[0]], & r = tr[u.s[1]];
	u.cnt = l.cnt + r.cnt + 1;
	u.sum = l.sum + r.sum + u.v;
	u.ls = std::max(l.ls, l.sum + u.v + r.ls);
	u.rs = std::max(r.rs, r.sum + u.v + l.rs);
	u.ms = std::max({ l.ms, r.ms, l.rs + u.v + r.ls });
}

void pushdown(int x)
{
	auto& u = tr[x], & l = tr[u.s[0]], & r = tr[u.s[1]];
	if (u.same)
	{
		u.same = u.rev = false;
		if (u.s[0]) l.same = true, l.v = u.v, l.sum = l.v * l.cnt;
		if (u.s[1]) r.same = true, r.v = u.v, r.sum = r.v * r.cnt;
		if (u.v > 0)
		{
			if (u.s[0]) l.ms = l.ls = l.rs = l.sum;
			if (u.s[1]) r.ms = r.ls = r.rs = r.sum;
		}
		else
		{
			if (u.s[0]) l.ms = l.v, l.ls = l.rs = 0;
			if (u.s[1]) r.ms = r.v, r.ls = r.rs = 0;
		}
	}
	else if (u.rev)
	{
		u.rev = false, l.rev ^= true, r.rev ^= true;
		std::swap(l.ls, l.rs), std::swap(l.s[0], l.s[1]);
		std::swap(r.ls, r.rs), std::swap(r.s[0], r.s[1]);
	}
}

void rotate(int x)
{
	int y = tr[x].p, z = tr[y].p;
	int k = tr[y].s[1] == x;

	tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;
	tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
	tr[y].p = x, tr[x].s[k ^ 1] = y;

	pushup(y), pushup(x);
}

void splay(int x, int k)
{
	while (tr[x].p != k)
	{
		int y = tr[x].p, z = tr[y].p;
		if (z != k)
		{
			if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
			else rotate(y);
		}
		rotate(x);
	}
	if (k == 0) root = x;
}

int getK(int k)
{
	int u = root;
	while (u)
	{
		pushdown(u);
		if (tr[tr[u].s[0]].cnt >= k) u = tr[u].s[0];
		else if (tr[tr[u].s[0]].cnt + 1 == k) return u;
		else
		{
			k -= tr[tr[u].s[0]].cnt + 1;
			u = tr[u].s[1];
		}
	}
	return -1;
}

int A[N];

int build(int l, int r, int p)
{
	if (l > r) return 0;

	int mid = l + r >> 1;
	int u = empty[top--];
	tr[u].init(A[mid], p);
	tr[u].s[0] = build(l, mid - 1, u);
	tr[u].s[1] = build(mid + 1, r, u);
	pushup(u);

	return u;
}

int main()
{
	std::ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	
	tr[0].ms = -INF;  // 便于子节点为空时的pushup
	
	for (int i = 1; i < N; i++) empty[++top] = i;

	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> A[i];
	A[0] = A[n + 1] = -INF;  // 不影响答案tr[root].ms
	root = build(0, n + 1, 0);

	while (m--)
	{
		std::string op; cin >> op;
		if (op == "INSERT")
		{
			int posi, tot; cin >> posi >> tot;
			for (int i = 1; i <= tot; i++) cin >> A[i];
			int l = getK(posi + 1), r = getK(posi + 2);
			splay(l, 0), splay(r, l);
			int u = build(1, tot, r);
			tr[r].s[0] = u;
			pushup(r), pushup(l);
		}
		else if (op == "DELETE")
		{
			int posi, tot; cin >> posi >> tot;
			int l = getK(posi), r = getK(posi + 1 + tot);
			splay(l, 0), splay(r, l);
			gc(tr[r].s[0]);
			tr[r].s[0] = 0;
			pushup(r), pushup(l);
		}
		else if (op == "MAKE-SAME")
		{
			int posi, tot, c; cin >> posi >> tot >> c;
			int l = getK(posi), r = getK(posi + 1 + tot);
			splay(l, 0), splay(r, l);
			auto& u = tr[tr[r].s[0]];
			u.same = true;
			u.v = c, u.sum = tot * c;
			if (c > 0) u.ms = u.ls = u.rs = u.sum;
			else u.ms = c, u.ls = u.rs = 0;
			pushup(r), pushup(l);
		}
		else if (op == "REVERSE")
		{
			int posi, tot; cin >> posi >> tot;
			int l = getK(posi), r = getK(posi + 1 + tot);
			splay(l, 0), splay(r, l);
			auto& u = tr[tr[r].s[0]];
			u.rev ^= true;
			std::swap(u.ls, u.rs), std::swap(u.s[0], u.s[1]);
			pushup(r), pushup(l);
		}
		else if (op == "GET-SUM")
		{
			int posi, tot; cin >> posi >> tot;
			int l = getK(posi), r = getK(posi + 1 + tot);
			splay(l, 0), splay(r, l);
			cout << tr[tr[r].s[0]].sum << '\n';
		}
		else
		{
			cout << tr[root].ms << '\n';
		}
	}

	return 0;
}
```

## 树套树

### 树套树-简单版

题目：https://www.acwing.com/problem/content/description/2490/

题解：https://www.acwing.com/solution/content/155519/

要在O2优化下才能通过

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <set>

using LL = long long;
using std::cin, std::cout;

const int N = 5e4 + 5, INF = 1e9;

int n, m;
struct STNode
{
    int l, r;
    std::multiset<int> S;
} tr[N * 4];
int A[N];

void build(int u, int l, int r)
{
    tr[u].l = l, tr[u].r = r;
    auto& S = tr[u].S;
    S.insert(-INF), S.insert(INF);
    for (int i = l; i <= r; i++) S.insert(A[i]);
    if (l < r)
    {
        int mid = (l + r) / 2;
        build(u * 2, l, mid), build(u * 2 + 1, mid + 1, r);
    }
}

void update(int u, int p, int x)
{
    auto& S = tr[u].S;
    S.erase(S.find(A[p]));
    S.insert(x);
    if (tr[u].l < tr[u].r)
    {
        int mid = (tr[u].l + tr[u].r) / 2;
        if (p <= mid) update(u * 2, p, x);
        else update(u * 2 + 1, p, x);
    }
}

int query(int u, int l, int r, int x)
{
    if (l <= tr[u].l && r >= tr[u].r)
    {
        auto& S = tr[u].S;
        auto it = S.lower_bound(x);
        --it;
        return *it;
    }
    else
    {
        int mid = (tr[u].l + tr[u].r) / 2;
        int res = -INF;
        if (l <= mid) res = std::max(res, query(u * 2, l, r, x));
        if (r > mid) res = std::max(res, query(u * 2 + 1, l, r, x));
        return res;
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> A[i];
    build(1, 1, n);

    while (m--)
    {
        int op; cin >> op;
        if (op == 1)
        {
            int p, x; cin >> p >> x;
            update(1, p, x);
            A[p] = x;
        }
        else
        {
            int l, r, x; cin >> l >> r >> x;
            cout << query(1, l, r, x) << '\n';
        }
    }

    return 0;
}
```

### 树套树

题目：https://www.acwing.com/problem/content/2478/

题解：https://www.acwing.com/solution/content/155598/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int INF = 1e9;

const int N = 5e4 + 10;

int A[N];

namespace sp
{
    const int N = 30 * 5e4;
    struct Node
    {
        int s[2], p, v;
        int cnt;

        void init(int _v, int _p)
        {
            v = _v, p = _p;
            cnt = 1;
        }
    } tr[N];
    int idx;

    void pushup(int x)
    {
        tr[x].cnt = tr[tr[x].s[0]].cnt + tr[tr[x].s[1]].cnt + 1;
    }

    void rotate(int x)
    {
        int y = tr[x].p, z = tr[y].p;
        int k = tr[y].s[1] == x;

        tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;
        tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
        tr[x].s[k ^ 1] = y, tr[y].p = x;

        pushup(y), pushup(x);
    }

    void splay(int& root, int x, int k)
    {
        while (tr[x].p != k)
        {
            int y = tr[x].p, z = tr[y].p;
            if (z != k)
            {
                if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
                else rotate(y);
            }
            rotate(x);
        }
        if (k == 0) root = x;
    }

    void insert(int& root, int v)
    {
        int p = 0, u = root;
        while (u)
        {
            p = u;
            u = tr[u].s[v > tr[u].v];
        }
        u = ++idx;
        if (p) tr[p].s[v > tr[p].v] = u;
        tr[u].init(v, p);
        splay(root, u, 0);
    }

    void delOne(int& root, int v)  // 删除一个=v的节点
    {
        int u = root;
        while (u)
        {
            if (tr[u].v == v) break;
            u = tr[u].s[v > tr[u].v];
        }
        splay(root, u, 0);
        int l = tr[u].s[0], r = tr[u].s[1];
        while (tr[l].s[1]) l = tr[l].s[1];
        while (tr[r].s[0]) r = tr[r].s[0];
        splay(root, l, 0), splay(root, r, l);
        tr[r].s[0] = 0;
        pushup(r), pushup(l);
    }

    int get(int& root, int v)  // 找到 < v的节点个数
    {
        int res = 0, u = root;
        while (u)
        {
            if (tr[u].v < v)
            {
                res += tr[tr[u].s[0]].cnt + 1;
                u = tr[u].s[1];
            }
            else u = tr[u].s[0];
        }
        return res;
    }

    int getPre(int& root, int v)  // 找到v的前驱
    {
        int u = root, res = -INF;
        while (u)
        {
            if (tr[u].v < v)
            {
                res = std::max(res, tr[u].v);
                u = tr[u].s[1];
            }
            else u = tr[u].s[0];
        }
        return res;
    }

    int getNxt(int& root, int v)  // 找到v的后继
    {
        int u = root, res = INF;
        while (u)
        {
            if (tr[u].v > v)
            {
                res = std::min(res, tr[u].v);
                u = tr[u].s[0];
            }
            else u = tr[u].s[1];
        }
        return res;
    }
}

namespace sg
{
    const int N = 5e4 * 4 + 5;
    struct Node
    {
        int l, r;
        int root;
    } tr[N];

    void build(int u, int l, int r)
    {
        tr[u] = { l, r };
        int& root = tr[u].root;
        //root = ++sp::idx;
        sp::insert(root, -INF), sp::insert(root, INF);
        for (int i = l; i <= r; i++) sp::insert(root, A[i]);
        if (l < r)
        {
            int mid = (l + r) / 2;
            build(u * 2, l, mid), build(u * 2 + 1, mid + 1, r);
        }
    }

    void update(int u, int p, int v)
    {
        sp::delOne(tr[u].root, A[p]);
        sp::insert(tr[u].root, v);
        if (tr[u].l < tr[u].r)
        {
            int mid = (tr[u].l + tr[u].r) / 2;
            if (p <= mid) update(u * 2, p, v);
            else update(u * 2 + 1, p, v);
        }
    }

    int query(int u, int l, int r, int v)  // 求在[l,r]中的 < v的数字个数
    {
        if (l <= tr[u].l && r >= tr[u].r)
        {
            return sp::get(tr[u].root, v) - 1;
        }
        int res = 0;
        int mid = (tr[u].l + tr[u].r) / 2;
        if (l <= mid) res += query(u * 2, l, r, v);
        if (r > mid) res += query(u * 2 + 1, l, r, v);
        return res;
    }

    int queryPre(int u, int l, int r, int v)  // 求v在[l,r]中的前驱
    {
        if (l <= tr[u].l && r >= tr[u].r)
        {
            return sp::getPre(tr[u].root, v);
        }
        int res = -INF;
        int mid = (tr[u].l + tr[u].r) / 2;
        if (l <= mid) res = std::max(res, queryPre(u * 2, l, r, v));
        if (r > mid) res = std::max(res, queryPre(u * 2 + 1, l, r, v));
        return res;
    }

    int queryNxt(int u, int l, int r, int v)  // 求v在[l,r]中的后继
    {
        if (l <= tr[u].l && r >= tr[u].r)
        {
            return sp::getNxt(tr[u].root, v);
        }

        int res = INF;
        int mid = (tr[u].l + tr[u].r) / 2;
        if (l <= mid) res = std::min(res, queryNxt(u * 2, l, r, v));
        if (r > mid) res = std::min(res, queryNxt(u * 2 + 1, l, r, v));
        return res;
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int n, m; cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> A[i];
    sg::build(1, 1, n);

    while (m--)
    {
        int op; cin >> op;
        if (op == 1)
        {
            int l, r, v; cin >> l >> r >> v;
            cout << sg::query(1, l, r, v) + 1 << '\n';
        }
        else if (op == 2)
        {
            int L, R, K; cin >> L >> R >> K;
            int l = 0, r = 1e8;
            while (l < r)
            {
                int mid = (l + r + 1) / 2;
                if (sg::query(1, L, R, mid) + 1 <= K) l = mid;
                else r = mid - 1;
            }
            cout << l << '\n';
        }
        else if (op == 3)
        {
            int p, v; cin >> p >> v;
            sg::update(1, p, v);
            A[p] = v;
        }
        else if (op == 4)
        {
            int l, r, v; cin >> l >> r >> v;
            cout << sg::queryPre(1, l, r, v) << '\n';
        }
        else
        {
            int l, r, v; cin >> l >> r >> v;
            cout << sg::queryNxt(1, l, r, v) << '\n';
        }
    }

    return 0;
}
```

### K大数查询

题目：https://www.acwing.com/problem/content/2308/

题解：https://www.acwing.com/solution/content/155794/

权值线段树套普通线段树

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>

using LL = long long;
using std::cin, std::cout;

const int N = 5e4 + 5, M = N * 4, S = N * 17 * 17;

int n, m;
struct Operation
{
    int op, a, b, c;
} OP[N];

std::vector<int> disc;

int find(int x)
{
    return std::lower_bound(disc.begin(), disc.end(), x) - disc.begin();
}

struct node  // 内层线段树节点
{
    int l, r;
    LL sum, add;
} tr[S];
int idx;

struct Node
{
    int l, r;
    int root;  // 内层线段树根节点指针
} TR[M];

void build(int u, int l, int r)  // 建立外层线段树
{
    TR[u] = { l, r, ++idx };
    if (l < r)
    {
        int mid = (l + r) / 2;
        build(u * 2, l, mid), build(u * 2 + 1, mid + 1, r);
    }
}

int overlap(int a, int b, int c, int d)
{
    return std::min(b, d) - std::max(a, c) + 1;
}

void increment(int u, int l, int r, int L, int R)  // 内层线段树[L, R]加1
{
    tr[u].sum += overlap(l, r, L, R);

    if (l >= L && r <= R)
    {
        tr[u].add++;
    }
    else
    {
        int mid = (l + r) / 2;
        if (L <= mid)
        {
            if (tr[u].l == 0) tr[u].l = ++idx;
            increment(tr[u].l, l, mid, L, R);
        }
        if (R > mid)
        {
            if (tr[u].r == 0) tr[u].r = ++idx;
            increment(tr[u].r, mid + 1, r, L, R);
        }
    }
}

LL getSum(int u, int l, int r, int L, int R, LL add)
{
    if (l >= L && r <= R) return tr[u].sum + add * (r - l + 1);

    LL res = 0;
    add += tr[u].add;
    int mid = (l + r) / 2;
    if (L <= mid)
    {
        if (tr[u].l) res += getSum(tr[u].l, l, mid, L, R, add);
        else res += add * overlap(l, mid, L, R);
    }
    if (R > mid)
    {
        if (tr[u].r) res += getSum(tr[u].r, mid + 1, r, L, R, add);
        else res += add * overlap(mid + 1, r, L, R);
    }
    return res;
}

void update(int u, int l, int r, int c)
{
    increment(TR[u].root, 1, n, l, r);

    if (TR[u].l < TR[u].r)
    {
        int mid = (TR[u].l + TR[u].r) / 2;
        if (c <= mid) update(u * 2, l, r, c);
        else update(u * 2 + 1, l, r, c);
    }
}

int queryK(int u, int l, int r, int k)
{
    if (TR[u].l == TR[u].r) return TR[u].l;

    LL rtSum = getSum(TR[u * 2 + 1].root, 1, n, l, r, 0);
    if (k <= rtSum) return queryK(u * 2 + 1, l, r, k);
    else return queryK(u * 2, l, r, k - rtSum);
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int op, a, b, c; cin >> op >> a >> b >> c;
        OP[i] = { op, a, b, c };
        if (op == 1) disc.push_back(c);
    }

    std::sort(disc.begin(), disc.end());
    disc.erase(std::unique(disc.begin(), disc.end()), disc.end());
    build(1, 0, disc.size() - 1);

    for (int i = 0; i < m; i++)
    {
        auto [op, a, b, c] = OP[i];
        if (op == 1)
        {
            update(1, a, b, find(c));
        }
        else
        {
            cout << disc[queryK(1, a, b, c)] << '\n';
        }
    }

    return 0;
}
```

