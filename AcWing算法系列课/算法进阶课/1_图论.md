# 图论

## 最大流

### 算法模板

#### EK求最大流

题目：https://www.acwing.com/problem/content/description/2173/

题解：《算法竞赛进阶指南》p441

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1010, M = 2e4 + 5, INF = 1 << 30;

int n, m, S, T;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;  // a->b
    E[++idx] = { a, 0, H[b] }, H[b] = idx;  // b->a
}

int f[N], pre[N];
int Q[N];
bool st[N];

bool bfs()
{
    memset(st, 0, sizeof st);
    int hh = 0, tt = 0;
    st[S] = true;
    f[S] = INF;
    Q[tt++] = S;
    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (!st[v] && w != 0)
            {
                int v = E[p].v, w = E[p].w;
                f[v] = std::min(f[u], w);
                pre[v] = p;
                if (v == T) return true;
                st[v] = true;
                Q[tt++] = v;
            }
        }
    }

    return false;
}

int EK()
{
    int mf = 0;  // 最大流
    while (bfs())
    {
        int u = T;
        while (u != S)
        {
            int p = pre[u];
            E[p].w -= f[T];
            E[p ^ 1].w += f[T];
            u = E[p ^ 1].v;
        }
        mf += f[T];
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m >> S >> T;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w);
    }

    cout << EK() << '\n';

    return 0;
}
```

#### Dinic/ISAP求最大流

题目：https://www.acwing.com/problem/content/2174/

题解：《算法竞赛》p668

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e4 + 5, M = 2e5 + 5, INF = 1 << 30;

int n, m, S, T;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;
    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[v] == -1 && w != 0)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }

    return false;
}

int dfs(int u, int limit)
{
    if (u == T) return limit;

    int flow = 0;
    for (int p = cur[u]; p && limit; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, w = E[p].w;
        if (w != 0 && dist[v] == dist[u] + 1)
        {
            int t = dfs(v, std::min(w, limit));
            if (t == 0) dist[v] = -1;
            else
            {
                E[p].w -= t;
                E[p ^ 1].w += t;
                limit -= t;
                flow += t;
            }
        }
    }

    return flow;
}

int dinic()
{
    int mf = 0, flow = 0;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m >> S >> T;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w);
    }

    cout << dinic() << '\n';

    return 0;
}
```

### 二分图匹配

#### 飞行员配对方案问题

题目：https://www.acwing.com/problem/content/description/2177/

题解：《算法竞赛》p676

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 110, M = 5210, INF = 1e8;

int n, m, S, T;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;
    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[v] == -1 && w > 0)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }

    return false;
}

int dfs(int u, int limit)
{
    if (u == T) return limit;

    int flow = 0;
    for (int p = cur[u]; p && limit; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, w = E[p].w;
        if (dist[v] == dist[u] + 1 && w > 0)
        {
            int t = dfs(v, std::min(limit, w));
            if (t == 0) dist[v] = -1;
            E[p].w -= t;
            E[p ^ 1].w += t;
            flow += t;
            limit -= t;
        }
    }

    return flow;
}

int dinic()
{
    int mf = 0, flow = 0;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> m >> n;
    S = 0, T = n + 1;
    for (int i = 1; i <= m; i++) add(S, i, 1);
    for (int i = m + 1; i <= n; i++) add(i, T, 1);
    int a, b;
    while (cin >> a >> b, a != -1) add(a, b, 1);

    cout << dinic() << '\n';
    for (int p = n * 2 + 2; p <= idx; p += 2)
        if (E[p].w == 0)
        {
            cout << E[p ^ 1].v << ' ' << E[p].v << '\n';
        }

    return 0;
}
```

#### 圆桌问题

题目：https://www.acwing.com/problem/content/description/2181/

题解：https://www.acwing.com/solution/content/40811/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 430, M = (N + 150 * 270) * 2, INF = 1 << 30;

int n, m, S, T;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[v] == -1 && w != 0)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }

    return false;
}

int dfs(int u, int limit)
{
    if (u == T) return limit;

    int flow = 0;
    for (int p = cur[u]; p && limit; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, w = E[p].w;
        if (dist[v] == dist[u] + 1 && w != 0)
        {
            int t = dfs(v, std::min(limit, w));
            if (t == 0) dist[v] = -1;
            else
            {
                E[p].w -= t;
                E[p ^ 1].w += t;
                limit -= t;
                flow += t;
            }
        }
    }

    return flow;
}

int dinic()
{
    int mf = 0, flow;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> m >> n;
    S = 0, T = m + n + 1;
    int tot = 0;
    for (int i = 1; i <= m; i++)
    {
        int x; cin >> x;
        add(S, i, x);
        tot += x;
    }
    for (int i = m + 1; i <= m + n; i++)
    {
        int x; cin >> x;
        add(i, T, x);
    }
    for (int i = 1; i <= m; i++)
        for (int j = m + 1; j <= m + n; j++)
            add(i, j, 1);

    if (tot == dinic())
    {
        cout << 1 << '\n';
        for (int u = 1; u <= m; u++)
        {
            for (int p = H[u]; p; p = E[p].n)
                if (E[p].w == 0)
                {
                    cout << (E[p].v - m) << ' ';
                }
            cout << '\n';
        }
    }
    else
    {
        cout << 0 << '\n';
    }

    return 0;
}
```

### 上下界可行流

#### 无源汇上下界可行流

题目：https://www.acwing.com/problem/content/description/2190/

题解：https://www.acwing.com/solution/content/61022/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 210, M = (10210 + N) * 2, INF = 1 << 30;

int n, m, S, T;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
}

int lb[M];   // 下界
int dif[N];  // 入边的下界和 - 出边的下界和

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[v] == -1 && w != 0)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }

    return false;
}

int dfs(int u, int limit)
{
    if (u == T) return limit;

    int flow = 0;
    for (int p = cur[u]; p && limit; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, w = E[p].w;
        if (dist[v] == dist[u] + 1 && w != 0)
        {
            int t = dfs(v, std::min(w, limit));
            if (t == 0) dist[v] = -1;
            else
            {
                E[p].w -= t, E[p ^ 1].w += t;
                flow += t, limit -= t;
            }
        }
    }

    return flow;
}

int dinic()
{
    int mf = 0, flow;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    S = 0, T = n + 1;
    for (int i = 0; i < m; i++)
    {
        int a, b, c, d; cin >> a >> b >> c >> d;
        add(a, b, d - c), lb[idx] = c;
        add(b, a, 0), lb[idx] = 0;
        dif[a] -= c, dif[b] += c;
    }
    int tot = 0;
    for (int u = 1; u <= n; u++)
    {
        if (dif[u] > 0)
        {
            add(S, u, dif[u]), add(u, S, 0);
            tot += dif[u];
        }
        else
        {
            add(u, T, -dif[u]), add(T, u, 0);
        }
    }

    if (tot == dinic())
    {
        cout << "YES" << '\n';
        for (int i = 2; i <= m * 2; i += 2)
        {
            cout << E[i ^ 1].w + lb[i] << '\n';
        }
    }
    else cout << "NO" << '\n';

    return 0;
}
```

#### 有源汇上下界最大流

题目：https://www.acwing.com/problem/content/description/2191/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 210, M = (1e4 + N) * 2, INF = 1e8;

int n, m, S, T;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int dif[N];  // 入边的下界和 - 出边的上界和

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[v] == -1 && w != 0)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }

    return false;
}

int dfs(int u, int limit)
{
    if (u == T) return limit;

    int flow = 0;
    for (int p = cur[u]; p && limit; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, w = E[p].w;
        if (dist[v] == dist[u] + 1 && w != 0)
        {
            int t = dfs(v, std::min(w, limit));
            if (t == 0) dist[v] = -1;
            else
            {
                E[p].w -= t, E[p ^ 1].w += t;
                flow += t, limit -= t;
            }
        }
    }

    return flow;
}

int dinic()
{
    int mf = 0, flow;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int s, t; cin >> n >> m >> s >> t;
    for (int i = 0; i < m; i++)
    {
        int a, b, c, d; cin >> a >> b >> c >> d;
        add(a, b, d - c);
        dif[a] -= c, dif[b] += c;
    }
    S = 0, T = n + 1;
    int tot = 0;
    for (int u = 1; u <= n; u++)
    {
        if (dif[u] > 0) add(S, u, dif[u]), tot += dif[u];
        else if (dif[u] < 0) add(u, T, -dif[u]);
    }
    add(t, s, INF);

    if (tot != dinic())
    {
        cout << "No Solution" << '\n';
    }
    else
    {
        int res = E[idx].w;
        E[idx].w = E[idx - 1].w = 0;
        S = s, T = t;
        res += dinic();
        cout << res << '\n';
    }

    return 0;
}
```

#### 有源汇上下界最小流

题目：https://www.acwing.com/problem/content/2192/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 5e4 + 10, M = (125003 + N) * 2, INF = 2147483647;

int n, m, S, T;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int dif[N];

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[v] == -1 && w != 0)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }

    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;

    int flow = 0;
    for (int p = cur[u]; p && lim; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, w = E[p].w;
        if (dist[v] == dist[u] + 1 && w != 0)
        {
            int t = dfs(v, std::min(w, lim));
            if (t == 0) dist[v] = -1;
            else
            {
                E[p].w -= t, E[p ^ 1].w += t;
                lim -= t, flow += t;
            }
        }
    }

    return flow;
}

int dinic()
{
    int mf = 0, flow = 0;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int s, t; cin >> n >> m >> s >> t;
    for (int i = 0; i < m; i++)
    {
        int a, b, c, d; cin >> a >> b >> c >> d;
        add(a, b, d - c);
        dif[a] -= c, dif[b] += c;
    }
    S = 0, T = n + 1;
    int tot = 0;
    for (int u = 1; u <= n; u++)
    {
        if (dif[u] > 0) add(S, u, dif[u]), tot += dif[u];
        else if (dif[u] < 0) add(u, T, -dif[u]);
    }
    add(t, s, INF);

    if (tot != dinic())
    {
        cout << "No Solution" << '\n';
    }
    else
    {
        int res = E[idx].w;
        S = t, T = s;
        E[idx].w = E[idx - 1].w = 0;
        res -= dinic();
        cout << res << '\n';
    }

    return 0;
}
```

### 多源汇最大流

#### 多源汇最大流

题目：https://www.acwing.com/problem/content/description/2236/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e4 + 5, M = (1e5 + N) * 2, INF = 1e9;

int n, m, sc, tc;
int S, T;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[v] == -1 && w != 0)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }

    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;

    int flow = 0;
    for (int p = cur[u]; p && lim; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, w = E[p].w;
        if (dist[v] == dist[u] + 1 && w != 0)
        {
            int t = dfs(v, std::min(w, lim));
            if (t == 0) dist[v] = -1;
            else
            {
                flow += t, lim -= t;
                E[p].w -= t, E[p ^ 1].w += t;
            }
        }
    }

    return flow;
}

int dinic()
{
    int mf = 0, flow;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m >> sc >> tc;
    S = 0, T = n + 1;
    for (int i = 0; i < sc; i++)
    {
        int x; cin >> x;
        add(S, x, INF);
    }
    for (int i = 0; i < tc; i++)
    {
        int x; cin >> x;
        add(x, T, INF);
    }
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w);
    }

    cout << dinic() << '\n';

    return 0;
}
```

### 关键边

#### 伊基的故事 I - 道路重建

题目：https://www.acwing.com/problem/content/description/2238/

题解：https://www.acwing.com/solution/content/123983/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 510, M = 1e4 + 5, INF = 1e8;

int n, m, S, T;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[v] == -1 && w != 0)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }

    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;

    int flow = 0;
    for (int p = cur[u]; p && lim; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, w = E[p].w;
        if (dist[v] == dist[u] + 1 && w != 0)
        {
            int t = dfs(v, std::min(w, lim));
            if (t == 0) dist[v] = -1;
            else
            {
                E[p].w -= t, E[p ^ 1].w += t;
                flow += t, lim -= t;
            }
        }
    }

    return flow;
}

int dinic()
{
    int mf = 0, flow;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

bool rs[N], rt[N];

void dfs(int u, bool st[], int flag)
{
    st[u] = true;
    for (int p = H[u]; p; p = E[p].n)
    {
        int t = p ^ flag;
        int v = E[p].v;
        if (!st[v] && E[t].w != 0)
        {
            dfs(v, st, flag);
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    S = 0, T = n - 1;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w);
    }
    
    dinic();
    dfs(S, rs, 0);
    dfs(T, rt, 1);

    int res = 0;
    for (int p = 2; p <= idx; p += 2)
    {
        int v = E[p].v, w = E[p].w;
        if (w == 0 && rt[v] && rs[E[p ^ 1].v])
            res++;
    }
    cout << res << '\n';

    return 0;
}
```

### 最大流判定

#### 秘密挤奶机

题目：https://www.acwing.com/problem/content/description/2279/

题解：https://www.acwing.com/solution/content/41534/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 210, M = 8e4 + 5, INF = 1e8;

int n, m, S, T, K;
int H[N];
struct EdgeNode
{
    int v, w, f, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, 0, H[a] }, H[a] = idx;
    E[++idx] = { a, w, 0, H[b] }, H[b] = idx;
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, f = E[p].f;
            if (dist[v] == -1 && f != 0)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }

    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return true;

    int flow = 0;
    for (int p = cur[u]; p && lim; p = E[p].n)
    {
        int v = E[p].v, f = E[p].f;
        if (dist[v] == dist[u] + 1 && f != 0)
        {
            int t = dfs(v, std::min(f, lim));
            if (t == 0) dist[v] = -1;
            else
            {
                flow += t, lim -= t;
                E[p].f -= t, E[p ^ 1].f += t;
            }
        }
    }

    return flow;
}

int dinic()
{
    int mf = 0, flow;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }

    return mf;
}

bool check(int mid)  // 二分答案
{
    for (int p = 2; p <= idx; p++)
    {
        if (E[p].w <= mid) E[p].f = 1;
        else E[p].f = 0;
    }

    return dinic() >= K;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m >> K;
    S = 1, T = n;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w);
    }

    int l = 1, r = 1e6;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }

    cout << l << '\n';

    return 0;
}
```

#### 星际转移问题

题目：https://www.acwing.com/problem/content/description/2189/

题解：https://www.acwing.com/solution/content/125870/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int STATION = 20, SHIP = 25, DAY = 1000, 
          N = STATION * DAY + 10, M = (N + SHIP * DAY) * 2, INF = 1e9;

int n, m, K, S, T;
struct Ship
{
    int h, r, S[STATION];
} ship[SHIP];

int get(int i, int j)  // 第i天的第j个空间站
{
    return i * STATION + j;
}

int H[N];
struct EdgeNode
{
    int v, f, n;
} E[M];
int idx = 1;

void add(int a, int b, int f)
{
    E[++idx] = { b, f, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int P[STATION];

int find(int x)
{
    if (x != P[x]) P[x] = find(P[x]);
    return P[x];
}

auto init = []
    {
        for (int i = 0; i < STATION; i++) P[i] = i;
        return 0;
    }();

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, f = E[p].f;
            if (dist[v] == -1 && f != 0)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            } 
        }
    }

    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;

    int flow = 0;
    for (int p = cur[u]; p && lim; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, f = E[p].f;
        if (dist[v] == dist[u] + 1 && f != 0)
        {
            int t = dfs(v, std::min(f, lim));
            if (t == 0) dist[v] = -1;
            flow += t, lim -= t;
            E[p].f -= t, E[p ^ 1].f += t;
        }
    }

    return flow;
}

int dinic()
{
    int mf = 0, flow = 0;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m >> K;
    for (int i = 0; i < m; i++)
    {
        cin >> ship[i].h >> ship[i].r;
        for (int j = 0; j < ship[i].r; j++)
        {
            int x; cin >> x;
            if (x == -1) x = n + 1;
            ship[i].S[j] = x;
        }
    }

    for (int i = 0; i < m; i++)
        for (int j = 1; j < ship[i].r; j++)
        {
            int a = ship[i].S[j - 1], b = ship[i].S[j];
            P[find(a)] = find(b);
        }
    if (find(0) != find(n + 1))
    {
        cout << 0 << '\n';
        return 0;
    }

    S = N - 2, T = N - 1;
    add(S, get(0, 0), K);
    //add(get(0, n + 1), T, INF);
    int res = 0;
    for (int day = 1; day < DAY; day++)
    {
        add(get(day, n + 1), T, INF);
        for (int i = 0; i <= n + 1; i++) 
        {
            add(get(day - 1, i), get(day, i), INF);
        }
        for (int i = 0; i < m; i++)
        {
            int h = ship[i].h, r = ship[i].r;
            int a = ship[i].S[(day - 1) % r],
                b = ship[i].S[day % r];
            add(get(day - 1, a), get(day, b), h);
        }

        res += dinic();
        if (res >= K)
        {
            cout << day << '\n';
            break;
        }
    }

    return 0;
}
```

### 拆点

#### 餐饮

题目：https://www.acwing.com/problem/content/description/2242/

题解：https://www.acwing.com/solution/content/125942/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 410, M = (100 * 3 + 10000 * 2) * 2 + 10, INF = 1e8;

int n, F, D, S = 0, T = N - 1;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[v] == -1 && w != 0)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }

    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;

    int flow = 0;
    for (int p = cur[u]; p && lim; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, w = E[p].w;
        if (dist[v] == dist[u] + 1 && w != 0)
        {
            int t = dfs(v, std::min(w, lim));
            if (t == 0) dist[v] = -1;
            E[p].w -= t, E[p ^ 1].w += t;
            flow += t, lim -= t;
        }
    }

    return flow;
}

int dinic()
{
    int mf = 0, flow = 0;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> F >> D;
    for (int i = 201; i <= 200 + F; i++) add(S, i, 1);
    for (int i = 301; i <= 300 + D; i++) add(i, T, 1);
    for (int i = 1; i <= n; i++)
    {
        add(i, 100 + i, 1);  // 拆点，入点->出点
        int a, b; cin >> a >> b;
        while (a--)
        {
            int x; cin >> x;
            add(200 + x, i, 1);
        }
        while (b--)
        {
            int x; cin >> x;
            add(100 + i, 300 + x, 1);
        }
    }

    cout << dinic() << '\n';

    return 0;
}
```

#### 最长递增子序列问题

题目：https://www.acwing.com/problem/content/2182/

题解：https://www.acwing.com/solution/content/41778/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1010, M = (500 + 125250) * 2 + 10, INF = 1e8;

int n;
int X[N], f[N];

int S = 0, T = N - 1;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int Q[N], cur[N], dist[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;
    
    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[v] == -1 && w != 0)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }

    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;

    int flow = 0;
    for (int p = cur[u]; p && lim; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, w = E[p].w;
        if (dist[v] == dist[u] + 1 && w != 0)
        {
            int t = dfs(v, std::min(w, lim));
            if (t == 0) dist[v] = -1;
            E[p].w -= t, E[p ^ 1].w += t;
            flow += t, lim -= t;
        }
    }

    return flow;
}

int dinic()
{
    int mf = 0, flow = 0;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    for (int i = 1; i <= n; i++) cin >> X[i];

    int s = 0;
    for (int i = 1; i <= n; i++)  // dp
    {
        f[i] = 1;
        for (int j = 1; j < i; j++)
            if (X[j] <= X[i])
            {
                f[i] = std::max(f[i], f[j] + 1);
            }
        s = std::max(s, f[i]);
    }

    for (int i = 1; i <= n; i++) // 建图
    {
        add(i, i + n, 1);  // 拆点限制流量

        if (f[i] == 1) add(S, i, 1);
        if (f[i] == s) add(i + n, T, 1);

        for (int j = 1; j < i; j++)
            if (f[i] == f[j] + 1 && X[j] <= X[i])
            {
                add(j + n, i, 1);
            }
    }

    cout << s << '\n';
    if (s == 1)
    {
        cout << n << '\n';
        cout << n << '\n';
        return 0;
    }

    int res = dinic();
    cout << res << '\n';

    for (int p = 2; p <= idx; p += 2)
    {
        int a = E[p ^ 1].v, b = E[p].v;
        if ((a == S && b == 1) ||
            (a == 1 && b == 1 + n) ||
            (a == n && b == n + n) ||
            (a == n + n && b == T))
        {
            E[p].w = INF;
            E[p ^ 1].w = 0;
        }
    }
    res += dinic();

    cout << res << '\n';

    return 0;
}
```

#### 企鹅游行

题目：https://www.acwing.com/problem/content/description/2280/

题解：https://www.acwing.com/solution/content/41823/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 210, M = (100 + 1e4) * 2 + 10, INF = 1e8;
const double eps = 1e-8;

int n, S = N - 1, T;
double md;
struct Point
{
    int x, y;
} P[N];

int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

bool check(int a, int b)
{
    int dx = P[a].x - P[b].x, dy = P[a].y - P[b].y;
    return dx * dx + dy * dy <= md * md + eps;
}

int Q[N], cur[N], dist[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[v] == -1 && w != 0)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }

    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;

    int flow = 0;
    for (int p = cur[u]; p && lim; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, w = E[p].w;
        if (dist[v] == dist[u] + 1 && w != 0)
        {
            int t = dfs(v, std::min(w, lim));
            if (t == 0) dist[v] = -1;
            E[p].w -= t, E[p ^ 1].w += t;
            flow += t, lim -= t;
        }
    }

    return flow;
}

int dinic()
{
    int mf = 0, flow = 0;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

void solve()
{
    memset(H, 0, sizeof H);
    idx = 1;

    cin >> n >> md;
    int tot = 0;
    for (int i = 0; i < n; i++)
    {
        int x, y, a, b; cin >> x >> y >> a >> b;
        P[i] = { x, y };
        tot += a;
        add(S, i, a);
        add(i, i + n, b);
    }

    for (int i = 0; i < n; i++)
        for (int j = 0; j < i; j++)
            if (check(i, j))
            {
                add(i + n, j, INF);
                add(j + n, i, INF);
            }

    int cnt = 0;
    for (T = 0; T < n; T++)
    {
        for (int p = 2; p <= idx; p += 2)  // 还原现场
        {
            E[p].w += E[p ^ 1].w;
            E[p ^ 1].w = 0;
        }
        if (tot == dinic())
        {
            cnt++;
            cout << T << ' ';
        }
    }

    if (cnt == 0) cout << -1 << '\n';
    else cout << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int t; cin >> t;
    while (t--)
        solve();

    return 0;
}
```

### 建图实战

#### 猪

题目：https://www.acwing.com/problem/content/description/2239/

题解：https://www.acwing.com/solution/content/21513/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 110, M = (1e5 + 100) * 2 + 10, INF = 1e8;
const int K = 1010;

int n, m, S = 0, T = N - 1;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int first[K];  // 表示猪舍的一开始猪的数量
int last[K];   // 表示上一个拥有该猪舍钥匙的顾客的编号

int Q[N], cur[N], dist[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[v] == -1 && w != 0)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }

    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;

    int flow = 0;
    for (int p = cur[u]; p && lim; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, w = E[p].w;
        if (dist[v] == dist[u] + 1 && w != 0)
        {
            int t = dfs(v, std::min(w, lim));
            if (t == 0) dist[v] = -1;
            E[p].w -= t, E[p ^ 1].w += t;
            flow += t, lim -= t;
        }
    }

    return flow;
}

int dinic()
{
    int mf = 0, flow = 0;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> m >> n;
    for (int i = 1; i <= m; i++) cin >> first[i];
    for (int i = 1; i <= n; i++)
    {
        int a; cin >> a;
        while (a--)
        {
            int id; cin >> id;
            if (last[id] == 0) add(S, i, first[id]);
            else add(last[id], i, INF);
            last[id] = i;
        }
        int b; cin >> b;
        add(i, T, b);
    }

    cout << dinic() << '\n';

    return 0;
}
```

## 最小割

### 算法模板

#### Dinic/ISAP求最小割

题目：https://www.acwing.com/problem/content/2175/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e4, M = 1e5 * 2 + 10, INF = 1e8;

int n, m, S, T;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (w && dist[v] == -1)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }
    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;

    int flow = 0;
    for (int p = cur[u]; p && lim; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, w = E[p].w;
        if (w && dist[v] == dist[u] + 1)
        {
            int t = dfs(v, std::min(w, lim));
            if (t == 0) dist[v] = -1;
            E[p].w -= t, E[p ^ 1].w += t;
            flow += t, lim -= t;
        }
    }

    return flow;
}

int dinic()
{
    int mf = 0, flow = 0;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m >> S >> T;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w);
    }

    cout << dinic() << '\n';

    return 0;
}
```

### 直接应用

#### 网络战争

题目：https://www.acwing.com/problem/content/2281/

题解：https://www.acwing.com/solution/content/128176/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 110, M = 810;
const double INF = 1e10, eps = 1e-8;

int n, m, S, T;
int H[N];
struct EdgeNode
{
    int v;
    double c, f;
    int n;
} E[M];
int idx = 1;

void add(int a, int b, double c)
{
    E[++idx] = { b, c, 0, H[a] }, H[a] = idx;
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            double f = E[p].f;
            if (f > eps && dist[v] == -1)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }
    return false;
}

double dfs(int u, double lim)
{
    if (u == T) return lim;

    double flow = 0;
    for (int p = cur[u]; p && lim > eps; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v;
        double f = E[p].f;
        if (f > eps && dist[v] == dist[u] + 1)
        {
            double t = dfs(v, std::min(f, lim));
            if (t < eps) dist[v] = -1;
            E[p].f -= t, E[p ^ 1].f += t;
            flow += t, lim -= t;
        }
    }
    return flow;
}

double dinic()
{
    double mf = 0, flow = 0;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m >> S >> T;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w), add(b, a, w);
    }

    double l = 0, r = 1e7;
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        double t = 0;  // 非正边权的和
        for (int p = 2; p <= idx; p += 2)  // 建图
        {
            if (E[p].c - mid <= 0)
            {
                E[p].f = E[p ^ 1].f = 0;
                t += E[p].c - mid;
            }
            else
            {
                E[p].f = E[p ^ 1].f = E[p].c - mid;
            }
        }
        if (t + dinic() < 0) r = mid;
        else l = mid;
    }

    printf("%.2lf\n", l);

    return 0;
}
```

#### 最优标号

题目：https://www.acwing.com/problem/content/description/2282/

题解：https://www.acwing.com/solution/content/128199/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 510, M = (3000 + N) * 2, INF = 1e8;

int n, m, S = 0, T = N - 1;
struct Edge
{
    int a, b;
} edge[3010];
int label[N];  // 点的标号

int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
}

void build(int k)  // 建图
{
    memset(H, 0, sizeof H);
    idx = 1;

    for (int u = 1; u <= n; u++)
        if (label[u] >= 0)
        {
            if (label[u] >> k & 1) add(u, T, INF), add(T, u, INF);
            else add(S, u, INF), add(u, S, INF);
        }
    
    for (int i = 0; i < m; i++)
    {
        auto [a, b] = edge[i];
        add(a, b, 1), add(b, a, 1);
    }
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (w && dist[v] == -1)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }
    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;

    int flow = 0;
    for (int p = cur[u]; p && lim; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, w = E[p].w;
        if (w && dist[v] == dist[u] + 1)
        {
            int t = dfs(v, std::min(w, lim));
            if (t == 0) dist[v] = -1;
            E[p].w -= t, E[p ^ 1].w += t;
            flow += t, lim -= t;
        }
    }
    return flow;
}

int dinic()
{
    int mf = 0, flow = 0;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        edge[i] = { a, b };
    }
    memset(label, -1, sizeof label);
    int t; cin >> t;
    while (t--)
    {
        int u, p; cin >> u >> p;
        label[u] = p;
    }

    LL res = 0;
    for (int i = 0; i < 31; i++)
    {
        build(i);
        res += LL(dinic()) << i;
    }

    cout << res << '\n';

    return 0;
}
```

### 最大权闭合图

#### 最大获利

题目：https://www.acwing.com/problem/content/description/963/

**方法：最大权闭合图**

题解：《最小割模型在信息学竞赛中的应用》

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 5e4 + 5010, M = (1e5 + 5e4 + 5000) * 2 + 10;
const int INF = 1e8;

int n, m, S = 0, T = N - 1;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (w && dist[v] == -1)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }
    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;

    int flow = 0;
    for (int p = cur[u]; p && lim; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, w = E[p].w;
        if (w && dist[v] == dist[u] + 1)
        {
            int t = dfs(v, std::min(w, lim));
            if (t == 0) dist[v] = -1;
            E[p].w -= t, E[p ^ 1].w += t;
            flow += t, lim -= t;
        }
    }
    return flow;
}

int dinic()
{
    int mf = 0, flow;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        int p; cin >> p;
        add(i, T, p);
    }
    int tot = 0;
    for (int i = 1; i <= m; i++)
    {
        int a, b, c; cin >> a >> b >> c;
        add(S, n + i, c);
        add(n + i, a, INF);
        add(n + i, b, INF);
        tot += c;
    }

    cout << tot - dinic() << '\n';

    return 0;
}
```

**方法：最大密度子图**

题解：《最小割模型在信息学竞赛中的应用》

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 5010, M = (5e4 + 5000 * 2) * 2 + 10;
const int INF = 1e8;

int n, m;
int P[N], dg[N];
int S, T;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w1, int w2)
{
    E[++idx] = { b, w1, H[a] }, H[a] = idx;
    E[++idx] = { a, w2, H[b] }, H[b] = idx;
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0, cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int i = H[u]; i; i = E[i].n)
        {
            int v = E[i].v, w = E[i].w;
            if (w && dist[v] == -1)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }
    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;

    int flow = 0;
    for (int i = cur[u]; i && flow < lim; i = E[i].n)
    {
        cur[u] = i;
        int v = E[i].v, w = E[i].w;
        if (w && dist[v] == dist[u] + 1)
        {
            int t = dfs(v, std::min(w, lim - flow));
            if (t == 0) dist[v] = -1;
            E[i].w -= t, E[i ^ 1].w += t;
            flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int mf = 0, flow = 0;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    S = 0, T = n + 1;
    for (int i = 1; i <= n; i++)
    {
        int p; cin >> p;
        P[i] = -p;
    }
    for (int i = 1; i <= m; i++)
    {
        int a, b, c; cin >> a >> b >> c;
        add(a, b, c, c);
        dg[a] += c, dg[b] += c;
    }
    int U = 0;
    for (int i = 1; i <= n; i++)
    {
        U = std::max(U, P[i] * 2 + dg[i]);
    }
    for (int i = 1; i <= n; i++)
    {
        add(S, i, U, 0);
        add(i, T, U - P[i] * 2 - dg[i], 0);
    }

    cout << (U * n - dinic()) / 2 << '\n';

    return 0;
}
```



### 最大密度子图

#### 生活的艰辛

题目：https://www.acwing.com/problem/content/description/2326/

题解：https://www.luogu.com.cn/article/8bqq50t8

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 110, M = (1000 + 100 * 2) * 2 + 10;
const double inf = 1e6, eps = 1e-8;

struct Edge
{
    int a, b;
} edge[M];

int n, m, S = 0, T = N - 1;
int H[N];
struct EdgeNode
{
    int v;
    double w;
    int n;
} E[M];
int idx;

void add(int a, int b, double w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
}

int dg[N];

void build(double g)
{
    memset(H, 0, sizeof H);
    idx = 1;

    for (int i = 1; i <= n; i++)
    {
        add(S, i, m), add(i, S, 0);
        add(i, T, m + g * 2 - dg[i]), add(T, i, 0);
    }

    for (int i = 0; i < m; i++)
    {
        auto [a, b] = edge[i];
        add(a, b, 1), add(b, a, 1);
    }
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0, cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int i = H[u]; i; i = E[i].n)
        {
            int v = E[i].v;
            double w = E[i].w;
            if (w > eps && dist[v] == -1)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }
    return false;
}

double dfs(int u, double lim)
{
    if (u == T) return lim;

    double flow = 0;
    for (int i = cur[u]; i && lim > flow; i = E[i].n)
    {
        cur[u] = i;
        int v = E[i].v;
        double w = E[i].w;
        if (w > eps && dist[v] == dist[u] + 1)
        {
            double t = dfs(v, std::min(w, lim - flow));
            if (t < eps) dist[v] = -1;
            E[i].w -= t, E[i ^ 1].w += t;
            flow += t;
        }
    }

    return flow;
}

double dinic()
{
    double mf = 0, flow;
    while (bfs())
    {
        while (flow = dfs(S, inf)) mf += flow;
    }
    return mf;
}

bool st[N];
int res = -1;

void dfs(int u)
{
    st[u] = true;
    res++;
    for (int i = H[u]; i; i = E[i].n)
    {
        int v = E[i].v;
        double w = E[i].w;
        if (w > 0 && !st[v])  // 这里不能改成w > eps，否则会出错
        {
            dfs(v);
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        edge[i] = { a, b };
        dg[a]++, dg[b]++;
    }

    double l = 0, r = m;
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        build(mid);
        if (m * n - dinic() > 0) l = mid;
        else r = mid;
    }

    build(l);
    dinic();
    dfs(S);

    if (res == 0)
    {
        cout << 1 << '\n';
        cout << 1 << '\n';
    }
    else
    {
        cout << res << '\n';
        for (int i = 1; i <= n; i++)
            if (st[i])
                cout << i << '\n';
    }

    return 0;
}
```

