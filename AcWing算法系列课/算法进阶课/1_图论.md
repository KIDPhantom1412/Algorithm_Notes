# 图论

## 最大流

### 算法模板

#### EK求最大流

题目：https://www.acwing.com/problem/content/description/2173/

题解：《算法竞赛进阶指南》p441

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1010, M = 2e4 + 5, INF = 1 << 30;

int n, m, S, T;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;  // a->b
    E[++idx] = { a, 0, H[b] }, H[b] = idx;  // b->a
}

int f[N], pre[N];
int Q[N];
bool st[N];

bool bfs()
{
    memset(st, 0, sizeof st);
    int hh = 0, tt = 0;
    st[S] = true;
    f[S] = INF;
    Q[tt++] = S;
    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (!st[v] && w != 0)
            {
                int v = E[p].v, w = E[p].w;
                f[v] = std::min(f[u], w);
                pre[v] = p;
                if (v == T) return true;
                st[v] = true;
                Q[tt++] = v;
            }
        }
    }

    return false;
}

int EK()
{
    int mf = 0;  // 最大流
    while (bfs())
    {
        int t = f[T];
        mf += t;
        for (int i = T; i != S; i = E[pre[i] ^ 1].v)
        {
            E[pre[i]].w -= t, E[pre[i] ^ 1].w += t;
        }
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m >> S >> T;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w);
    }

    cout << EK() << '\n';

    return 0;
}
```

#### Dinic/ISAP求最大流

题目：https://www.acwing.com/problem/content/2174/

题解：《算法竞赛》p668

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e4 + 5, M = 2e5 + 5, INF = 1 << 30;

int n, m, S, T;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;
    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[v] == -1 && w != 0)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }

    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;
    
    int flow = 0;
    for (int i = H[u]; i && flow < lim; i = E[i].n)
    {
        int v = E[i].v, w = E[i].w;
        if (w && dist[v] == dist[u] + 1)
        {
            int t = dfs(v, std::min(w, lim - flow));
            if (t == 0) dist[v] = -1;
            E[i].w -= t, E[i ^ 1].w += t;
            flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int mf = 0, flow = 0;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m >> S >> T;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w);
    }

    cout << dinic() << '\n';

    return 0;
}
```

### 二分图匹配

#### 飞行员配对方案问题

题目：https://www.acwing.com/problem/content/description/2177/

题解：《算法竞赛》p676

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 110, M = 5210, INF = 1e8;

int n, m, S, T;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;
    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[v] == -1 && w > 0)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }

    return false;
}

int dfs(int u, int limit)
{
    if (u == T) return limit;

    int flow = 0;
    for (int p = cur[u]; p && limit; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, w = E[p].w;
        if (dist[v] == dist[u] + 1 && w > 0)
        {
            int t = dfs(v, std::min(limit, w));
            if (t == 0) dist[v] = -1;
            E[p].w -= t;
            E[p ^ 1].w += t;
            flow += t;
            limit -= t;
        }
    }

    return flow;
}

int dinic()
{
    int mf = 0, flow = 0;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> m >> n;
    S = 0, T = n + 1;
    for (int i = 1; i <= m; i++) add(S, i, 1);
    for (int i = m + 1; i <= n; i++) add(i, T, 1);
    int a, b;
    while (cin >> a >> b, a != -1) add(a, b, 1);

    cout << dinic() << '\n';
    for (int p = n * 2 + 2; p <= idx; p += 2)
        if (E[p].w == 0)
        {
            cout << E[p ^ 1].v << ' ' << E[p].v << '\n';
        }

    return 0;
}
```

#### 圆桌问题

题目：https://www.acwing.com/problem/content/description/2181/

题解：https://www.acwing.com/solution/content/40811/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 430, M = (N + 150 * 270) * 2, INF = 1 << 30;

int n, m, S, T;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[v] == -1 && w != 0)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }

    return false;
}

int dfs(int u, int limit)
{
    if (u == T) return limit;

    int flow = 0;
    for (int p = cur[u]; p && limit; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, w = E[p].w;
        if (dist[v] == dist[u] + 1 && w != 0)
        {
            int t = dfs(v, std::min(limit, w));
            if (t == 0) dist[v] = -1;
            else
            {
                E[p].w -= t;
                E[p ^ 1].w += t;
                limit -= t;
                flow += t;
            }
        }
    }

    return flow;
}

int dinic()
{
    int mf = 0, flow;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> m >> n;
    S = 0, T = m + n + 1;
    int tot = 0;
    for (int i = 1; i <= m; i++)
    {
        int x; cin >> x;
        add(S, i, x);
        tot += x;
    }
    for (int i = m + 1; i <= m + n; i++)
    {
        int x; cin >> x;
        add(i, T, x);
    }
    for (int i = 1; i <= m; i++)
        for (int j = m + 1; j <= m + n; j++)
            add(i, j, 1);

    if (tot == dinic())
    {
        cout << 1 << '\n';
        for (int u = 1; u <= m; u++)
        {
            for (int p = H[u]; p; p = E[p].n)
                if (E[p].w == 0)
                {
                    cout << (E[p].v - m) << ' ';
                }
            cout << '\n';
        }
    }
    else
    {
        cout << 0 << '\n';
    }

    return 0;
}
```

### 上下界可行流

#### 无源汇上下界可行流

题目：https://www.acwing.com/problem/content/description/2190/

题解：https://www.acwing.com/solution/content/61022/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 210, M = (10210 + N) * 2, INF = 1 << 30;

int n, m, S, T;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
}

int lb[M];   // 下界
int dif[N];  // 入边的下界和 - 出边的下界和

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[v] == -1 && w != 0)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }

    return false;
}

int dfs(int u, int limit)
{
    if (u == T) return limit;

    int flow = 0;
    for (int p = cur[u]; p && limit; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, w = E[p].w;
        if (dist[v] == dist[u] + 1 && w != 0)
        {
            int t = dfs(v, std::min(w, limit));
            if (t == 0) dist[v] = -1;
            else
            {
                E[p].w -= t, E[p ^ 1].w += t;
                flow += t, limit -= t;
            }
        }
    }

    return flow;
}

int dinic()
{
    int mf = 0, flow;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    S = 0, T = n + 1;
    for (int i = 0; i < m; i++)
    {
        int a, b, c, d; cin >> a >> b >> c >> d;
        add(a, b, d - c), lb[idx] = c;
        add(b, a, 0), lb[idx] = 0;
        dif[a] -= c, dif[b] += c;
    }
    int tot = 0;
    for (int u = 1; u <= n; u++)
    {
        if (dif[u] > 0)
        {
            add(S, u, dif[u]), add(u, S, 0);
            tot += dif[u];
        }
        else
        {
            add(u, T, -dif[u]), add(T, u, 0);
        }
    }

    if (tot == dinic())
    {
        cout << "YES" << '\n';
        for (int i = 2; i <= m * 2; i += 2)
        {
            cout << E[i ^ 1].w + lb[i] << '\n';
        }
    }
    else cout << "NO" << '\n';

    return 0;
}
```

#### 有源汇上下界最大流

题目：https://www.acwing.com/problem/content/description/2191/

题解：https://www.acwing.com/solution/content/123860/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 210, M = (1e4 + N) * 2, INF = 1e8;

int n, m, S, T;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int dif[N];  // 入边的下界和 - 出边的上界和

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[v] == -1 && w != 0)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }

    return false;
}

int dfs(int u, int limit)
{
    if (u == T) return limit;

    int flow = 0;
    for (int p = cur[u]; p && limit; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, w = E[p].w;
        if (dist[v] == dist[u] + 1 && w != 0)
        {
            int t = dfs(v, std::min(w, limit));
            if (t == 0) dist[v] = -1;
            else
            {
                E[p].w -= t, E[p ^ 1].w += t;
                flow += t, limit -= t;
            }
        }
    }

    return flow;
}

int dinic()
{
    int mf = 0, flow;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int s, t; cin >> n >> m >> s >> t;
    for (int i = 0; i < m; i++)
    {
        int a, b, c, d; cin >> a >> b >> c >> d;
        add(a, b, d - c);
        dif[a] -= c, dif[b] += c;
    }
    S = 0, T = n + 1;
    int tot = 0;
    for (int u = 1; u <= n; u++)
    {
        if (dif[u] > 0) add(S, u, dif[u]), tot += dif[u];
        else if (dif[u] < 0) add(u, T, -dif[u]);
    }
    add(t, s, INF);

    if (tot != dinic())
    {
        cout << "No Solution" << '\n';
    }
    else
    {
        int res = E[idx].w;
        E[idx].w = E[idx - 1].w = 0;
        S = s, T = t;
        res += dinic();
        cout << res << '\n';
    }

    return 0;
}
```

#### 有源汇上下界最小流

题目：https://www.acwing.com/problem/content/2192/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 5e4 + 10, M = (125003 + N) * 2, INF = 2147483647;

int n, m, S, T;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int dif[N];

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[v] == -1 && w != 0)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }

    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;

    int flow = 0;
    for (int p = cur[u]; p && lim; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, w = E[p].w;
        if (dist[v] == dist[u] + 1 && w != 0)
        {
            int t = dfs(v, std::min(w, lim));
            if (t == 0) dist[v] = -1;
            else
            {
                E[p].w -= t, E[p ^ 1].w += t;
                lim -= t, flow += t;
            }
        }
    }

    return flow;
}

int dinic()
{
    int mf = 0, flow = 0;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int s, t; cin >> n >> m >> s >> t;
    for (int i = 0; i < m; i++)
    {
        int a, b, c, d; cin >> a >> b >> c >> d;
        add(a, b, d - c);
        dif[a] -= c, dif[b] += c;
    }
    S = 0, T = n + 1;
    int tot = 0;
    for (int u = 1; u <= n; u++)
    {
        if (dif[u] > 0) add(S, u, dif[u]), tot += dif[u];
        else if (dif[u] < 0) add(u, T, -dif[u]);
    }
    add(t, s, INF);

    if (tot != dinic())
    {
        cout << "No Solution" << '\n';
    }
    else
    {
        int res = E[idx].w;
        S = t, T = s;
        E[idx].w = E[idx - 1].w = 0;
        res -= dinic();
        cout << res << '\n';
    }

    return 0;
}
```

### 多源汇最大流

#### 多源汇最大流

题目：https://www.acwing.com/problem/content/description/2236/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e4 + 5, M = (1e5 + N) * 2, INF = 1e9;

int n, m, sc, tc;
int S, T;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[v] == -1 && w != 0)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }

    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;

    int flow = 0;
    for (int p = cur[u]; p && lim; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, w = E[p].w;
        if (dist[v] == dist[u] + 1 && w != 0)
        {
            int t = dfs(v, std::min(w, lim));
            if (t == 0) dist[v] = -1;
            else
            {
                flow += t, lim -= t;
                E[p].w -= t, E[p ^ 1].w += t;
            }
        }
    }

    return flow;
}

int dinic()
{
    int mf = 0, flow;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m >> sc >> tc;
    S = 0, T = n + 1;
    for (int i = 0; i < sc; i++)
    {
        int x; cin >> x;
        add(S, x, INF);
    }
    for (int i = 0; i < tc; i++)
    {
        int x; cin >> x;
        add(x, T, INF);
    }
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w);
    }

    cout << dinic() << '\n';

    return 0;
}
```

### 关键边

#### 伊基的故事 I - 道路重建

题目：https://www.acwing.com/problem/content/description/2238/

题解：https://www.acwing.com/solution/content/123983/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 510, M = 1e4 + 5, INF = 1e8;

int n, m, S, T;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[v] == -1 && w != 0)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }

    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;

    int flow = 0;
    for (int p = cur[u]; p && lim; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, w = E[p].w;
        if (dist[v] == dist[u] + 1 && w != 0)
        {
            int t = dfs(v, std::min(w, lim));
            if (t == 0) dist[v] = -1;
            else
            {
                E[p].w -= t, E[p ^ 1].w += t;
                flow += t, lim -= t;
            }
        }
    }

    return flow;
}

int dinic()
{
    int mf = 0, flow;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

bool rs[N], rt[N];

void dfs(int u, bool st[], int flag)
{
    st[u] = true;
    for (int p = H[u]; p; p = E[p].n)
    {
        int t = p ^ flag;
        int v = E[p].v;
        if (!st[v] && E[t].w != 0)
        {
            dfs(v, st, flag);
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    S = 0, T = n - 1;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w);
    }
    
    dinic();
    dfs(S, rs, 0);
    dfs(T, rt, 1);

    int res = 0;
    for (int p = 2; p <= idx; p += 2)
    {
        int v = E[p].v, w = E[p].w;
        if (w == 0 && rt[v] && rs[E[p ^ 1].v])
            res++;
    }
    cout << res << '\n';

    return 0;
}
```

### 最大流判定

#### 秘密挤奶机

题目：https://www.acwing.com/problem/content/description/2279/

题解：https://www.acwing.com/solution/content/41534/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 210, M = 8e4 + 5, INF = 1e8;

int n, m, S, T, K;
int H[N];
struct EdgeNode
{
    int v, w, f, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, 0, H[a] }, H[a] = idx;
    E[++idx] = { a, w, 0, H[b] }, H[b] = idx;
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, f = E[p].f;
            if (dist[v] == -1 && f != 0)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }

    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return true;

    int flow = 0;
    for (int p = cur[u]; p && lim; p = E[p].n)
    {
        int v = E[p].v, f = E[p].f;
        if (dist[v] == dist[u] + 1 && f != 0)
        {
            int t = dfs(v, std::min(f, lim));
            if (t == 0) dist[v] = -1;
            else
            {
                flow += t, lim -= t;
                E[p].f -= t, E[p ^ 1].f += t;
            }
        }
    }

    return flow;
}

int dinic()
{
    int mf = 0, flow;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }

    return mf;
}

bool check(int mid)  // 二分答案
{
    for (int p = 2; p <= idx; p++)
    {
        if (E[p].w <= mid) E[p].f = 1;
        else E[p].f = 0;
    }

    return dinic() >= K;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m >> K;
    S = 1, T = n;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w);
    }

    int l = 1, r = 1e6;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }

    cout << l << '\n';

    return 0;
}
```

#### 星际转移问题

题目：https://www.acwing.com/problem/content/description/2189/

题解：https://www.acwing.com/solution/content/125870/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int STATION = 20, SHIP = 25, DAY = 1000, 
          N = STATION * DAY + 10, M = (N + SHIP * DAY) * 2, INF = 1e9;

int n, m, K, S, T;
struct Ship
{
    int h, r, S[STATION];
} ship[SHIP];

int get(int i, int j)  // 第i天的第j个空间站
{
    return i * STATION + j;
}

int H[N];
struct EdgeNode
{
    int v, f, n;
} E[M];
int idx = 1;

void add(int a, int b, int f)
{
    E[++idx] = { b, f, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int P[STATION];

int find(int x)
{
    if (x != P[x]) P[x] = find(P[x]);
    return P[x];
}

auto init = []
    {
        for (int i = 0; i < STATION; i++) P[i] = i;
        return 0;
    }();

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, f = E[p].f;
            if (dist[v] == -1 && f != 0)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            } 
        }
    }

    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;

    int flow = 0;
    for (int p = cur[u]; p && lim; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, f = E[p].f;
        if (dist[v] == dist[u] + 1 && f != 0)
        {
            int t = dfs(v, std::min(f, lim));
            if (t == 0) dist[v] = -1;
            flow += t, lim -= t;
            E[p].f -= t, E[p ^ 1].f += t;
        }
    }

    return flow;
}

int dinic()
{
    int mf = 0, flow = 0;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m >> K;
    for (int i = 0; i < m; i++)
    {
        cin >> ship[i].h >> ship[i].r;
        for (int j = 0; j < ship[i].r; j++)
        {
            int x; cin >> x;
            if (x == -1) x = n + 1;
            ship[i].S[j] = x;
        }
    }

    for (int i = 0; i < m; i++)
        for (int j = 1; j < ship[i].r; j++)
        {
            int a = ship[i].S[j - 1], b = ship[i].S[j];
            P[find(a)] = find(b);
        }
    if (find(0) != find(n + 1))
    {
        cout << 0 << '\n';
        return 0;
    }

    S = N - 2, T = N - 1;
    add(S, get(0, 0), K);
    //add(get(0, n + 1), T, INF);
    int res = 0;
    for (int day = 1; day < DAY; day++)
    {
        add(get(day, n + 1), T, INF);
        for (int i = 0; i <= n + 1; i++) 
        {
            add(get(day - 1, i), get(day, i), INF);
        }
        for (int i = 0; i < m; i++)
        {
            int h = ship[i].h, r = ship[i].r;
            int a = ship[i].S[(day - 1) % r],
                b = ship[i].S[day % r];
            add(get(day - 1, a), get(day, b), h);
        }

        res += dinic();
        if (res >= K)
        {
            cout << day << '\n';
            break;
        }
    }

    return 0;
}
```

### 拆点

#### 餐饮

题目：https://www.acwing.com/problem/content/description/2242/

题解：https://www.acwing.com/solution/content/125942/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 410, M = (100 * 3 + 10000 * 2) * 2 + 10, INF = 1e8;

int n, F, D, S = 0, T = N - 1;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[v] == -1 && w != 0)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }

    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;

    int flow = 0;
    for (int p = cur[u]; p && lim; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, w = E[p].w;
        if (dist[v] == dist[u] + 1 && w != 0)
        {
            int t = dfs(v, std::min(w, lim));
            if (t == 0) dist[v] = -1;
            E[p].w -= t, E[p ^ 1].w += t;
            flow += t, lim -= t;
        }
    }

    return flow;
}

int dinic()
{
    int mf = 0, flow = 0;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> F >> D;
    for (int i = 201; i <= 200 + F; i++) add(S, i, 1);
    for (int i = 301; i <= 300 + D; i++) add(i, T, 1);
    for (int i = 1; i <= n; i++)
    {
        add(i, 100 + i, 1);  // 拆点，入点->出点
        int a, b; cin >> a >> b;
        while (a--)
        {
            int x; cin >> x;
            add(200 + x, i, 1);
        }
        while (b--)
        {
            int x; cin >> x;
            add(100 + i, 300 + x, 1);
        }
    }

    cout << dinic() << '\n';

    return 0;
}
```

#### 最长递增子序列问题

题目：https://www.acwing.com/problem/content/2182/

题解：https://www.acwing.com/solution/content/41778/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1010, M = (500 + 125250) * 2 + 10, INF = 1e8;

int n;
int X[N], f[N];

int S = 0, T = N - 1;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int Q[N], cur[N], dist[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;
    
    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[v] == -1 && w != 0)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }

    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;

    int flow = 0;
    for (int p = cur[u]; p && lim; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, w = E[p].w;
        if (dist[v] == dist[u] + 1 && w != 0)
        {
            int t = dfs(v, std::min(w, lim));
            if (t == 0) dist[v] = -1;
            E[p].w -= t, E[p ^ 1].w += t;
            flow += t, lim -= t;
        }
    }

    return flow;
}

int dinic()
{
    int mf = 0, flow = 0;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    for (int i = 1; i <= n; i++) cin >> X[i];

    int s = 0;
    for (int i = 1; i <= n; i++)  // dp
    {
        f[i] = 1;
        for (int j = 1; j < i; j++)
            if (X[j] <= X[i])
            {
                f[i] = std::max(f[i], f[j] + 1);
            }
        s = std::max(s, f[i]);
    }

    for (int i = 1; i <= n; i++) // 建图
    {
        add(i, i + n, 1);  // 拆点限制流量

        if (f[i] == 1) add(S, i, 1);
        if (f[i] == s) add(i + n, T, 1);

        for (int j = 1; j < i; j++)
            if (f[i] == f[j] + 1 && X[j] <= X[i])
            {
                add(j + n, i, 1);
            }
    }

    cout << s << '\n';
    if (s == 1)
    {
        cout << n << '\n';
        cout << n << '\n';
        return 0;
    }

    int res = dinic();
    cout << res << '\n';

    for (int p = 2; p <= idx; p += 2)
    {
        int a = E[p ^ 1].v, b = E[p].v;
        if ((a == S && b == 1) ||
            (a == 1 && b == 1 + n) ||
            (a == n && b == n + n) ||
            (a == n + n && b == T))
        {
            E[p].w = INF;
            E[p ^ 1].w = 0;
        }
    }
    res += dinic();

    cout << res << '\n';

    return 0;
}
```

#### 企鹅游行

题目：https://www.acwing.com/problem/content/description/2280/

题解：https://www.acwing.com/solution/content/41823/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 210, M = (100 + 1e4) * 2 + 10, INF = 1e8;
const double eps = 1e-8;

int n, S = N - 1, T;
double md;
struct Point
{
    int x, y;
} P[N];

int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

bool check(int a, int b)
{
    int dx = P[a].x - P[b].x, dy = P[a].y - P[b].y;
    return dx * dx + dy * dy <= md * md + eps;
}

int Q[N], cur[N], dist[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[v] == -1 && w != 0)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }

    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;

    int flow = 0;
    for (int p = cur[u]; p && lim; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, w = E[p].w;
        if (dist[v] == dist[u] + 1 && w != 0)
        {
            int t = dfs(v, std::min(w, lim));
            if (t == 0) dist[v] = -1;
            E[p].w -= t, E[p ^ 1].w += t;
            flow += t, lim -= t;
        }
    }

    return flow;
}

int dinic()
{
    int mf = 0, flow = 0;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

void solve()
{
    memset(H, 0, sizeof H);
    idx = 1;

    cin >> n >> md;
    int tot = 0;
    for (int i = 0; i < n; i++)
    {
        int x, y, a, b; cin >> x >> y >> a >> b;
        P[i] = { x, y };
        tot += a;
        add(S, i, a);
        add(i, i + n, b);
    }

    for (int i = 0; i < n; i++)
        for (int j = 0; j < i; j++)
            if (check(i, j))
            {
                add(i + n, j, INF);
                add(j + n, i, INF);
            }

    int cnt = 0;
    for (T = 0; T < n; T++)
    {
        for (int p = 2; p <= idx; p += 2)  // 还原现场
        {
            E[p].w += E[p ^ 1].w;
            E[p ^ 1].w = 0;
        }
        if (tot == dinic())
        {
            cnt++;
            cout << T << ' ';
        }
    }

    if (cnt == 0) cout << -1 << '\n';
    else cout << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int t; cin >> t;
    while (t--)
        solve();

    return 0;
}
```

### 建图实战

#### 猪

题目：https://www.acwing.com/problem/content/description/2239/

题解：https://www.acwing.com/solution/content/17624/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 110, M = (1e5 + 100) * 2 + 10, INF = 1e8;
const int K = 1010;

int n, m, S = 0, T = N - 1;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int first[K];  // 表示猪舍的一开始猪的数量
int last[K];   // 表示上一个拥有该猪舍钥匙的顾客的编号

int Q[N], cur[N], dist[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (dist[v] == -1 && w != 0)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }

    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;

    int flow = 0;
    for (int p = cur[u]; p && lim; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, w = E[p].w;
        if (dist[v] == dist[u] + 1 && w != 0)
        {
            int t = dfs(v, std::min(w, lim));
            if (t == 0) dist[v] = -1;
            E[p].w -= t, E[p ^ 1].w += t;
            flow += t, lim -= t;
        }
    }

    return flow;
}

int dinic()
{
    int mf = 0, flow = 0;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> m >> n;
    for (int i = 1; i <= m; i++) cin >> first[i];
    for (int i = 1; i <= n; i++)
    {
        int a; cin >> a;
        while (a--)
        {
            int id; cin >> id;
            if (last[id] == 0) add(S, i, first[id]);
            else add(last[id], i, INF);
            last[id] = i;
        }
        int b; cin >> b;
        add(i, T, b);
    }

    cout << dinic() << '\n';

    return 0;
}
```

## 最小割

### 算法模板

#### Dinic/ISAP求最小割

题目：https://www.acwing.com/problem/content/2175/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e4, M = 1e5 * 2 + 10, INF = 1e8;

int n, m, S, T;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (w && dist[v] == -1)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }
    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;

    int flow = 0;
    for (int p = cur[u]; p && lim; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, w = E[p].w;
        if (w && dist[v] == dist[u] + 1)
        {
            int t = dfs(v, std::min(w, lim));
            if (t == 0) dist[v] = -1;
            E[p].w -= t, E[p ^ 1].w += t;
            flow += t, lim -= t;
        }
    }

    return flow;
}

int dinic()
{
    int mf = 0, flow = 0;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m >> S >> T;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w);
    }

    cout << dinic() << '\n';

    return 0;
}
```

### 直接应用

#### 网络战争

题目：https://www.acwing.com/problem/content/2281/

题解：https://www.acwing.com/solution/content/128176/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 110, M = 810;
const double INF = 1e10, eps = 1e-8;

int n, m, S, T;
int H[N];
struct EdgeNode
{
    int v;
    double c, f;
    int n;
} E[M];
int idx = 1;

void add(int a, int b, double c)
{
    E[++idx] = { b, c, 0, H[a] }, H[a] = idx;
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v;
            double f = E[p].f;
            if (f > eps && dist[v] == -1)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }
    return false;
}

double dfs(int u, double lim)
{
    if (u == T) return lim;

    double flow = 0;
    for (int p = cur[u]; p && lim > eps; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v;
        double f = E[p].f;
        if (f > eps && dist[v] == dist[u] + 1)
        {
            double t = dfs(v, std::min(f, lim));
            if (t < eps) dist[v] = -1;
            E[p].f -= t, E[p ^ 1].f += t;
            flow += t, lim -= t;
        }
    }
    return flow;
}

double dinic()
{
    double mf = 0, flow = 0;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m >> S >> T;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(a, b, w), add(b, a, w);
    }

    double l = 0, r = 1e7;
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        double t = 0;  // 非正边权的和
        for (int p = 2; p <= idx; p += 2)  // 建图
        {
            if (E[p].c - mid <= 0)
            {
                E[p].f = E[p ^ 1].f = 0;
                t += E[p].c - mid;
            }
            else
            {
                E[p].f = E[p ^ 1].f = E[p].c - mid;
            }
        }
        if (t + dinic() < 0) r = mid;
        else l = mid;
    }

    printf("%.2lf\n", l);

    return 0;
}
```

#### 最优标号

题目：https://www.acwing.com/problem/content/description/2282/

题解：https://www.acwing.com/solution/content/128199/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 510, M = (3000 + N) * 2, INF = 1e8;

int n, m, S = 0, T = N - 1;
struct Edge
{
    int a, b;
} edge[3010];
int label[N];  // 点的标号

int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
}

void build(int k)  // 建图
{
    memset(H, 0, sizeof H);
    idx = 1;

    for (int u = 1; u <= n; u++)
        if (label[u] >= 0)
        {
            if (label[u] >> k & 1) add(u, T, INF), add(T, u, INF);
            else add(S, u, INF), add(u, S, INF);
        }
    
    for (int i = 0; i < m; i++)
    {
        auto [a, b] = edge[i];
        add(a, b, 1), add(b, a, 1);
    }
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (w && dist[v] == -1)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }
    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;

    int flow = 0;
    for (int p = cur[u]; p && lim; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, w = E[p].w;
        if (w && dist[v] == dist[u] + 1)
        {
            int t = dfs(v, std::min(w, lim));
            if (t == 0) dist[v] = -1;
            E[p].w -= t, E[p ^ 1].w += t;
            flow += t, lim -= t;
        }
    }
    return flow;
}

int dinic()
{
    int mf = 0, flow = 0;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        edge[i] = { a, b };
    }
    memset(label, -1, sizeof label);
    int t; cin >> t;
    while (t--)
    {
        int u, p; cin >> u >> p;
        label[u] = p;
    }

    LL res = 0;
    for (int i = 0; i < 31; i++)
    {
        build(i);
        res += LL(dinic()) << i;
    }

    cout << res << '\n';

    return 0;
}
```

### 最大权闭合图

#### 最大获利

题目：https://www.acwing.com/problem/content/description/963/

**方法：最大权闭合图**

题解：《最小割模型在信息学竞赛中的应用》

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 5e4 + 5010, M = (1e5 + 5e4 + 5000) * 2 + 10;
const int INF = 1e8;

int n, m, S = 0, T = N - 1;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0;
    cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int p = H[u]; p; p = E[p].n)
        {
            int v = E[p].v, w = E[p].w;
            if (w && dist[v] == -1)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }
    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;

    int flow = 0;
    for (int p = cur[u]; p && lim; p = E[p].n)
    {
        cur[u] = p;
        int v = E[p].v, w = E[p].w;
        if (w && dist[v] == dist[u] + 1)
        {
            int t = dfs(v, std::min(w, lim));
            if (t == 0) dist[v] = -1;
            E[p].w -= t, E[p ^ 1].w += t;
            flow += t, lim -= t;
        }
    }
    return flow;
}

int dinic()
{
    int mf = 0, flow;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        int p; cin >> p;
        add(i, T, p);
    }
    int tot = 0;
    for (int i = 1; i <= m; i++)
    {
        int a, b, c; cin >> a >> b >> c;
        add(S, n + i, c);
        add(n + i, a, INF);
        add(n + i, b, INF);
        tot += c;
    }

    cout << tot - dinic() << '\n';

    return 0;
}
```

**方法：最大密度子图**

题解：《最小割模型在信息学竞赛中的应用》

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 5010, M = (5e4 + 5000 * 2) * 2 + 10;
const int INF = 1e8;

int n, m;
int P[N], dg[N];
int S, T;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w1, int w2)
{
    E[++idx] = { b, w1, H[a] }, H[a] = idx;
    E[++idx] = { a, w2, H[b] }, H[b] = idx;
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0, cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int i = H[u]; i; i = E[i].n)
        {
            int v = E[i].v, w = E[i].w;
            if (w && dist[v] == -1)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }
    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;

    int flow = 0;
    for (int i = cur[u]; i && flow < lim; i = E[i].n)
    {
        cur[u] = i;
        int v = E[i].v, w = E[i].w;
        if (w && dist[v] == dist[u] + 1)
        {
            int t = dfs(v, std::min(w, lim - flow));
            if (t == 0) dist[v] = -1;
            E[i].w -= t, E[i ^ 1].w += t;
            flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int mf = 0, flow = 0;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    S = 0, T = n + 1;
    for (int i = 1; i <= n; i++)
    {
        int p; cin >> p;
        P[i] = -p;
    }
    for (int i = 1; i <= m; i++)
    {
        int a, b, c; cin >> a >> b >> c;
        add(a, b, c, c);
        dg[a] += c, dg[b] += c;
    }
    int U = 0;
    for (int i = 1; i <= n; i++)
    {
        U = std::max(U, P[i] * 2 + dg[i]);
    }
    for (int i = 1; i <= n; i++)
    {
        add(S, i, U, 0);
        add(i, T, U - P[i] * 2 - dg[i], 0);
    }

    cout << (U * n - dinic()) / 2 << '\n';

    return 0;
}
```



### 最大密度子图

#### 生活的艰辛

题目：https://www.acwing.com/problem/content/description/2326/

题解：https://www.luogu.com.cn/article/8bqq50t8

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 110, M = (1000 + 100 * 2) * 2 + 10;
const double inf = 1e6, eps = 1e-8;

struct Edge
{
    int a, b;
} edge[M];

int n, m, S = 0, T = N - 1;
int H[N];
struct EdgeNode
{
    int v;
    double w;
    int n;
} E[M];
int idx;

void add(int a, int b, double w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
}

int dg[N];

void build(double g)
{
    memset(H, 0, sizeof H);
    idx = 1;

    for (int i = 1; i <= n; i++)
    {
        add(S, i, m), add(i, S, 0);
        add(i, T, m + g * 2 - dg[i]), add(T, i, 0);
    }

    for (int i = 0; i < m; i++)
    {
        auto [a, b] = edge[i];
        add(a, b, 1), add(b, a, 1);
    }
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0, cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int i = H[u]; i; i = E[i].n)
        {
            int v = E[i].v;
            double w = E[i].w;
            if (w > eps && dist[v] == -1)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }
    return false;
}

double dfs(int u, double lim)
{
    if (u == T) return lim;

    double flow = 0;
    for (int i = cur[u]; i && lim > flow; i = E[i].n)
    {
        cur[u] = i;
        int v = E[i].v;
        double w = E[i].w;
        if (w > eps && dist[v] == dist[u] + 1)
        {
            double t = dfs(v, std::min(w, lim - flow));
            if (t < eps) dist[v] = -1;
            E[i].w -= t, E[i ^ 1].w += t;
            flow += t;
        }
    }

    return flow;
}

double dinic()
{
    double mf = 0, flow;
    while (bfs())
    {
        while (flow = dfs(S, inf)) mf += flow;
    }
    return mf;
}

bool st[N];
int res = -1;

void dfs(int u)
{
    st[u] = true;
    res++;
    for (int i = H[u]; i; i = E[i].n)
    {
        int v = E[i].v;
        double w = E[i].w;
        if (w > 0 && !st[v])  // 这里不能改成w > eps，否则会出错
        {
            dfs(v);
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        edge[i] = { a, b };
        dg[a]++, dg[b]++;
    }

    double l = 0, r = m;
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        build(mid);
        if (m * n - dinic() > 0) l = mid;
        else r = mid;
    }

    build(l);
    dinic();
    dfs(S);

    if (res == 0)
    {
        cout << 1 << '\n';
        cout << 1 << '\n';
    }
    else
    {
        cout << res << '\n';
        for (int i = 1; i <= n; i++)
            if (st[i])
                cout << i << '\n';
    }

    return 0;
}
```

### 最小点权覆盖集

#### 有向图破坏

题目：https://www.acwing.com/problem/content/description/2327/

题解：https://www.acwing.com/solution/content/132309/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 210, M = (5000 + 200) * 2 + 10, INF = 1e9;

int n, m, S = 0, T = N - 1;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0, cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int i = H[u]; i; i = E[i].n)
        {
            int v = E[i].v, w = E[i].w;
            if (w && dist[v] == -1)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }
    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;

    int flow = 0;
    for (int i = cur[u]; i && flow < lim; i = E[i].n)
    {
        cur[u] = i;
        int v = E[i].v, w = E[i].w;
        if (w && dist[v] == dist[u] + 1)
        {
            int t = dfs(v, std::min(w, lim - flow));
            if (t == 0) dist[v] = -1;
            E[i].w -= t, E[i ^ 1].w += t;
            flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int mf = 0, flow;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

bool st[N];

void dfs(int u)  // 标记S集合
{
    st[u] = true;

    for (int i = H[u]; i; i = E[i].n)
    {
        int v = E[i].v, w = E[i].w;
        if (w && !st[v])
            dfs(v);
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        int w; cin >> w;
        add(S, i, w);
    }
    for (int i = 1; i <= n; i++)
    {
        int w; cin >> w;
        add(n + i, T, w);
    }
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        add(b, n + a, INF);
    }

    cout << dinic() << '\n';

    dfs(S);
    int cnt = 0;  // 割边的数量
    for (int i = 2; i <= idx; i += 2)
    {
        int a = E[i ^ 1].v, b = E[i].v;
        if (st[a] && !st[b])
        {
            cnt++;
        }
    }
    cout << cnt << '\n';

    for (int i = 2; i <= idx; i += 2)
    {
        int a = E[i ^ 1].v, b = E[i].v;
        if (st[a] && !st[b])
        {
            if (a == S) cout << b << " +\n";
            else if (b == T) cout << a - n << " -\n";
        }
    }

    return 0;
}
```

### 最大点权独立集

#### 王者之剑

题目：https://www.acwing.com/problem/content/description/2328/

题解：https://www.luogu.com.cn/article/pzpx5dgl

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e4 + 5, M = (1e4 + 2e4) * 2 + 5, INF = 1e8;

int n, m;
int S = 0, T = N - 1;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int get(int x, int y)
{
    return x * m + y + 1;
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0, cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int i = H[u]; i; i = E[i].n)
        {
            int v = E[i].v, w = E[i].w;
            if (w && dist[v] == -1)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }
    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;

    int flow = 0;
    for (int i = cur[u]; i && flow < lim; i = E[i].n)
    {
        int v = E[i].v, w = E[i].w;
        if (w && dist[v] == dist[u] + 1)
        {
            int t = dfs(v, std::min(w, lim - flow));
            if (t == 0) dist[v] = -1;
            E[i].w -= t, E[i ^ 1].w += t;
            flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int mf = 0, flow;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, 1, 0, -1 };
    cin >> n >> m;
    int tot = 0;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
        {
            int u = get(i, j);
            int w; cin >> w;
            if ((i + j) % 2)
            {
                add(S, u, w);
                for (int k = 0; k < 4; k++)
                {
                    int x = i + dx[k], y = j + dy[k];
                    if (x >= 0 && x < n && y >= 0 && y < m)
                    {
                        add(u, get(x, y), INF);
                    }
                }
            }
            else
            {
                add(u, T, w);
            }

            tot += w;
        }

    cout << tot - dinic() << '\n';

    return 0;
}
```

### 建图实战

#### 有线电视网络

题目：https://www.acwing.com/problem/content/description/383/

题解：https://www.acwing.com/solution/content/114415/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

const int N = 110, M = 5050 * 2 + 10, INF = 1e8;

int n, m, S, T;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx;

void add(int a, int b, int w)
{
    E[++idx] = {b, w, H[a]}, H[a] = idx;
    E[++idx] = {a, 0, H[b]}, H[b] = idx;
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0, cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;
    
    while (hh != tt)
    {
        int u = Q[hh++];
        for (int i = H[u]; i; i = E[i].n)
        {
            int v = E[i].v, w = E[i].w;
            if (w && dist[v] == -1)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }
    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;
    
    int flow = 0;
    for (int i = cur[u]; i && flow < lim; i = E[i].n)
    {
        cur[u] = i;
        int v = E[i].v, w = E[i].w;
        if (w && dist[v] == dist[u] + 1)
        {
            int t = dfs(v, std::min(w, lim - flow));
            if (t == 0) dist[v] = -1;
            E[i].w -= t, E[i ^ 1].w += t;
            flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int mf = 0, flow;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}


void solve()
{
    memset(H, 0, sizeof H);
    idx = 1;
    
    for (int i = 0; i < n; i++) add(i, n + i, 1);
    for (int i = 0; i < m; i++)
    {
        int a, b; scanf(" (%d,%d)", &a, &b);
        add(n + a, b, INF), add(n + b, a, INF);
    }
    
    int res = n;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < i; j++)
        {
            S = n + i, T = j;
            for (int i = 2; i <= idx; i += 2)
            {
                E[i].w += E[i ^ 1].w;
                E[i ^ 1].w = 0;
            }
            res = std::min(res, dinic());
        }
    
    std::cout << res << '\n';
}

int main()
{
    while (std::cin >> n >> m)
    {
        solve();
    }
    
    return 0;
}
```

#### 太空飞行计划问题

题目：https://www.acwing.com/problem/content/2178/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <sstream>

using LL = long long;
using std::cin, std::cout;

const int N = 110, M = (100 + 2500) * 2 + 10, INF = 1e8;

int n, m;
int S = 0, T = N - 1;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0, cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int i = H[u]; i; i = E[i].n)
        {
            int v = E[i].v, w = E[i].w;
            if (w && dist[v] == -1)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }
    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;

    int flow = 0;
    for (int i = cur[u]; i && flow < lim; i = E[i].n)
    {
        cur[u] = i;
        int v = E[i].v, w = E[i].w;
        if (w && dist[v] == dist[u] + 1)
        {
            int t = dfs(v, std::min(w, lim - flow));
            if (t == 0) dist[v] = -1;
            E[i].w -= t, E[i ^ 1].w += t;
            flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int mf = 0, flow;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

bool st[N];

void dfs(int u)
{
    st[u] = true;
    for (int i = H[u]; i; i = E[i].n)
    {
        int v = E[i].v, w = E[i].w;
        if (w && !st[v])
        {
            dfs(v);
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> m >> n;
    int tot = 0;
    std::string line; std::getline(cin, line);  // 读取空格
    for (int i = 1; i <= m; i++)
    {
        std::getline(cin, line);
        std::stringstream ss(line);
        int w; ss >> w;
        add(S, i, w);
        tot += w;
        int j;
        while (ss >> j)
        {
            add(i, m + j, INF);
        }
    }
    for (int i = 1; i <= n; i++)
    {
        int w; cin >> w;
        add(m + i, T, w);
    }

    int res = tot - dinic();
    dfs(S);
    for (int i = 1; i <= m; i++)
        if (st[i])
        {
            cout << i << ' ';
        }
    cout << '\n';
    for (int i = m + 1; i <= m + n; i++)
        if (st[i])
        {
            cout << i - m << ' ';
        }
    cout << '\n';
    cout << res << '\n';

    return 0;
}
```

#### 骑士共存问题

题目：https://www.acwing.com/problem/content/description/2200/

题解：https://www.acwing.com/solution/content/133616/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 4e4 + 5, M = (4e4 * 8 + 4e4 * 2) * 2 + 10, INF = 1e8;

int n, m;
bool st[210][210];
int S, T = N - 1;
int H[N];
struct EdgeNode
{
    int v, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w)
{
    E[++idx] = { b, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, H[b] }, H[b] = idx;
}

int get(int i, int j)
{
    return (i - 1) * n + j;
}

int dx[8] = { -2, -1, 1, 2, 2, 1, -1, -2 };
int dy[8] = { 1, 2, 2, 1, -1, -2, -2, -1 };

int Q[N], dist[N], cur[N];

bool bfs()
{
    memset(dist, -1, sizeof dist);
    dist[S] = 0, cur[S] = H[S];
    int hh = 0, tt = 0;
    Q[tt++] = S;

    while (hh != tt)
    {
        int u = Q[hh++];
        for (int i = H[u]; i; i = E[i].n)
        {
            int v = E[i].v, w = E[i].w;
            if (w && dist[v] == -1)
            {
                dist[v] = dist[u] + 1;
                cur[v] = H[v];
                if (v == T) return true;
                Q[tt++] = v;
            }
        }
    }
    return false;
}

int dfs(int u, int lim)
{
    if (u == T) return lim;

    int flow = 0;
    for (int i = cur[u]; i && flow < lim; i = E[i].n)
    {
        cur[u] = i;
        int v = E[i].v, w = E[i].w;
        if (w && dist[v] == dist[u] + 1)
        {
            int t = dfs(v, std::min(w, lim - flow));
            if (t == 0) dist[v] = -1;
            E[i].w -= t, E[i ^ 1].w += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int mf = 0, flow;
    while (bfs())
    {
        while (flow = dfs(S, INF)) mf += flow;
    }
    return mf;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int x, y; cin >> x >> y;
        st[x][y] = true;
    }

    int tot = 0;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            if (!st[i][j])
            {
                int u = get(i, j);
                if (i + j & 1)
                {
                    add(S, u, 1);
                    for (int k = 0; k < 8; k++)
                    {
                        int x = i + dx[k], y = j + dy[k];
                        if (x >= 1 && x <= n && y >= 1 && y <= n && !st[x][y])
                        {
                            add(u, get(x, y), INF);
                        }
                    }
                }
                else
                {
                    add(u, T, 1);
                }
                tot++;
            }

    cout << tot - dinic() << '\n';

    return 0;
}
```

## 费用流

### 算法模板

#### 费用流

题目：https://www.acwing.com/problem/content/description/2176/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 5010, M = 1e5 + 5, INF = 1e8;

int n, m, S, T;
int H[N];
struct EdgeNode
{
    int v, f, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int w, int f)
{
    E[++idx] = { b, f, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, -w, H[b] }, H[b] = idx;
}

bool st[N];
int Q[N], incf[N], pre[N], dist[N];

bool spfa()
{
    memset(dist, 0x3f, sizeof dist);
    memset(incf, 0, sizeof incf);
    dist[S] = 0, incf[S] = INF;
    int hh = 0, tt = 0;
    Q[tt++] = S, st[S] = true;

    while (hh != tt)
    {
        int u = Q[hh++]; hh %= N;
        st[u] = false;

        for (int i = H[u]; i; i = E[i].n)
        {
            int v = E[i].v, f = E[i].f, w = E[i].w;
            if (f && dist[v] > dist[u] + w)
            {
                dist[v] = dist[u] + w;
                pre[v] = i;
                incf[v] = std::min(f, incf[u]);
                if (!st[v])
                {
                    Q[tt++] = v; tt %= N;
                    st[v] = true;
                }
            }
        }
    }

    return incf[T] > 0;
}

void EK(int& flow, int& cost)
{
    flow = cost = 0;
    while (spfa())
    {
        int t = incf[T];
        flow += t, cost += t * dist[T];
        for (int i = T; i != S; i = E[pre[i] ^ 1].v)
        {
            E[pre[i]].f -= t, E[pre[i] ^ 1].f += t;
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m >> S >> T;
    for (int i = 0; i < m; i++)
    {
        int a, b, f, w; cin >> a >> b >> f >> w;
        add(a, b, w, f);
    }

    int cost, flow;
    EK(flow, cost);

    cout << flow << ' ' << cost << '\n';

    return 0;
}
```

### 直接应用

#### 运输问题

题目：https://www.acwing.com/problem/content/description/2194/

题解：https://www.acwing.com/solution/content/165251/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 160, M = (150 + 5000) * 2 + 10, INF = 1e8;

int n, m;
int S, T = N - 1;
int H[N];
struct EdgeNode
{
    int v, f, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int f, int w)
{
    E[++idx] = { b, f, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, -w, H[b] }, H[b] = idx;
}

int incf[N], dist[N], pre[N];
bool st[N];
int Q[N];

bool spfa()
{
    memset(dist, 0x3f, sizeof dist);
    memset(incf, 0, sizeof incf);
    dist[S] = 0, incf[S] = INF;
    int hh = 0, tt = 0;
    Q[tt++] = S;
    st[S] = true;

    while (hh != tt)
    {
        int u = Q[hh++]; hh %= N;
        st[u] = false;

        for (int i = H[u]; i; i = E[i].n)
        {
            int v = E[i].v, f = E[i].f, w = E[i].w;
            if (f && dist[u] + w < dist[v])
            {
                dist[v] = dist[u] + w;
                incf[v] = std::min(f, incf[u]);
                pre[v] = i;
                if (!st[v])
                {
                    Q[tt++] = v; tt %= N;
                    st[v] = true;
                }
            }
        }
    }

    return incf[T] > 0;
}

void EK(int& flow, int& cost)
{
    flow = cost = 0;
    while (spfa())
    {
        int t = incf[T];
        flow += t, cost += t * dist[T];
        for (int i = T; i != S; i = E[pre[i] ^ 1].v)
        {
            E[pre[i]].f -= t, E[pre[i] ^ 1].f += t;
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> m >> n;
    for (int i = 1; i <= m; i++)
    {
        int f; cin >> f;
        add(S, i, f, 0);
    }
    for (int i = 1; i <= n; i++)
    {
        int f; cin >> f;
        add(m + i, T, f, 0);
    }
    for (int i = 1; i <= m; i++)
        for (int j = 1; j <= n; j++)
        {
            int w; cin >> w;
            add(i, m + j, INF, w);
        }

    int flow, cost;
    EK(flow, cost);
    cout << cost << '\n';
    
    for (int i = 2; i <= idx; i += 2)
    {
        E[i].f += E[i ^ 1].f, E[i ^ 1].f = 0;
        E[i].w = -E[i].w, E[i ^ 1].w = -E[i ^ 1].w;
    }
    EK(flow, cost);
    cout << -cost << '\n';

    return 0;
}
```

#### 负载平衡问题

题目：https://www.acwing.com/problem/content/description/2196/

题解：https://www.acwing.com/solution/content/26755/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 110, M = 300 * 2 + 10, INF = 1e8;

int n, stock[N];
int S, T = N - 1;
int H[N];
struct EdgeNode
{
    int v, f, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int f, int w)
{
    E[++idx] = { b, f, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, -w, H[b] }, H[b] = idx;
}

int incf[N], dist[N], pre[N];
bool st[N];
int Q[N];

bool spfa()
{
    memset(incf, 0, sizeof incf);
    memset(dist, 0x3f, sizeof dist);
    dist[S] = 0, incf[S] = INF;
    int hh = 0, tt = 0;
    Q[tt++] = S;
    st[S] = true;

    while (hh != tt)
    {
        int u = Q[hh++]; hh %= N;
        st[u] = false;
        for (int i = H[u]; i; i = E[i].n)
        {
            int v = E[i].v, f = E[i].f, w = E[i].w;
            if (f && dist[u] + w < dist[v])
            {
                dist[v] = dist[u] + w;
                incf[v] = std::min(f, incf[u]);
                pre[v] = i;
                if (!st[v])
                {
                    Q[tt++] = v; tt %= N;
                    st[v] = true;
                }
            }
        }
    }

    return incf[T] > 0;
}

void EK(int& flow, int& cost)
{
    flow = cost = 0;
    while (spfa())
    {
        int t = incf[T];
        flow += t, cost += t * dist[T];
        for (int i = T; i != S; i = E[pre[i] ^ 1].v)
        {
            E[pre[i]].f -= t, E[pre[i] ^ 1].f += t;
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    int avg = 0;
    for (int i = 1; i <= n; i++)
    {
        cin >> stock[i];
        avg += stock[i];
    }
    avg /= n;  // avg | n

    for (int i = 1; i <= n; i++)
    {
        if (stock[i] > avg)
        {
            add(S, i, stock[i] - avg, 0);
        }
        else if (stock[i] < avg)
        {
            add(i, T, avg - stock[i], 0);
        }
        add(i, i < n ? i + 1 : 1, INF, 1);
        add(i, i > 1 ? i - 1 : n, INF, 1);
    }

    int flow, cost;
    EK(flow, cost);
    cout << cost << '\n';

    return 0;
}
```

### 二分图最优匹配

#### 分配问题

题目：https://www.acwing.com/problem/content/description/2195/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 110, M = (100 + 2500) * 2 + 10, INF = 1e8;

int n;
int S, T = N - 1;
int H[N];
struct EdgeNode
{
    int v, f, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int f, int w)
{
    E[++idx] = { b, f, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, -w, H[b] }, H[b] = idx;
}

int incf[N], dist[N], pre[N];
bool st[N];
int Q[N];

bool spfa()
{
    memset(incf, 0, sizeof incf);
    memset(dist, 0x3f, sizeof dist);
    incf[S] = INF, dist[S] = 0;
    int hh = 0, tt = 0;
    Q[tt++] = S;
    st[S] = true;

    while (hh != tt)
    {
        int u = Q[hh++]; hh %= N;
        st[u] = false;

        for (int i = H[u]; i; i = E[i].n)
        {
            int v = E[i].v, w = E[i].w, f = E[i].f;
            if (f && dist[u] + w < dist[v])
            {
                dist[v] = dist[u] + w;
                incf[v] = std::min(f, incf[u]);
                pre[v] = i;
                if (!st[v])
                {
                    Q[tt++] = v; tt %= N;
                    st[v] = true;
                }
            }
        }
    }
    return incf[T] > 0;
}

void EK(int& flow, int& cost)
{
    flow = cost = 0;
    while (spfa())
    {
        int t = incf[T];
        flow += t, cost += t * dist[T];
        for (int i = T; i != S; i = E[pre[i] ^ 1].v)
        {
            E[pre[i]].f -= t, E[pre[i] ^ 1].f += t;
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    for (int i = 1; i <= n; i++) add(S, i, 1, 0);
    for (int i = 1; i <= n; i++) add(n + i, T, 1, 0);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
        {
            int w; cin >> w;
            add(i, n + j, 1, w);
        }

    int flow, cost;
    EK(flow, cost);
    cout << cost << '\n';

    for (int i = 2; i <= idx; i += 2)
    {
        E[i].f += E[i ^ 1].f; E[i ^ 1].f = 0;
        E[i].w = -E[i].w, E[i ^ 1].w = -E[i ^ 1].w;
    }
    EK(flow, cost);
    cout << -cost << '\n';

    return 0;
}
```

### 最大权不相交路径

#### 数字梯形问题

题目：https://www.acwing.com/problem/content/description/2193/

题解：https://www.acwing.com/solution/content/135875/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1200, M = 4000, INF = 1e8;

int n, m;
int S, T = N - 1;
int tot, id[40][40], W[40][40];  // 用于建图
int H[N];
struct EdgeNode
{
    int v, f, w, n;
} E[M];
int idx;

void clear()
{
    memset(H, 0, sizeof H);
    idx = 1;
}

void add(int a, int b, int f, int w)
{
    E[++idx] = { b, f, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, -w, H[b] }, H[b] = idx;
}

void build(int in, int out, int last)
{
    clear();

    for (int i = 0; i < n; i++)
        for (int j = 0; j < m + i; j++)
        {
            add(id[i][j], tot + id[i][j], in, W[i][j]);
            if (i == 0) add(S, id[i][j], 1, 0);
            if (i < n - 1)
            {
                add(tot + id[i][j], id[i + 1][j], out, 0);
                add(tot + id[i][j], id[i + 1][j + 1], out, 0);
            }
            else
            {
                add(tot + id[i][j], T, last, 0);
            }
        }
}

int incf[N], dist[N], pre[N];
bool st[N];
int Q[N];

bool spfa()
{
    memset(incf, 0, sizeof incf);
    memset(dist, -0x3f, sizeof dist);
    incf[S] = INF, dist[S] = 0;
    int hh = 0, tt = 0;
    Q[tt++] = S;
    st[S] = true;

    while (hh != tt)
    {
        int u = Q[hh++]; hh %= N;
        st[u] = false;
        for (int i = H[u]; i; i = E[i].n)
        {
            int v = E[i].v, w = E[i].w, f = E[i].f;
            if (f && dist[u] + w > dist[v])
            {
                dist[v] = dist[u] + w;
                incf[v] = std::min(f, incf[u]);
                pre[v] = i;
                if (!st[v])
                {
                    Q[tt++] = v; tt %= N;
                    st[v] = true;
                }
            }
        }
    }

    return incf[T] > 0;
}

void EK(int& flow, int& cost)
{
    flow = cost = 0;
    while (spfa())
    {
        int t = incf[T];
        flow += t, cost += t * dist[T];
        for (int i = T; i != S; i = E[pre[i] ^ 1].v)
        {
            E[pre[i]].f -= t, E[pre[i] ^ 1].f += t;
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> m >> n;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m + i; j++)
        {
            cin >> W[i][j];
            id[i][j] = ++tot;
        }

    int flow, cost;

    build(1, 1, 1);
    EK(flow, cost);
    cout << cost << '\n';

    build(INF, 1, INF);
    EK(flow, cost);
    cout << cost << '\n';

    build(INF, INF, INF);
    EK(flow, cost);
    cout << cost << '\n';

    return 0;
}
```

### 网格图模型

#### K取方格数

题目：https://www.acwing.com/problem/content/description/384/

题解：https://www.acwing.com/solution/content/137590/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 5010, M = 2500 * 4 * 2 + 10, INF = 1e8;

int n, k_;
int S = N - 2, T = N - 1;
int H[N];
struct EdgeNode
{
    int v, f, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int f, int w)
{
    E[++idx] = { b, f, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, -w, H[b] }, H[b] = idx;
}

int get(int x, int y, int t)
{
    return x * n + y + t * n * n;
}

int incf[N], dist[N], pre[N];
bool st[N];
int Q[N];

bool spfa()
{
    memset(incf, 0, sizeof incf);
    memset(dist, -0x3f, sizeof dist);
    incf[S] = INF, dist[S] = 0;
    int hh = 0, tt = 0;
    Q[tt++] = S;
    st[S] = true;

    while (hh != tt)
    {
        int u = Q[hh++]; hh %= N;
        st[u] = false;
        for (int i = H[u]; i; i = E[i].n)
        {
            int v = E[i].v, w = E[i].w, f = E[i].f;
            if (f && dist[u] + w > dist[v])
            {
                dist[v] = dist[u] + w;
                incf[v] = std::min(f, incf[u]);
                pre[v] = i;
                if (!st[v])
                {
                    Q[tt++] = v; tt %= N;
                    st[v] = true;
                }
            }
        }
    }

    return incf[T] > 0;
}

int EK()
{
    int cost = 0;
    while (spfa())
    {
        int t = incf[T];
        cost += t * dist[T];
        for (int i = T; i != S; i = E[pre[i] ^ 1].v)
        {
            E[pre[i]].f -= t, E[pre[i] ^ 1].f += t;
        }
    }

    return cost;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> k_;
    add(S, get(0, 0, 0), k_, 0);
    add(get(n - 1, n - 1, 1), T, k_, 0);
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
        {
            int w; cin >> w;
            int u = get(i, j, 0), v = get(i, j, 1);
            add(u, v, 1, w), add(u, v, INF, 0);
            if (i < n - 1) add(v, get(i + 1, j, 0), INF, 0);
            if (j < n - 1) add(v, get(i, j + 1, 0), INF, 0);
        }

    cout << EK() << '\n';

    return 0;
}
```

#### 深海机器人问题

题目：https://www.acwing.com/problem/content/description/2197/

题解：https://www.acwing.com/solution/content/137607/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 260, M = 970 * 2 + 10, INF = 1e8;

int n, m, s, t;
int S = N - 2, T = N - 1;
int H[N];
struct EdgeNode
{
    int v, f, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int f, int w)
{
    E[++idx] = { b, f, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, -w, H[b] }, H[b] = idx;
}

int get(int x, int y)
{
    return x * (m + 1) + y;
}

int incf[N], dist[N], pre[N];
bool st[N];
int Q[N];

bool spfa()
{
    memset(incf, 0, sizeof incf);
    memset(dist, -0x3f, sizeof dist);
    dist[S] = 0, incf[S] = INF;
    int hh = 0, tt = 0;
    Q[tt++] = S; tt %= N;
    st[S] = true;

    while (hh != tt)
    {
        int u = Q[hh++]; hh %= N;
        st[u] = false;
        for (int i = H[u]; i; i = E[i].n)
        {
            int v = E[i].v, w = E[i].w, f = E[i].f;
            if (f && dist[u] + w > dist[v])
            {
                dist[v] = dist[u] + w;
                incf[v] = std::min(f, incf[u]);
                pre[v] = i;
                if (!st[v])
                {
                    Q[tt++] = v; tt %= N;
                    st[v] = true;
                }
            }
        }
    }

    return incf[T] > 0;
}

int EK()
{
    int cost = 0;
    while (spfa())
    {
        int t = incf[T];
        cost += t * dist[T];
        for (int i = T; i != S; i = E[pre[i] ^ 1].v)
        {
            E[pre[i]].f -= t, E[pre[i] ^ 1].f += t;
        }
    }
    return cost;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> s >> t >> n >> m;
    for (int i = 0; i <= n; i++)
        for (int j = 0; j < m; j++)
        {
            int w; cin >> w;
            int a = get(i, j), b = get(i, j + 1);
            add(a, b, 1, w), add(a, b, INF, 0);
        }
    for (int i = 0; i <= m; i++)
        for (int j = 0; j < n; j++)
        {
            int w; cin >> w;
            int a = get(j, i), b = get(j + 1, i);
            add(a, b, 1, w), add(a, b, INF, 0);
        }
    for (int i = 0; i < s; i++)
    {
        int f, x, y; cin >> f >> x >> y;
        add(S, get(x, y), f, 0);
    }
    for (int i = 0; i < t; i++)
    {
        int f, x, y; cin >> f >> x >> y;
        add(get(x, y), T, f, 0);
    }

    cout << EK() << '\n';

    return 0;
}
```

### 拆点

#### 餐巾计划问题

题目：https://www.acwing.com/problem/content/description/2186/

题解：https://www.acwing.com/solution/content/137765/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1610, M = 800 * 6 * 2 + 10, INF = 1e8;

int n, p, m, mp, r, rp;
int S, T = N - 1;
int H[N];
struct EdgeNode
{
    int v, f, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int f, int w)
{
    E[++idx] = { b, f, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, -w, H[b] }, H[b] = idx;
}

int incf[N], dist[N], pre[N];
bool st[N];
int Q[N];

bool spfa()
{
    memset(incf, 0, sizeof incf);
    memset(dist, 0x3f, sizeof dist);
    incf[S] = INF, dist[S] = 0;
    int hh = 0, tt = 0;
    Q[tt++] = S;
    st[S] = true;

    while (hh != tt)
    {
        int u = Q[hh++]; hh %= N;
        st[u] = false;

        for (int i = H[u]; i; i = E[i].n)
        {
            int v = E[i].v, w = E[i].w, f = E[i].f;
            if (f && dist[u] + w < dist[v])
            {
                dist[v] = dist[u] + w;
                incf[v] = std::min(f, incf[u]);
                pre[v] = i;
                if (!st[v])
                {
                    Q[tt++] = v; tt %= N;
                    st[v] = true;
                }
            }
        }
    }

    return incf[T] > 0;
}

int EK()
{
    int cost = 0;
    while (spfa())
    {
        int t = incf[T];
        cost += t * dist[T];
        for (int i = T; i != S; i = E[pre[i] ^ 1].v)
        {
            E[pre[i]].f -= t, E[pre[i] ^ 1].f += t;
        }
    }
    return cost;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> p >> m >> mp >> r >> rp;
    for (int i = 1; i <= n; i++)
    {
        int t; cin >> t;
        add(S, i, t, 0);
        if (i + 1 <= n) add(i, i + 1, INF, 0);
        if (m + i <= n) add(i, n + m + i, INF, mp);
        if (r + i <= n) add(i, n + r + i, INF, rp);
        add(S, n + i, t, p);
        add(n + i, T, t, 0);
    }

    cout << EK() << '\n';

    return 0;
}
```

### 上下界可行流

#### 志愿者招募

题目：https://www.acwing.com/problem/content/description/971/

题解：https://www.acwing.com/solution/content/137773/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1010, M = (1000 * 2 + 10000) * 2 + 10, INF = 1e8;

int n, m;
int S, T = N - 1;
int H[N];
struct EdgeNode
{
    int v, f, w, n;
} E[M];
int idx = 1;

void add(int a, int b, int f, int w)
{
    E[++idx] = { b, f, w, H[a] }, H[a] = idx;
    E[++idx] = { a, 0, -w, H[b] }, H[b] = idx;
}

int incf[N], dist[N], pre[N];
bool st[N];
int Q[N];

bool spfa()
{
    memset(incf, 0, sizeof incf);
    memset(dist, 0x3f, sizeof dist);
    incf[S] = INF, dist[S] = 0;
    int hh = 0, tt = 0;
    Q[tt++] = S;
    st[S] = true;

    while (hh != tt)
    {
        int u = Q[hh++]; hh %= N;
        st[u] = false;

        for (int i = H[u]; i; i = E[i].n)
        {
            int v = E[i].v, w = E[i].w, f = E[i].f;
            if (f && dist[u] + w < dist[v])
            {
                dist[v] = dist[u] + w;
                incf[v] = std::min(f, incf[u]);
                pre[v] = i;
                if (!st[v])
                {
                    Q[tt++] = v; tt %= N;
                    st[v] = true;
                }
            }
        }
    }

    return incf[T] > 0;
}

int EK()
{
    int cost = 0;
    while (spfa())
    {
        int t = incf[T];
        cost += t * dist[T];
        for (int i = T; i != S; i = E[pre[i] ^ 1].v)
        {
            E[pre[i]].f -= t, E[pre[i] ^ 1].f += t;
        }
    }
    return cost;
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    int c1 = 0;
    for (int i = 1; i <= n; i++)
    {
        int c2; cin >> c2;
        add(i, i + 1, INF, 0);
        if (c1 > c2) add(S, i, c1 - c2, 0);
        else if (c1 < c2) add(i, T, c2 - c1, 0);
        c1 = c2;
    }
    add(S, n + 1, c1, 0);
    for (int i = 0; i < m; i++)
    {
        int a, b, w; cin >> a >> b >> w;
        add(b + 1, a, INF, w);
    }

    cout << EK() << '\n';

    return 0;
}
```

## 2-SAT

### 2-SAT 问题

题目：https://www.acwing.com/problem/content/description/2404/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 2e6 + 5, M = N;

int n, m;
int H[N];
struct EdgeNode
{
    int v, n;
} E[M];
int idx;

void add(int a, int b)
{
    E[++idx] = { b, H[a] }, H[a] = idx;
}

int dfn[N], low[N], ts;
int stk[N], top;
bool inStk[N];
int scc[N], cnt;

void Tarjan(int u)
{
    stk[++top] = u;
    inStk[u] = true;
    dfn[u] = low[u] = ++ts;
    
    for (int i = H[u]; i; i = E[i].n)
    {
        int v = E[i].v;
        if (dfn[v] == 0)
        {
            Tarjan(v);
            low[u] = std::min(low[u], low[v]);
        }
        else if (inStk[v])
        {
            low[u] = std::min(low[u], dfn[v]);
        }
    }

    if (dfn[u] == low[u])
    {
        cnt++;
        int v = -1;
        while (v != u)
        {
            v = stk[top--];
            inStk[v] = false;
            scc[v] = cnt;
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, va, b, vb; cin >> a >> va >> b >> vb;
        add(a + (va ^ 1) * n, b + vb * n);
        add(b + (vb ^ 1) * n, a + va * n);
    }

    for (int i = 1; i <= n * 2; i++)
        if (dfn[i] == 0)
            Tarjan(i);

    for (int i = 1; i <= n; i++)
        if (scc[i] == scc[i + n])
        {
            cout << "IMPOSSIBLE" << '\n';
            return 0;
        }

    cout << "POSSIBLE" << '\n';
    for (int i = 1; i <= n; i++)
    {
        if (scc[i] < scc[i + n]) cout << 0 << ' ';
        else cout << 1 << ' ';
    }
    cout << '\n';

    return 0;
}
```

### 牧师约翰最忙碌的一天

题目：https://www.acwing.com/problem/content/description/373/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;

const int N = 2010, M = N * (N - 1);

int n;
struct Wedding
{
    int s, t, d;
} W[1010];
int H[N];
struct EdgeNode
{
    int v, n;
} E[M];
int idx;

void add(int a, int b)
{
    E[++idx] = { b, H[a] }, H[a] = idx;
}

bool isOverlap(int a, int b, int c, int d)
{
    return c < b && a < d;
}

int dfn[N], low[N], ts;
int stk[N], top;
bool inStk[N];
int scc[N], cnt;

void Tarjan(int u)
{
    dfn[u] = low[u] = ++ts;
    stk[++top] = u;
    inStk[u] = true;

    for (int i = H[u]; i; i = E[i].n)
    {
        int v = E[i].v;
        if (dfn[v] == 0)
        {
            Tarjan(v);
            low[u] = std::min(low[u], low[v]);
        }
        else if (inStk[v])
        {
            low[u] = std::min(low[u], dfn[v]);
        }
    }

    if (dfn[u] == low[u])
    {
        cnt++;
        int v = -1;
        while (v != u)
        {
            v = stk[top--];
            inStk[v] = false;
            scc[v] = cnt;
        }
    }
}

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i++)
    {
        int s, t, d;
        int hh, mm; 
        scanf("%d:%d", &hh, &mm); s = hh * 60 + mm;
        scanf("%d:%d", &hh, &mm); t = hh * 60 + mm;
        scanf("%d", &d);
        W[i] = { s, t, d };
    }
    for (int i = 0; i < n; i++)
        for (int j = 0; j < i; j++)
        {
            auto& a = W[i], & b = W[j];
            if (isOverlap(a.s, a.s + a.d, b.s, b.s + b.d)) add(i, j + n), add(j, i + n);
            if (isOverlap(a.s, a.s + a.d, b.t - b.d, b.t)) add(i, j), add(j + n, i + n);
            if (isOverlap(a.t - a.d, a.t, b.s, b.s + b.d)) add(i + n, j + n), add(j, i);
            if (isOverlap(a.t - a.d, a.t, b.t - b.d, b.t)) add(i + n, j), add(j + n, i);
        }

    for (int i = 0; i < n * 2; i++)
        if (dfn[i] == 0)
            Tarjan(i);

    for (int i = 0; i < n; i++)
        if (scc[i] == scc[i + n])
        {
            puts("NO");
            return 0;
        }

    puts("YES");
    for (int i = 0; i < n; i++)
    {
        auto [s, t, d] = W[i];
        if (scc[i] < scc[i + n])
            printf("%02d:%02d %02d:%02d\n", s / 60, s % 60, (s + d) / 60, (s + d) % 60);
        else
            printf("%02d:%02d %02d:%02d\n", (t - d) / 60, (t - d) % 60, t / 60, t % 60);
    }

    return 0;
}
```

### 游戏

题目：https://www.acwing.com/problem/content/description/1034/

题解：https://www.acwing.com/solution/content/138505/

该代码需要开启O2优化，或者inline两个辅助函数`car2bool`和`bool2car`。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 5e4 + 5, M = 1e5 + 5;

int n, d, m;
char game[N];
struct Rule
{
    int i, j;
    char hi, hj;
} R[M];
int xPos[10];

int H[N * 2];
struct EdgeNode
{
    int v, n;
} E[M * 2];
int idx;

void add(int a, int b)
{
    E[++idx] = { b, H[a] }, H[a] = idx;
}

int dfn[N * 2], low[N * 2], ts;
int stk[N * 2], top;
bool inStk[N * 2];
int scc[N * 2], cnt;

void Tarjan(int u)
{
    stk[++top] = u;
    inStk[u] = true;
    dfn[u] = low[u] = ++ts;

    for (int i = H[u]; i; i = E[i].n)
    {
        int v = E[i].v;
        if (dfn[v] == 0)
        {
            Tarjan(v);
            low[u] = std::min(low[u], low[v]);
        }
        else if (inStk[v])
        {
            low[u] = std::min(low[u], dfn[v]);
        }
    }

    if (dfn[u] == low[u])
    {
        cnt++;
        int v = -1;
        while (v != u)
        {
            v = stk[top--];
            inStk[v] = false;
            scc[v] = cnt;
        }
    }
}

bool car2bool(char g, char c)  // 对游戏g来说，赛车c是2-SAT中的true还是false
{
    int offset = g - 'a';
    offset = (offset + 2) % 3;
    return c == 'A' + offset;
}

char bool2car(char g, bool b)  // 对游戏g来说，2-SAT中的布尔值b是哪种赛车
{
    int offset = g - 'a';
    offset = (offset + 1 + b) % 3;
    return 'A' + offset;
}

int get(int i, char c, bool choose)
{
    bool b = car2bool(game[i], c);
    if (!choose) b = !b;
    return i + b * n;
}

bool twoSAT()
{
    idx = 0;
    memset(H, 0, sizeof H);

    for (int k = 0; k < m; k++)
    {
        auto [i, j, hi, hj] = R[k];
        if (hi != game[i] - 'a' + 'A')
        {
            if (hj != game[j] - 'a' + 'A')
            {
                add(get(i, hi, true), get(j, hj, true));
                add(get(j, hj, false), get(i, hi, false));
            }
            else
            {
                add(get(i, hi, true), get(i, hi, false));
            }
        }
    }

    memset(dfn, 0, sizeof dfn);
    memset(low, 0, sizeof low);
    ts = cnt = 0;

    for (int i = 0; i < n * 2; i++)
        if (dfn[i] == 0)
            Tarjan(i);

    for (int i = 0; i < n; i++)
        if (scc[i] == scc[i + n])
            return false;

    return true;
}


int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> d;
    cin >> game;
    for (int i = 0, j = 0; i < n; i++)
        if (game[i] == 'x')
        {
            xPos[j++] = i;
        }
    cin >> m;
    for (int k = 0; k < m; k++)
    {
        int i, j; 
        char hi, hj;
        cin >> i >> hi >> j >> hj;
        R[k] = { i - 1, j - 1, hi, hj };
    }

    for (int i = 0; i < (1 << d); i++)  // 二进制枚举
    {
        for (int j = 0; j < d; j++)
        {
            if (i >> j & 1) game[xPos[j]] = 'a';
            else game[xPos[j]] = 'c';
        }

        if (twoSAT())
        {
            for (int i = 0; i < n; i++)
            {
                cout << bool2car(game[i], scc[i] > scc[i + n]);
            }
            cout << '\n';
            return 0;
        }
    }

    cout << -1 << '\n';
    return 0;
}
```

## 朱刘算法

### 指挥网络

题目：https://www.acwing.com/problem/content/description/2419/

题解：https://www.acwing.com/solution/content/274465/

```c++
#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 110;
const double INF = 1e6;

int n, m;
struct Point
{
    int x, y;
} P[N];
bool G[N][N];
double dist[N][N];

int pre[N];

int dfn[N], low[N], ts;
int stk[N], top;
bool inStk[N];
int scc[N], cnt;

void Tarjan(int u)
{
    dfn[u] = low[u] = ++ts;
    stk[++top] = u;
    inStk[u] = true;

    int v = pre[u];  // 在反向图上做Tarjan，不影响判环
    if (dfn[v] == 0)
    {
        Tarjan(v);
        low[u] = std::min(low[u], low[v]);
    }
    else if (inStk[v])
    {
        low[u] = std::min(low[u], dfn[v]);
    }

    if (dfn[u] == low[u])
    {
        cnt++;
        int x;
        do
        {
            x = stk[top--];
            inStk[x] = false;
            scc[x] = cnt;
        } while (x != u);
    }
}

double ZhuLiu()
{
    double res = 0;

    while (true)
    {
        for (int i = 1; i <= n; i++) pre[i] = i;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                if (dist[j][i] < dist[pre[i]][i])
                {
                    pre[i] = j;
                }

        memset(dfn, 0, sizeof dfn);
        //memset(low, 0, sizeof low);
        ts = cnt = 0;
        for (int i = 1; i <= n; i++)
            if (dfn[i] == 0)
                Tarjan(i);

        if (cnt == n)
        {
            for (int i = 2; i <= n; i++) res += dist[pre[i]][i];
            return res;
        }

        for (int i = 2; i <= n; i++)
            if (scc[i] == scc[pre[i]])
                res += dist[pre[i]][i];

        static double tmp[N][N];
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                tmp[i][j] = INF;

        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                if (dist[i][j] < INF && scc[i] != scc[j])
                {
                    int a = scc[i], b = scc[j];
                    if (scc[j] == scc[pre[j]])
                        tmp[a][b] = std::min(tmp[a][b], dist[i][j] - dist[pre[j]][j]);
                    else tmp[a][b] = std::min(tmp[a][b], dist[i][j]);
                }

        memcpy(dist, tmp, sizeof dist);
        n = cnt;
    }

    return -1;
}

bool st[N];

void dfs(int u)
{
    st[u] = true;
    for (int i = 1; i <= n; i++)
        if (G[u][i] && !st[i])
        {
            dfs(i);
        }
}

void solve()
{
    for (int i = 1; i <= n; i++)
    {
        int x, y; cin >> x >> y;
        P[i] = { x, y };
    }
    memset(G, 0, sizeof G);
    for (int i = 0; i < m; i++)
    {
        int a, b; cin >> a >> b;
        if (a != b && b != 1) G[a][b] = true;  // 为了正确地求出pre，pre[1]必须是1否则影响判环
    }

    memset(st, 0, sizeof st);
    dfs(1);

    for (int i = 1; i <= n; i++)
        if (!st[i])
        {
            printf("poor snoopy\n");
            return;
        }

    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
        {
            if (G[i][j])
            {
                auto [ax, ay] = P[i];
                auto [bx, by] = P[j];
                double dx = ax - bx, dy = ay - by;
                dist[i][j] = sqrt(dx * dx + dy * dy);
            }
            else dist[i][j] = INF;
        }

    printf("%.2lf\n", ZhuLiu());
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    while (cin >> n >> m)
        solve();

    return 0;
}
```

## Prufer编码

### prufer序列

题目：https://www.acwing.com/problem/content/2421/

题解：https://www.acwing.com/solution/content/50439/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 1e5 + 5;

int n, m;
int p[N], f[N];
int dout[N];

void tree2prufer()
{
    for (int i = 1; i <= n - 1; i++)
    {
        cin >> f[i];
        dout[f[i]]++;
    }

    for (int i = 0, j = 1; i < n - 2; j++)
    {
        while (dout[j]) j++;
        p[i++] = f[j];
        while (i < n - 2 && --dout[p[i - 1]] == 0 && p[i - 1] < j)
        {
            p[i] = f[p[i - 1]];
            i++;
        }
    }

    for (int i = 0; i < n - 2; i++) cout << p[i] << ' ';
    cout << '\n';
}

void prufer2tree()
{
    for (int i = 0; i < n - 2; i++)
    {
        cin >> p[i];
        dout[p[i]]++;
    }
    p[n - 2] = n;
    //dout[n]++;

    for (int i = 0, j = 1; i < n - 1; i++, j++)
    {
        while (dout[j]) j++;
        f[j] = p[i];
        while (i < n - 1 && --dout[p[i]] == 0 && p[i] < j)
        {
            f[p[i]] = p[i + 1];
            i++;
        }
    }

    for (int i = 1; i <= n - 1; i++) cout << f[i] << ' ';
    cout << '\n';
}


int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    if (m == 1) tree2prufer();
    else prufer2tree();

    return 0;
}
```

### 光之大陆

题目：https://www.acwing.com/problem/content/description/2420/

题解：https://www.acwing.com/solution/content/139622/

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using LL = long long;
using std::cin, std::cout;

const int N = 210;

int n, m;
int f[N][N];
int C[N][N];
int g[N];

void init()
{
    for (int i = 0; i <= n; i++)
        for (int j = 0; j <= i; j++)
        {
            if (j == 0) C[i][j] = 1;
            else
            {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % m;
            }
        }

    g[1] = 1, g[3] = 3;
    for (int i = 4; i <= n; i++)
    {
        g[i] = g[i - 1] * i % m;
    }
}


int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n >> m;
    init();

    f[0][0] = 1;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= i; j++)
            for (int k = 1; k <= i - j + 1; k++)
            {
                f[i][j] = (f[i][j] + LL(f[i - k][j - 1]) * g[k] * C[i - 1][k - 1]) % m;
            }

    int res = g[n - 1];
    int p = 1;
    for (int i = 2; i <= n; i++)
    {
        res = (res + LL(f[n][i]) * p) % m;
        p = p * n % m;
    }

    cout << res << '\n';

    return 0;
}
```

